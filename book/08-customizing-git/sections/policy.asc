[[_an_example_git_enforced_policy]]
=== Một Ví dụ về Chính sách được Thực thi bởi Git

(((policy example)))
Trong phần này, bạn sẽ sử dụng những gì bạn đã học để thiết lập một quy trình làm việc Git kiểm tra định dạng thông điệp commit tùy chỉnh, và chỉ cho phép một số người dùng nhất định sửa đổi các thư mục con nhất định trong một dự án.
Bạn sẽ xây dựng các tập tin kịch bản phía máy khách giúp nhà phát triển biết liệu lần đẩy của họ có bị từ chối hay không và các tập tin kịch bản phía máy chủ thực sự thực thi các chính sách.

Các tập tin kịch bản chúng tôi sẽ hiển thị được viết bằng Ruby; một phần vì quán tính trí tuệ của chúng tôi, nhưng cũng vì Ruby dễ đọc, ngay cả khi bạn không nhất thiết phải viết được nó.
Tuy nhiên, bất kỳ ngôn ngữ nào cũng sẽ hoạt động – tất cả các tập tin kịch bản móc mẫu được phân phối với Git đều bằng Perl hoặc Bash, vì vậy bạn cũng có thể xem nhiều ví dụ về các móc trong các ngôn ngữ đó bằng cách xem các mẫu.

==== Móc Phía Máy Chủ

Tất cả công việc phía máy chủ sẽ đi vào tập tin `update` trong thư mục `hooks` của bạn.
Móc `update` chạy một lần cho mỗi nhánh đang được đẩy và nhận ba đối số:

* Tên của tham chiếu đang được đẩy đến
* Bản sửa đổi cũ nơi nhánh đó đã ở
* Bản sửa đổi mới đang được đẩy

Bạn cũng có quyền truy cập vào người dùng đang thực hiện việc đẩy nếu việc đẩy đang được chạy qua SSH.
Nếu bạn đã cho phép mọi người kết nối với một người dùng duy nhất (như "`git`") thông qua xác thực khóa công khai, bạn có thể phải cung cấp cho người dùng đó một trình bao bọc shell xác định người dùng nào đang kết nối dựa trên khóa công khai, và thiết lập một biến môi trường cho phù hợp.
Ở đây chúng tôi sẽ giả định người dùng đang kết nối nằm trong biến môi trường `$USER`, vì vậy tập tin kịch bản cập nhật của bạn bắt đầu bằng cách thu thập tất cả thông tin bạn cần:

[source,ruby]
----
#!/usr/bin/env ruby

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV['USER']

puts "Enforcing Policies..."
puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"
----

Vâng, đó là các biến toàn cục.
Đừng phán xét – cách này dễ minh họa hơn.

[[_enforcing_commit_message_format]]
===== Thực thi một Định dạng Thông điệp Commit Cụ thể

Thách thức đầu tiên của bạn là thực thi việc mỗi thông điệp commit tuân thủ một định dạng cụ thể.
Chỉ để có một mục tiêu, giả sử rằng mỗi thông điệp phải bao gồm một chuỗi trông giống như "`ref: 1234`" bởi vì bạn muốn mỗi commit liên kết đến một mục công việc trong hệ thống bán vé của bạn.
Bạn phải xem xét từng commit đang được đẩy lên, xem chuỗi đó có trong thông điệp commit hay không, và, nếu chuỗi đó vắng mặt trong bất kỳ commit nào, hãy thoát với mã khác không để lần đẩy bị từ chối.

Bạn có thể lấy danh sách các giá trị SHA-1 của tất cả các commit đang được đẩy bằng cách lấy các giá trị `$newrev` và `$oldrev` và chuyển chúng cho một lệnh plumbing của Git gọi là `git rev-list`.
Về cơ bản đây là lệnh `git log`, nhưng theo mặc định nó chỉ in ra các giá trị SHA-1 và không có thông tin nào khác.
Vì vậy, để lấy danh sách tất cả các SHA-1 commit được giới thiệu giữa một SHA-1 commit này và một cái khác, bạn có thể chạy một cái gì đó như thế này:

[source,console]
----
$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475
----

Bạn có thể lấy đầu ra đó, lặp qua từng SHA-1 commit đó, lấy thông điệp cho nó, và kiểm tra thông điệp đó so với một biểu thức chính quy tìm kiếm một mẫu.

Bạn phải tìm ra cách lấy thông điệp commit từ mỗi commit này để kiểm tra.
Để lấy dữ liệu commit thô, bạn có thể sử dụng một lệnh plumbing khác gọi là `git cat-file`.
Chúng tôi sẽ xem xét tất cả các lệnh plumbing này một cách chi tiết trong <<ch10-git-internals#ch10-git-internals>>; nhưng hiện tại, đây là những gì lệnh đó cung cấp cho bạn:

[source,console]
----
$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

Change the version number
----

Một cách đơn giản để lấy thông điệp commit từ một commit khi bạn có giá trị SHA-1 là đi đến dòng trống đầu tiên và lấy mọi thứ sau đó.
Bạn có thể làm như vậy với lệnh `sed` trên các hệ thống Unix:

[source,console]
----
$ git cat-file commit ca82a6 | sed '1,/^$/d'
Change the version number
----

Bạn có thể sử dụng câu thần chú đó để lấy thông điệp commit từ mỗi commit đang cố gắng được đẩy và thoát nếu bạn thấy bất cứ điều gì không khớp.
Để thoát khỏi tập tin kịch bản và từ chối lần đẩy, hãy thoát với mã khác không.
Toàn bộ phương pháp trông giống như thế này:

[source,ruby]
----
$regex = /\[ref: (\d+)\]/

# enforced custom commit message format
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[POLICY] Your message is not formatted correctly"
      exit 1
    end
  end
end
check_message_format
----

Đặt cái đó vào tập tin kịch bản `update` của bạn sẽ từ chối các bản cập nhật chứa các commit có thông điệp không tuân thủ quy tắc của bạn.

===== Thực thi Hệ thống ACL Dựa trên Người dùng

Giả sử bạn muốn thêm một cơ chế sử dụng danh sách kiểm soát truy cập (ACL) chỉ định người dùng nào được phép đẩy các thay đổi đến phần nào của dự án của bạn.
Một số người có quyền truy cập đầy đủ, và những người khác chỉ có thể đẩy các thay đổi đến các thư mục con nhất định hoặc các tập tin cụ thể.
Để thực thi điều này, bạn sẽ viết các quy tắc đó vào một tập tin có tên `acl` nằm trong kho chứa Git bare của bạn trên máy chủ.
Bạn sẽ để móc `update` xem xét các quy tắc đó, xem những tập tin nào đang được giới thiệu cho tất cả các commit đang được đẩy, và xác định xem người dùng thực hiện việc đẩy có quyền cập nhật tất cả các tập tin đó hay không.

Điều đầu tiên bạn sẽ làm là viết ACL của mình.
Ở đây bạn sẽ sử dụng một định dạng rất giống với cơ chế ACL của CVS: nó sử dụng một loạt các dòng, trong đó trường đầu tiên là `avail` hoặc `unavail`, trường tiếp theo là danh sách người dùng được phân tách bằng dấu phẩy mà quy tắc áp dụng, và trường cuối cùng là đường dẫn mà quy tắc áp dụng (trống có nghĩa là truy cập mở).
Tất cả các trường này được phân tách bằng ký tự ống (`|`).

Trong trường hợp này, bạn có một vài quản trị viên, một số người viết tài liệu có quyền truy cập vào thư mục `doc`, và một nhà phát triển chỉ có quyền truy cập vào các thư mục `lib` và `tests`, và tập tin ACL của bạn trông giống như thế này:

[source]
----
avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests
----

Bạn bắt đầu bằng cách đọc dữ liệu này vào một cấu trúc mà bạn có thể sử dụng.
Trong trường hợp này, để giữ cho ví dụ đơn giản, bạn sẽ chỉ thực thi các chỉ thị `avail`.
Đây là một phương thức cung cấp cho bạn một mảng liên kết trong đó khóa là tên người dùng và giá trị là một mảng các đường dẫn mà người dùng có quyền ghi:

[source,ruby]
----
def get_acl_access_data(acl_file)
  # read in ACL data
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] << path
    end
  end
  access
end
----

Trên tập tin ACL bạn đã xem trước đó, phương thức `get_acl_access_data` này trả về một cấu trúc dữ liệu trông giống như thế này:

[source,ruby]
----
{"defunkt"=>[nil],
 "tpw"=>[nil],
 "nickh"=>[nil],
 "pjhyett"=>[nil],
 "schacon"=>["lib", "tests"],
 "cdickens"=>["doc"],
 "usinclair"=>["doc"],
 "ebronte"=>["doc"]}
----

Bây giờ bạn đã sắp xếp xong các quyền, bạn cần xác định những đường dẫn nào mà các commit đang được đẩy đã sửa đổi, để bạn có thể đảm bảo người dùng đang đẩy có quyền truy cập vào tất cả chúng.

Bạn có thể thấy khá dễ dàng những tập tin nào đã được sửa đổi trong một commit duy nhất với tùy chọn `--name-only` cho lệnh `git log` (được đề cập ngắn gọn trong <<ch02-git-basics-chapter#ch02-git-basics-chapter>>):

[source,console]
----
$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb
----

Nếu bạn sử dụng cấu trúc ACL được trả về từ phương thức `get_acl_access_data` và kiểm tra nó so với các tập tin được liệt kê trong mỗi commit, bạn có thể xác định xem người dùng có quyền truy cập để đẩy tất cả các commit của họ hay không:

[source,ruby]
----
# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('acl')

  # see if anyone is trying to push something they can't
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path  # user has access to everything
           || (path.start_with? access_path) # access to this path
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[POLICY] You do not have access to push to #{path}"
        exit 1
      end
    end
  end
end

check_directory_perms
----

Bạn nhận được danh sách các commit mới đang được đẩy lên máy chủ của mình với `git rev-list`.
Sau đó, đối với mỗi commit đó, bạn tìm tập tin nào được sửa đổi và đảm bảo người dùng đang đẩy có quyền truy cập vào tất cả các đường dẫn đang được sửa đổi.

Bây giờ người dùng của bạn không thể đẩy bất kỳ commit nào với thông điệp được định dạng sai hoặc với các tập tin được sửa đổi bên ngoài đường dẫn được chỉ định của họ.

===== Kiểm tra Thử

Nếu bạn chạy `chmod u+x .git/hooks/update`, đây là tập tin mà bạn lẽ ra phải đặt tất cả mã này vào, và sau đó cố gắng đẩy một commit với thông điệp không tuân thủ, bạn sẽ nhận được một cái gì đó như thế này:

[source,console]
----
$ git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----

Có một vài điều thú vị ở đây.
Đầu tiên, bạn thấy điều này nơi móc bắt đầu chạy.

[source,console]
----
Enforcing Policies...
(refs/heads/master) (fb8c72) (c56860)
----

Hãy nhớ rằng bạn đã in ra điều đó ngay từ đầu tập tin kịch bản cập nhật của mình.
Bất cứ điều gì tập tin kịch bản của bạn echo ra `stdout` sẽ được chuyển đến máy khách.

Điều tiếp theo bạn sẽ nhận thấy là thông báo lỗi.

[source,console]
----
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
----

Dòng đầu tiên được in ra bởi bạn, hai dòng còn lại là Git nói với bạn rằng tập tin kịch bản cập nhật đã thoát với mã khác không và đó là lý do từ chối lần đẩy của bạn.
Cuối cùng, bạn có cái này:

[source,console]
----
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----

Bạn sẽ thấy thông báo từ chối từ xa cho mỗi tham chiếu mà móc của bạn đã từ chối, và nó cho bạn biết rằng nó đã bị từ chối cụ thể vì lỗi móc.

Hơn nữa, nếu ai đó cố gắng chỉnh sửa một tập tin mà họ không có quyền truy cập và đẩy một commit chứa nó, họ sẽ thấy một cái gì đó tương tự.
Ví dụ, nếu một tác giả tài liệu cố gắng đẩy một commit sửa đổi thứ gì đó trong thư mục `lib`, họ sẽ thấy:

[source,console]
----
[POLICY] You do not have access to push to lib/test.rb
----

Từ giờ trở đi, miễn là tập tin kịch bản `update` đó ở đó và có thể thực thi được, kho chứa của bạn sẽ không bao giờ có một thông điệp commit nào mà không có mẫu của bạn trong đó, và người dùng của bạn sẽ bị đóng hộp (sandboxed).

==== Móc Phía Máy Khách

Nhược điểm của phương pháp này là sự than vãn chắc chắn sẽ xảy ra khi các lần đẩy commit của người dùng của bạn bị từ chối.
Việc công việc được chế tác cẩn thận của họ bị từ chối vào phút cuối có thể cực kỳ bực bội và khó hiểu; và hơn nữa, họ sẽ phải chỉnh sửa lịch sử của mình để sửa nó, điều này không phải lúc nào cũng dành cho những người yếu tim.

Câu trả lời cho tình thế tiến thoái lưỡng nan này là cung cấp một số móc phía máy khách mà người dùng có thể chạy để thông báo cho họ khi họ đang làm điều gì đó mà máy chủ có khả năng từ chối.
Bằng cách đó, họ có thể sửa bất kỳ vấn đề nào trước khi commit và trước khi những vấn đề đó trở nên khó sửa hơn.
Bởi vì các móc không được chuyển cùng với bản sao (clone) của một dự án, bạn phải phân phối các tập tin kịch bản này theo một cách khác và sau đó yêu cầu người dùng của bạn sao chép chúng vào thư mục `.git/hooks` của họ và làm cho chúng có thể thực thi được.
Bạn có thể phân phối các móc này trong dự án hoặc trong một dự án riêng biệt, nhưng Git sẽ không tự động thiết lập chúng.

Để bắt đầu, bạn nên kiểm tra thông điệp commit của mình ngay trước khi mỗi commit được ghi lại, để bạn biết máy chủ sẽ không từ chối các thay đổi của bạn do các thông điệp commit được định dạng sai.
Để làm điều này, bạn có thể thêm móc `commit-msg`.
Nếu bạn để nó đọc thông điệp từ tập tin được truyền làm đối số đầu tiên và so sánh nó với mẫu, bạn có thể buộc Git hủy bỏ commit nếu không có sự trùng khớp:

[source,ruby]
----
#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[POLICY] Your message is not formatted correctly"
  exit 1
end
----

Nếu tập tin kịch bản đó ở đúng vị trí (trong `.git/hooks/commit-msg`) và có thể thực thi được, và bạn commit với một thông điệp không được định dạng đúng, bạn sẽ thấy điều này:

[source,console]
----
$ git commit -am 'Test'
[POLICY] Your message is not formatted correctly
----

Không có commit nào được hoàn thành trong trường hợp đó.
Tuy nhiên, nếu thông điệp của bạn chứa mẫu thích hợp, Git cho phép bạn commit:

[source,console]
----
$ git commit -am 'Test [ref: 132]'
[master e05c914] Test [ref: 132]
 1 file changed, 1 insertions(+), 0 deletions(-)
----

Tiếp theo, bạn muốn đảm bảo rằng bạn không sửa đổi các tập tin nằm ngoài phạm vi ACL của mình.
Nếu thư mục `.git` của dự án của bạn chứa một bản sao của tập tin ACL bạn đã sử dụng trước đó, thì tập tin kịch bản `pre-commit` sau đây sẽ thực thi các ràng buộc đó cho bạn:

[source,ruby]
----
#!/usr/bin/env ruby

$user    = ENV['USER']

# [ insert acl_access_data method from above ]

# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[POLICY] You do not have access to push to #{path}"
      exit 1
    end
  end
end

check_directory_perms
----

Đây gần như là cùng một tập tin kịch bản với phần phía máy chủ, nhưng với hai sự khác biệt quan trọng.
Đầu tiên, tập tin ACL ở một nơi khác, bởi vì tập tin kịch bản này chạy từ thư mục làm việc của bạn, không phải từ thư mục `.git` của bạn.
Bạn phải thay đổi đường dẫn đến tập tin ACL từ thế này:

[source,ruby]
----
access = get_acl_access_data('acl')
----

thành thế này:

[source,ruby]
----
access = get_acl_access_data('.git/acl')
----

Sự khác biệt quan trọng khác là cách bạn lấy danh sách các tập tin đã bị thay đổi.
Bởi vì phương pháp phía máy chủ xem xét nhật ký của các commit, và, tại thời điểm này, commit chưa được ghi lại, bạn phải lấy danh sách tập tin của mình từ khu vực tổ chức (staging area) thay thế.
Thay vì:

[source,ruby]
----
files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`
----

bạn phải sử dụng:

[source,ruby]
----
files_modified = `git diff-index --cached --name-only HEAD`
----

Nhưng đó là hai sự khác biệt duy nhất – nếu không, tập tin kịch bản hoạt động theo cùng một cách.
Một lưu ý là nó mong đợi bạn đang chạy cục bộ với tư cách là cùng một người dùng mà bạn đẩy lên máy từ xa.
Nếu khác nhau, bạn phải thiết lập biến `$user` một cách thủ công.

Một điều khác chúng ta có thể làm ở đây là đảm bảo người dùng không đẩy các tham chiếu không được tua nhanh (non-fast-forwarded).
Để có được một tham chiếu không phải là tua nhanh, bạn hoặc phải rebase qua một commit mà bạn đã đẩy lên hoặc cố gắng đẩy một nhánh cục bộ khác lên cùng một nhánh từ xa.

Có lẽ, máy chủ đã được cấu hình với `receive.denyDeletes` và `receive.denyNonFastForwards` để thực thi chính sách này, vì vậy điều tình cờ duy nhất bạn có thể cố gắng bắt là rebase các commit đã được đẩy.

Đây là một ví dụ về tập tin kịch bản pre-rebase kiểm tra điều đó.
Nó lấy danh sách tất cả các commit bạn sắp viết lại và kiểm tra xem chúng có tồn tại trong bất kỳ tham chiếu từ xa nào của bạn hay không.
Nếu nó thấy một cái có thể truy cập được từ một trong các tham chiếu từ xa của bạn, nó sẽ hủy bỏ việc rebase.

[source,ruby]
----
#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[POLICY] Commit #{sha} has already been pushed to #{remote_ref}"
      exit 1
    end
  end
end
----

Tập tin kịch bản này sử dụng một cú pháp chưa được đề cập trong <<ch07-git-tools#_revision_selection>>.
Bạn nhận được danh sách các commit đã được đẩy lên bằng cách chạy lệnh này:

[source,ruby]
----
`git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
----

Cú pháp `SHA^@` phân giải thành tất cả các cha của commit đó.
Bạn đang tìm kiếm bất kỳ commit nào có thể truy cập được từ commit cuối cùng trên máy từ xa và không thể truy cập được từ bất kỳ cha nào của bất kỳ SHA-1 nào bạn đang cố gắng đẩy lên – nghĩa là nó là một tua nhanh (fast-forward).

Hạn chế chính của phương pháp này là nó có thể rất chậm và thường không cần thiết – nếu bạn không cố gắng buộc việc đẩy bằng `-f`, máy chủ sẽ cảnh báo bạn và không chấp nhận lần đẩy.
Tuy nhiên, đó là một bài tập thú vị và về lý thuyết có thể giúp bạn tránh việc rebase mà sau này bạn có thể phải quay lại và sửa.
