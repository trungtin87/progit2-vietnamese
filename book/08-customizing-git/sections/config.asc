[[_git_config]]
=== Cấu hình Git

(((git commands, config)))
Như bạn đã đọc sơ qua trong <<ch01-getting-started#ch01-getting-started>>, bạn có thể chỉ định các thiết lập cấu hình Git bằng lệnh `git config`.
Một trong những điều đầu tiên bạn đã làm là thiết lập tên và địa chỉ email của mình:

[source,console]
----
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
----

Bây giờ bạn sẽ tìm hiểu một vài tùy chọn thú vị hơn mà bạn có thể thiết lập theo cách này để tùy chỉnh việc sử dụng Git của mình.

Đầu tiên, hãy ôn lại nhanh: Git sử dụng một loạt các tập tin cấu hình để xác định hành vi không mặc định mà bạn có thể muốn.
Nơi đầu tiên Git tìm các giá trị này là trong tập tin `[path]/etc/gitconfig` toàn hệ thống, chứa các thiết lập được áp dụng cho mọi người dùng trên hệ thống và tất cả các kho chứa của họ.
Nếu bạn truyền tùy chọn `--system` cho `git config`, nó sẽ đọc và ghi từ tập tin này một cách cụ thể.

Nơi tiếp theo Git tìm kiếm là tập tin `~/.gitconfig` (hoặc `~/.config/git/config`), tập tin này dành riêng cho từng người dùng.
Bạn có thể làm cho Git đọc và ghi vào tập tin này bằng cách truyền tùy chọn `--global`.

Cuối cùng, Git tìm kiếm các giá trị cấu hình trong tập tin cấu hình trong thư mục Git (`.git/config`) của bất kỳ kho chứa nào bạn đang sử dụng.
Các giá trị này dành riêng cho kho chứa đó, và đại diện cho việc truyền tùy chọn `--local` cho `git config`.
Nếu bạn không chỉ định cấp độ nào bạn muốn làm việc cùng, đây là mặc định.

Mỗi "`cấp độ`" này (hệ thống, toàn cục, cục bộ) sẽ ghi đè các giá trị ở cấp độ trước đó, vì vậy các giá trị trong `.git/config` sẽ thắng các giá trị trong `[path]/etc/gitconfig`, chẳng hạn.

[NOTE]
====
Các tập tin cấu hình của Git là văn bản thuần túy, vì vậy bạn cũng có thể thiết lập các giá trị này bằng cách chỉnh sửa thủ công tập tin và chèn cú pháp chính xác.
Tuy nhiên, thường thì chạy lệnh `git config` sẽ dễ dàng hơn.
====

==== Cấu hình Cơ bản cho Máy khách

Các tùy chọn cấu hình được Git công nhận chia thành hai loại: phía máy khách và phía máy chủ.
Phần lớn các tùy chọn là phía máy khách -- cấu hình các sở thích làm việc cá nhân của bạn.
Rất, _rất_ nhiều tùy chọn cấu hình được hỗ trợ, nhưng một phần lớn trong số đó chỉ hữu ích trong một số trường hợp hiếm gặp; chúng tôi sẽ chỉ đề cập đến các tùy chọn phổ biến và hữu ích nhất ở đây.
Nếu bạn muốn xem danh sách tất cả các tùy chọn mà phiên bản Git của bạn công nhận, bạn có thể chạy:

[source,console]
----
$ man git-config
----

Lệnh này liệt kê tất cả các tùy chọn có sẵn khá chi tiết.
Bạn cũng có thể tìm thấy tài liệu tham khảo này tại https://git-scm.com/docs/git-config[^].

[NOTE]
====
Đối với các trường hợp sử dụng nâng cao, bạn có thể muốn tra cứu "Conditional includes" (Bao gồm có điều kiện) trong tài liệu được đề cập ở trên.
====

===== `core.editor`

((($EDITOR)))((($VISUAL, xem $EDITOR)))
Theo mặc định, Git sử dụng bất kỳ thứ gì bạn đã đặt làm trình soạn thảo văn bản mặc định của mình thông qua một trong các biến môi trường shell `VISUAL` hoặc `EDITOR`, hoặc nếu không sẽ quay lại trình soạn thảo `vi` để tạo và chỉnh sửa các thông điệp commit và tag của bạn.
Để thay đổi mặc định đó thành một cái gì đó khác, bạn có thể sử dụng thiết lập `core.editor`:

[source,console]
----
$ git config --global core.editor emacs
----

Bây giờ, bất kể trình soạn thảo shell mặc định của bạn là gì, Git sẽ kích hoạt Emacs để chỉnh sửa tin nhắn.

===== `commit.template`

(((commit templates)))
Nếu bạn đặt cái này thành đường dẫn của một tập tin trên hệ thống của bạn, Git sẽ sử dụng tập tin đó làm tin nhắn ban đầu mặc định khi bạn commit.
Giá trị của việc tạo một mẫu commit tùy chỉnh là bạn có thể sử dụng nó để nhắc nhở bản thân (hoặc người khác) về định dạng và phong cách phù hợp khi tạo một thông điệp commit.

Ví dụ, hãy xem xét một tập tin mẫu tại `~/.gitmessage.txt` trông như thế này:

[source,text]
----
Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
----

Lưu ý cách mẫu commit này nhắc nhở người commit giữ cho dòng chủ đề ngắn gọn (để phục vụ cho đầu ra của `git log --oneline`), thêm chi tiết bên dưới, và tham chiếu đến số phiếu theo dõi vấn đề hoặc lỗi nếu có.

Để bảo Git sử dụng nó làm tin nhắn mặc định xuất hiện trong trình soạn thảo của bạn khi bạn chạy `git commit`, hãy đặt giá trị cấu hình `commit.template`:

[source,console]
----
$ git config --global commit.template ~/.gitmessage.txt
$ git commit
----

Sau đó, trình soạn thảo của bạn sẽ mở ra một cái gì đó giống như thế này cho thông điệp commit giữ chỗ của bạn khi bạn commit:

[source,text]
----
Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C
----

Nếu đội ngũ của bạn có chính sách về thông điệp commit, thì việc đặt một mẫu cho chính sách đó trên hệ thống của bạn và cấu hình Git để sử dụng nó theo mặc định có thể giúp tăng cơ hội chính sách đó được tuân thủ thường xuyên.

===== `core.pager`

(((pager)))
Thiết lập này xác định trình phân trang nào được sử dụng khi Git phân trang đầu ra như `log` và `diff`.
Bạn có thể đặt nó thành `more` hoặc trình phân trang yêu thích của bạn (mặc định là `less`), hoặc bạn có thể tắt nó bằng cách đặt nó thành một chuỗi trống:

[source,console]
----
$ git config --global core.pager ''
----

Nếu bạn chạy lệnh đó, Git sẽ in toàn bộ đầu ra của tất cả các lệnh, bất kể chúng dài bao nhiêu.

===== `user.signingkey`

(((GPG)))
Nếu bạn đang tạo các thẻ (tag) có chú thích được ký (như đã thảo luận trong <<ch07-git-tools#_signing>>), việc thiết lập khóa ký GPG của bạn làm thiết lập cấu hình sẽ giúp mọi việc dễ dàng hơn.
Thiết lập ID khóa của bạn như sau:

[source,console]
----
$ git config --global user.signingkey <gpg-key-id>
----

Bây giờ, bạn có thể ký các thẻ mà không cần phải chỉ định khóa của mình mỗi lần với lệnh `git tag`:

[source,console]
----
$ git tag -s <tag-name>
----

===== `core.excludesfile`

(((excludes)))(((.gitignore)))
Bạn có thể đặt các mẫu trong tập tin `.gitignore` của dự án để Git không xem chúng là các tập tin không được theo dõi hoặc cố gắng stage chúng khi bạn chạy `git add` trên chúng, như đã thảo luận trong <<ch02-git-basics-chapter#_ignoring>>.

Nhưng đôi khi bạn muốn bỏ qua một số tập tin nhất định cho tất cả các kho chứa mà bạn làm việc cùng.
Nếu máy tính của bạn đang chạy macOS, có lẽ bạn đã quen thuộc với các tập tin `.DS_Store`.
Nếu trình soạn thảo ưa thích của bạn là Emacs hoặc Vim, bạn biết về các tên tập tin kết thúc bằng `~` hoặc `.swp`.

Thiết lập này cho phép bạn viết một loại tập tin `.gitignore` toàn cục.
Nếu bạn tạo một tập tin `~/.gitignore_global` với nội dung sau:

[source,ini]
----
*~
.*.swp
.DS_Store
----

…và bạn chạy `git config --global core.excludesfile ~/.gitignore_global`, Git sẽ không bao giờ làm phiền bạn về những tập tin đó nữa.

===== `help.autocorrect`

(((autocorrect)))
Nếu bạn gõ sai một lệnh, nó sẽ hiển thị cho bạn một cái gì đó như thế này:

[source,console]
----
$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

The most similar command is
    checkout
----

Git cố gắng tìm ra ý bạn muốn nói một cách hữu ích, nhưng nó vẫn từ chối thực hiện nó.
Nếu bạn đặt `help.autocorrect` thành 1, Git sẽ thực sự chạy lệnh này cho bạn:

[source,console]
----
$ git chekcout master
WARNING: You called a Git command named 'chekcout', which does not exist.
Continuing under the assumption that you meant 'checkout'
in 0.1 seconds automatically...
----

Lưu ý cái vụ "`0.1 seconds`".
`help.autocorrect` thực sự là một số nguyên đại diện cho phần mười của một giây.
Vì vậy, nếu bạn đặt nó thành 50, Git sẽ cho bạn 5 giây để thay đổi ý định trước khi thực thi lệnh đã được tự động sửa.

==== Màu sắc trong Git

(((color)))
Git hỗ trợ đầy đủ đầu ra terminal có màu, điều này hỗ trợ rất nhiều trong việc phân tích cú pháp đầu ra lệnh một cách trực quan nhanh chóng và dễ dàng.
Một số tùy chọn có thể giúp bạn thiết lập màu sắc theo sở thích của mình.

===== `color.ui`

Git tự động tô màu hầu hết đầu ra của nó, nhưng có một công tắc tổng nếu bạn không thích hành vi này.
Để tắt tất cả đầu ra terminal có màu của Git, hãy làm như sau:

[source,console]
----
$ git config --global color.ui false
----

Thiết lập mặc định là `auto`, tô màu đầu ra khi nó đi thẳng đến terminal, nhưng bỏ qua các mã điều khiển màu khi đầu ra được chuyển hướng đến một đường ống (pipe) hoặc một tập tin.

Bạn cũng có thể đặt nó thành `always` để bỏ qua sự khác biệt giữa terminal và đường ống.
Bạn sẽ hiếm khi muốn điều này; trong hầu hết các tình huống, nếu bạn muốn mã màu trong đầu ra được chuyển hướng của mình, thay vào đó bạn có thể truyền cờ `--color` cho lệnh Git để buộc nó sử dụng mã màu.
Thiết lập mặc định hầu như luôn là những gì bạn muốn.

===== `color.*`

Nếu bạn muốn cụ thể hơn về lệnh nào được tô màu và như thế nào, Git cung cấp các thiết lập tô màu cụ thể cho từng động từ.
Mỗi cái này có thể được đặt thành `true`, `false`, hoặc `always`:

  color.branch
  color.diff
  color.interactive
  color.status

Ngoài ra, mỗi cái này có các thiết lập con bạn có thể sử dụng để đặt màu cụ thể cho các phần của đầu ra, nếu bạn muốn ghi đè từng màu.
Ví dụ, để đặt thông tin meta trong đầu ra diff của bạn thành chữ màu xanh lam, nền đen và in đậm, bạn có thể chạy:

[source,console]
----
$ git config --global color.diff.meta "blue black bold"
----

Bạn có thể đặt màu thành bất kỳ giá trị nào sau đây: `normal`, `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, hoặc `white`.
Nếu bạn muốn một thuộc tính như in đậm trong ví dụ trước, bạn có thể chọn từ `bold`, `dim`, `ul` (gạch chân), `blink`, và `reverse` (hoán đổi nền và chữ).

[[_external_merge_tools]]
==== Công cụ Trộn và So sánh Bên ngoài

(((mergetool)))(((difftool)))
Mặc dù Git có một triển khai nội bộ của diff, đó là những gì chúng tôi đã hiển thị trong cuốn sách này, bạn có thể thiết lập một công cụ bên ngoài thay thế.
Bạn cũng có thể thiết lập một công cụ giải quyết xung đột trộn đồ họa thay vì phải giải quyết xung đột thủ công.
Chúng tôi sẽ minh họa việc thiết lập Perforce Visual Merge Tool (P4Merge) để thực hiện diff và giải quyết trộn của bạn, bởi vì nó là một công cụ đồ họa đẹp và miễn phí.

Nếu bạn muốn thử cái này, P4Merge hoạt động trên tất cả các nền tảng chính, vì vậy bạn sẽ có thể làm như vậy.
Chúng tôi sẽ sử dụng tên đường dẫn trong các ví dụ hoạt động trên hệ thống macOS và Linux; đối với Windows, bạn sẽ phải thay đổi `/usr/local/bin` thành một đường dẫn thực thi trong môi trường của bạn.

Để bắt đầu, https://www.perforce.com/products/helix-core-apps/merge-diff-tool-p4merge[tải xuống P4Merge từ Perforce^].
Tiếp theo, bạn sẽ thiết lập các tập tin kịch bản bao bọc (wrapper scripts) bên ngoài để chạy các lệnh của bạn.
Chúng tôi sẽ sử dụng đường dẫn macOS cho tệp thực thi; trong các hệ thống khác, nó sẽ là nơi cài đặt nhị phân `p4merge` của bạn.
Thiết lập một tập tin kịch bản bao bọc trộn có tên `extMerge` gọi nhị phân của bạn với tất cả các đối số được cung cấp:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*
----

Trình bao bọc diff kiểm tra để đảm bảo bảy đối số được cung cấp và chuyển hai trong số đó đến tập tin kịch bản trộn của bạn.
Theo mặc định, Git chuyển các đối số sau cho chương trình diff:

[source]
----
path old-file old-hex old-mode new-file new-hex new-mode
----

Bởi vì bạn chỉ muốn các đối số `old-file` và `new-file`, bạn sử dụng tập tin kịch bản bao bọc để chuyển những cái bạn cần.

[source,console]
----
$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"
----

Bạn cũng cần đảm bảo các công cụ này có thể thực thi được:

[source,console]
----
$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff
----

Bây giờ bạn có thể thiết lập tập tin cấu hình của mình để sử dụng các công cụ giải quyết trộn và diff tùy chỉnh của bạn.
Điều này cần một số thiết lập tùy chỉnh: `merge.tool` để bảo Git chiến lược nào cần sử dụng, `mergetool.<tool>.cmd` để chỉ định cách chạy lệnh, `mergetool.<tool>.trustExitCode` để bảo Git biết mã thoát của chương trình đó có cho biết giải quyết trộn thành công hay không, và `diff.external` để bảo Git lệnh nào cần chạy cho diff.
Vì vậy, bạn có thể chạy bốn lệnh cấu hình:

[source,console]
----
$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff
----

hoặc bạn có thể chỉnh sửa tập tin `~/.gitconfig` của mình để thêm các dòng sau:

[source,ini]
----
[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff
----

Sau khi tất cả những điều này được thiết lập, nếu bạn chạy các lệnh diff như thế này:

[source,console]
----
$ git diff 32d1776b1^ 32d1776b1
----

Thay vì nhận đầu ra diff trên dòng lệnh, Git kích hoạt P4Merge, trông giống như thế này:

.P4Merge
image::images/p4merge.png[P4Merge]

Nếu bạn cố gắng trộn hai nhánh và sau đó gặp xung đột trộn, bạn có thể chạy lệnh `git mergetool`; nó khởi động P4Merge để cho phép bạn giải quyết các xung đột thông qua công cụ GUI đó.

Điều tuyệt vời về thiết lập bao bọc này là bạn có thể thay đổi các công cụ diff và trộn của mình một cách dễ dàng.
Ví dụ, để thay đổi các công cụ `extDiff` và `extMerge` của bạn để chạy công cụ KDiff3 thay thế, tất cả những gì bạn phải làm là chỉnh sửa tập tin `extMerge` của mình:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*
----

Bây giờ, Git sẽ sử dụng công cụ KDiff3 để xem diff và giải quyết xung đột trộn.

Git được cài đặt sẵn để sử dụng một số công cụ giải quyết trộn khác mà bạn không cần phải thiết lập cấu hình cmd.
Để xem danh sách các công cụ mà nó hỗ trợ, hãy thử:

[source,console]
----
$ git mergetool --tool-help
'git mergetool --tool=<tool>' may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.
----

Nếu bạn không quan tâm đến việc sử dụng KDiff3 cho diff mà chỉ muốn sử dụng nó cho giải quyết trộn, và lệnh kdiff3 nằm trong đường dẫn của bạn, thì bạn có thể chạy:

[source,console]
----
$ git config --global merge.tool kdiff3
----

Nếu bạn chạy lệnh này thay vì thiết lập các tập tin `extMerge` và `extDiff`, Git sẽ sử dụng KDiff3 để giải quyết trộn và công cụ diff Git bình thường cho diff.

==== Định dạng và Khoảng trắng

(((whitespace)))
Các vấn đề về định dạng và khoảng trắng là một trong những vấn đề khó chịu và tinh vi hơn mà nhiều nhà phát triển gặp phải khi cộng tác, đặc biệt là đa nền tảng.
Rất dễ để các bản vá hoặc công việc cộng tác khác đưa vào các thay đổi khoảng trắng tinh vi vì các trình soạn thảo âm thầm đưa chúng vào, và nếu các tập tin của bạn từng chạm vào hệ thống Windows, kết thúc dòng của chúng có thể bị thay thế.
Git có một vài tùy chọn cấu hình để giúp giải quyết các vấn đề này.

===== `core.autocrlf`

(((crlf)))(((line endings)))
Nếu bạn đang lập trình trên Windows và làm việc với những người không phải (hoặc ngược lại), bạn có thể sẽ gặp phải các vấn đề về kết thúc dòng tại một thời điểm nào đó.
Điều này là do Windows sử dụng cả ký tự về đầu dòng (carriage-return) và ký tự xuống dòng (linefeed) cho các dòng mới trong các tập tin của nó, trong khi các hệ thống macOS và Linux chỉ sử dụng ký tự xuống dòng.
Đây là một thực tế tinh vi nhưng cực kỳ khó chịu của công việc đa nền tảng; nhiều trình soạn thảo trên Windows âm thầm thay thế các kết thúc dòng kiểu LF hiện có bằng CRLF, hoặc chèn cả hai ký tự kết thúc dòng khi người dùng nhấn phím enter.

Git có thể xử lý việc này bằng cách tự động chuyển đổi kết thúc dòng CRLF thành LF khi bạn thêm một tập tin vào chỉ mục, và ngược lại khi nó check out mã vào hệ thống tập tin của bạn.
Bạn có thể bật chức năng này bằng thiết lập `core.autocrlf`.
Nếu bạn đang ở trên máy Windows, hãy đặt nó thành `true` -- điều này chuyển đổi kết thúc LF thành CRLF khi bạn check out mã:

[source,console]
----
$ git config --global core.autocrlf true
----

Nếu bạn đang ở trên hệ thống Linux hoặc macOS sử dụng kết thúc dòng LF, thì bạn không muốn Git tự động chuyển đổi chúng khi bạn check out tập tin; tuy nhiên, nếu một tập tin có kết thúc CRLF vô tình được đưa vào, thì bạn có thể muốn Git sửa nó.
Bạn có thể bảo Git chuyển đổi CRLF thành LF khi commit nhưng không làm ngược lại bằng cách đặt `core.autocrlf` thành `input`:

[source,console]
----
$ git config --global core.autocrlf input
----

Thiết lập này sẽ để lại cho bạn các kết thúc CRLF trong các lần check out trên Windows, nhưng kết thúc LF trên các hệ thống macOS và Linux và trong kho chứa.

Nếu bạn là một lập trình viên Windows đang thực hiện một dự án chỉ dành cho Windows, thì bạn có thể tắt chức năng này, ghi lại các ký tự về đầu dòng trong kho chứa bằng cách đặt giá trị cấu hình thành `false`:

[source,console]
----
$ git config --global core.autocrlf false
----

===== `core.whitespace`

Git được cài đặt sẵn để phát hiện và sửa một số vấn đề về khoảng trắng.
Nó có thể tìm kiếm sáu vấn đề khoảng trắng chính -- ba được bật theo mặc định và có thể tắt, và ba bị tắt theo mặc định nhưng có thể kích hoạt.

Ba cái được bật theo mặc định là `blank-at-eol`, tìm kiếm khoảng trắng ở cuối dòng; `blank-at-eof`, nhận thấy các dòng trống ở cuối tập tin; và `space-before-tab`, tìm kiếm khoảng trắng trước tab ở đầu dòng.

Ba cái bị tắt theo mặc định nhưng có thể bật là `indent-with-non-tab`, tìm kiếm các dòng bắt đầu bằng khoảng trắng thay vì tab (và được kiểm soát bởi tùy chọn `tabwidth`); `tab-in-indent`, theo dõi các tab trong phần thụt đầu dòng của một dòng; và `cr-at-eol`, bảo Git rằng các ký tự về đầu dòng ở cuối dòng là OK.

Bạn có thể bảo Git cái nào trong số này bạn muốn bật bằng cách đặt `core.whitespace` thành các giá trị bạn muốn bật hoặc tắt, phân tách bằng dấu phẩy.
Bạn có thể tắt một tùy chọn bằng cách thêm dấu `-` vào trước tên của nó, hoặc sử dụng giá trị mặc định bằng cách bỏ nó ra khỏi chuỗi thiết lập hoàn toàn.
Ví dụ, nếu bạn muốn tất cả trừ `space-before-tab` được đặt, bạn có thể làm điều này (với `trailing-space` là cách viết tắt để bao gồm cả `blank-at-eol` và `blank-at-eof`):

[source,console]
----
$ git config --global core.whitespace \
    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

Hoặc bạn có thể chỉ định phần tùy chỉnh:

[source,console]
----
$ git config --global core.whitespace \
    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

Git sẽ phát hiện các vấn đề này khi bạn chạy lệnh `git diff` và cố gắng tô màu chúng để bạn có thể sửa chúng trước khi commit.
Nó cũng sẽ sử dụng các giá trị này để giúp bạn khi bạn áp dụng các bản vá với `git apply`.
Khi bạn đang áp dụng các bản vá, bạn có thể yêu cầu Git cảnh báo bạn nếu nó đang áp dụng các bản vá có các vấn đề về khoảng trắng được chỉ định:

[source,console]
----
$ git apply --whitespace=warn <patch>
----

Hoặc bạn có thể yêu cầu Git cố gắng tự động sửa vấn đề trước khi áp dụng bản vá:

[source,console]
----
$ git apply --whitespace=fix <patch>
----

Các tùy chọn này cũng áp dụng cho lệnh `git rebase`.
Nếu bạn đã commit các vấn đề về khoảng trắng nhưng chưa đẩy lên thượng nguồn (upstream), bạn có thể chạy `git rebase --whitespace=fix` để yêu cầu Git tự động sửa các vấn đề về khoảng trắng khi nó viết lại các bản vá.

==== Cấu hình Máy chủ

Không có nhiều tùy chọn cấu hình có sẵn cho phía máy chủ của Git, nhưng có một vài cái thú vị mà bạn có thể muốn lưu ý.

===== `receive.fsckObjects`

Git có khả năng đảm bảo mọi đối tượng nhận được trong quá trình đẩy vẫn khớp với tổng kiểm tra SHA-1 của nó và trỏ đến các đối tượng hợp lệ.
Tuy nhiên, nó không làm điều này theo mặc định; nó là một hoạt động khá tốn kém, và có thể làm chậm hoạt động, đặc biệt là trên các kho chứa lớn hoặc các lần đẩy lớn.
Nếu bạn muốn Git kiểm tra tính nhất quán của đối tượng trên mỗi lần đẩy, bạn có thể buộc nó làm như vậy bằng cách đặt `receive.fsckObjects` thành true:

[source,console]
----
$ git config --system receive.fsckObjects true
----

Bây giờ, Git sẽ kiểm tra tính toàn vẹn của kho chứa của bạn trước khi mỗi lần đẩy được chấp nhận để đảm bảo các máy khách bị lỗi (hoặc độc hại) không đưa vào dữ liệu bị hỏng.

===== `receive.denyNonFastForwards`

Nếu bạn rebase các commit mà bạn đã đẩy và sau đó cố gắng đẩy lại, hoặc nếu không cố gắng đẩy một commit đến một nhánh từ xa không chứa commit mà nhánh từ xa hiện đang trỏ tới, bạn sẽ bị từ chối.
Đây thường là chính sách tốt; nhưng trong trường hợp rebase, bạn có thể xác định rằng bạn biết mình đang làm gì và có thể cập nhật bắt buộc nhánh từ xa bằng cờ `-f` cho lệnh đẩy của bạn.

Để bảo Git từ chối các lần đẩy bắt buộc (force-pushes), hãy đặt `receive.denyNonFastForwards`:

[source,console]
----
$ git config --system receive.denyNonFastForwards true
----

Cách khác bạn có thể làm điều này là thông qua các móc nhận (receive hooks) phía máy chủ, mà chúng tôi sẽ đề cập trong giây lát.
Cách tiếp cận đó cho phép bạn làm những việc phức tạp hơn như từ chối các tua nhanh (non-fast-forwards) đối với một nhóm người dùng nhất định.

===== `receive.denyDeletes`

Một trong những cách giải quyết chính sách `denyNonFastForwards` là người dùng xóa nhánh và sau đó đẩy nó trở lại với tham chiếu mới.
Để tránh điều này, hãy đặt `receive.denyDeletes` thành true:

[source,console]
----
$ git config --system receive.denyDeletes true
----

Điều này từ chối mọi việc xóa nhánh hoặc thẻ -- không người dùng nào có thể làm điều đó.
Để xóa các nhánh từ xa, bạn phải xóa các tập tin tham chiếu (ref files) khỏi máy chủ một cách thủ công.
Cũng có những cách thú vị hơn để làm điều này trên cơ sở từng người dùng thông qua ACL, như bạn sẽ tìm hiểu trong <<ch08-customizing-git#_an_example_git_enforced_policy>>.
