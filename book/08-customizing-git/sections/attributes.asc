=== Thuộc tính Git

(((attributes)))
Một số thiết lập này cũng có thể được chỉ định cho một đường dẫn, để Git chỉ áp dụng các thiết lập đó cho một thư mục con hoặc một tập hợp các tập tin.
Các thiết lập cụ thể theo đường dẫn này được gọi là các thuộc tính Git và được đặt trong tập tin `.gitattributes` trong một trong các thư mục của bạn (thường là thư mục gốc của dự án) hoặc trong tập tin `.git/info/attributes` nếu bạn không muốn tập tin thuộc tính được commit cùng với dự án của mình.

Sử dụng các thuộc tính, bạn có thể làm những việc như chỉ định các chiến lược trộn riêng biệt cho các tập tin hoặc thư mục riêng lẻ trong dự án của mình, bảo Git cách diff các tập tin không phải văn bản, hoặc yêu cầu Git lọc nội dung trước khi bạn check nó vào hoặc ra khỏi Git.
Trong phần này, bạn sẽ tìm hiểu về một số thuộc tính bạn có thể đặt trên các đường dẫn trong dự án Git của mình và xem một vài ví dụ về việc sử dụng tính năng này trong thực tế.

==== Tập tin Nhị phân

(((binary files)))
Một thủ thuật thú vị mà bạn có thể sử dụng các thuộc tính Git là bảo Git biết tập tin nào là nhị phân (trong trường hợp nó có thể không tự tìm ra được) và đưa ra các hướng dẫn đặc biệt cho Git về cách xử lý các tập tin đó.
Ví dụ, một số tập tin văn bản có thể được tạo bởi máy và không thể diff được, trong khi một số tập tin nhị phân có thể diff được.
Bạn sẽ thấy cách bảo Git cái nào là cái nào.

===== Xác định Tập tin Nhị phân

Một số tập tin trông giống như tập tin văn bản nhưng về mọi mặt và mục đích đều được coi là dữ liệu nhị phân.
Ví dụ, các dự án Xcode trên macOS chứa một tập tin kết thúc bằng `.pbxproj`, về cơ bản là một tập dữ liệu JSON (định dạng dữ liệu JavaScript văn bản thuần túy) được IDE ghi ra đĩa, ghi lại các thiết lập xây dựng của bạn và vân vân.
Mặc dù về mặt kỹ thuật nó là một tập tin văn bản (vì nó hoàn toàn là UTF-8), bạn không muốn coi nó như vậy vì nó thực sự là một cơ sở dữ liệu nhẹ – bạn không thể trộn nội dung nếu hai người thay đổi nó, và các diff thường không hữu ích.
Tập tin này được dùng để máy tiêu thụ.
Về bản chất, bạn muốn coi nó như một tập tin nhị phân.

Để bảo Git coi tất cả các tập tin `pbxproj` là dữ liệu nhị phân, hãy thêm dòng sau vào tập tin `.gitattributes` của bạn:

[source,ini]
----
*.pbxproj binary
----

Bây giờ, Git sẽ không cố gắng chuyển đổi hoặc sửa các vấn đề CRLF; nó cũng sẽ không cố gắng tính toán hoặc in một diff cho các thay đổi trong tập tin này khi bạn chạy `git show` hoặc `git diff` trên dự án của mình.

===== Diff các Tập tin Nhị phân

Bạn cũng có thể sử dụng chức năng thuộc tính Git để diff các tập tin nhị phân một cách hiệu quả.
Bạn làm điều này bằng cách bảo Git cách chuyển đổi dữ liệu nhị phân của bạn sang định dạng văn bản có thể so sánh được thông qua diff thông thường.

Đầu tiên, bạn sẽ sử dụng kỹ thuật này để giải quyết một trong những vấn đề khó chịu nhất được biết đến với nhân loại: kiểm soát phiên bản tài liệu Microsoft Word.
Nếu bạn muốn kiểm soát phiên bản tài liệu Word, bạn có thể ném chúng vào một kho chứa Git và commit thỉnh thoảng; nhưng điều đó có ích gì?
Nếu bạn chạy `git diff` thông thường, bạn chỉ thấy một cái gì đó như thế này:

[source,console]
----
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ
----

Bạn không thể so sánh trực tiếp hai phiên bản trừ khi bạn check out chúng và quét chúng thủ công, phải không?
Hóa ra bạn có thể làm điều này khá tốt bằng cách sử dụng các thuộc tính Git.
Đặt dòng sau vào tập tin `.gitattributes` của bạn:

[source,ini]
----
*.docx diff=word
----

Điều này bảo Git rằng bất kỳ tập tin nào khớp với mẫu này (`.docx`) nên sử dụng bộ lọc "`word`" khi bạn cố gắng xem một diff có chứa các thay đổi.
Bộ lọc "`word`" là gì?
Bạn phải thiết lập nó.
Ở đây bạn sẽ cấu hình Git để sử dụng chương trình `docx2txt` để chuyển đổi tài liệu Word thành các tập tin văn bản có thể đọc được, mà sau đó nó sẽ diff đúng cách.

Đầu tiên, bạn sẽ cần cài đặt `docx2txt`; bạn có thể tải xuống từ https://sourceforge.net/projects/docx2txt[^].
Làm theo hướng dẫn trong tập tin `INSTALL` để đặt nó ở đâu đó mà shell của bạn có thể tìm thấy.
Tiếp theo, bạn sẽ viết một tập tin kịch bản bao bọc để chuyển đổi đầu ra sang định dạng mà Git mong đợi.
Tạo một tập tin ở đâu đó trong đường dẫn của bạn có tên `docx2txt`, và thêm các nội dung này:

[source,console]
----
#!/bin/bash
docx2txt.pl "$1" -
----

Đừng quên `chmod a+x` tập tin đó.
Cuối cùng, bạn có thể cấu hình Git để sử dụng tập tin kịch bản này:

[source,console]
----
$ git config diff.word.textconv docx2txt
----

Bây giờ Git biết rằng nếu nó cố gắng thực hiện một diff giữa hai ảnh chụp nhanh (snapshots), và bất kỳ tập tin nào kết thúc bằng `.docx`, nó nên chạy các tập tin đó qua bộ lọc "`word`", được định nghĩa là chương trình `docx2txt`.
Điều này thực sự tạo ra các phiên bản dựa trên văn bản đẹp của các tập tin Word của bạn trước khi cố gắng diff chúng.

Đây là một ví dụ: Chương 1 của cuốn sách này đã được chuyển đổi sang định dạng Word và được commit trong một kho chứa Git.
Sau đó, một đoạn văn mới đã được thêm vào.
Đây là những gì `git diff` hiển thị:

[source,console]
----
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.
 1.1. About Version Control
 What is "version control", and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.
+Testing: 1, 2, 3.
 If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
 1.1.1. Local Version Control Systems
 Many people's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you're in and accidentally write to the wrong file or copy over files you don't mean to.
----

Git thành công và ngắn gọn cho chúng ta biết rằng chúng ta đã thêm chuỗi "`Testing: 1, 2, 3.`", điều này là chính xác.
Nó không hoàn hảo – các thay đổi định dạng sẽ không hiển thị ở đây – nhưng nó chắc chắn hoạt động.

Một vấn đề thú vị khác mà bạn có thể giải quyết theo cách này liên quan đến việc diff các tập tin hình ảnh.
Một cách để làm điều này là chạy các tập tin hình ảnh qua một bộ lọc trích xuất thông tin EXIF của chúng – siêu dữ liệu được ghi lại với hầu hết các định dạng hình ảnh.
Nếu bạn tải xuống và cài đặt chương trình `exiftool`, bạn có thể sử dụng nó để chuyển đổi hình ảnh của mình thành văn bản về siêu dữ liệu, vì vậy ít nhất diff sẽ hiển thị cho bạn một biểu diễn văn bản của bất kỳ thay đổi nào đã xảy ra.
Đặt dòng sau vào tập tin `.gitattributes` của bạn:

[source,ini]
----
*.png diff=exif
----

Cấu hình Git để sử dụng công cụ này:

[source,console]
----
$ git config diff.exif.textconv exiftool
----

Nếu bạn thay thế một hình ảnh trong dự án của mình và chạy `git diff`, bạn thấy một cái gì đó như thế này:

[source,diff]
----
diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha
----

Bạn có thể dễ dàng thấy rằng kích thước tập tin và kích thước hình ảnh đều đã thay đổi.

[[_keyword_expansion]]
==== Mở rộng Từ khóa

(((keyword expansion)))
Mở rộng từ khóa kiểu SVN- hoặc CVS- thường được yêu cầu bởi các nhà phát triển đã quen với các hệ thống đó.
Vấn đề chính với điều này trong Git là bạn không thể sửa đổi một tập tin với thông tin về commit sau khi bạn đã commit, bởi vì Git kiểm tra tổng (checksums) tập tin trước.
Tuy nhiên, bạn có thể tiêm văn bản vào một tập tin khi nó được check out và xóa nó một lần nữa trước khi nó được thêm vào một commit.
Các thuộc tính Git cung cấp cho bạn hai cách để làm điều này.

Đầu tiên, bạn có thể tiêm tổng kiểm tra SHA-1 của một blob vào một trường `$Id$` trong tập tin một cách tự động.
Nếu bạn đặt thuộc tính này trên một tập tin hoặc tập hợp các tập tin, thì lần tới khi bạn check out nhánh đó, Git sẽ thay thế trường đó bằng SHA-1 của blob.
Điều quan trọng cần lưu ý là nó không phải là SHA-1 của commit, mà là của chính blob đó.
Đặt dòng sau vào tập tin `.gitattributes` của bạn:

[source,ini]
----
*.txt ident
----

Thêm một tham chiếu `$Id$` vào một tập tin thử nghiệm:

[source,console]
----
$ echo '$Id$' > test.txt
----

Lần tới khi bạn check out tập tin này, Git tiêm SHA-1 của blob:

[source,console]
----
$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $
----

Tuy nhiên, kết quả đó có công dụng hạn chế.
Nếu bạn đã sử dụng thay thế từ khóa trong CVS hoặc Subversion, bạn có thể bao gồm một dấu thời gian (datestamp) – SHA-1 không hữu ích lắm, bởi vì nó khá ngẫu nhiên và bạn không thể biết liệu một SHA-1 cũ hơn hay mới hơn cái khác chỉ bằng cách nhìn vào chúng.

Hóa ra bạn có thể viết các bộ lọc của riêng mình để thực hiện thay thế trong các tập tin khi commit/checkout.
Chúng được gọi là các bộ lọc "`clean`" (làm sạch) và "`smudge`" (làm nhòe).
Trong tập tin `.gitattributes`, bạn có thể đặt một bộ lọc cho các đường dẫn cụ thể và sau đó thiết lập các tập tin kịch bản sẽ xử lý các tập tin ngay trước khi chúng được check out ("`smudge`", xem <<filters_a>>) và ngay trước khi chúng được stage ("`clean`", xem <<filters_b>>).
Các bộ lọc này có thể được thiết lập để làm tất cả các loại điều thú vị.

[[filters_a]]
.Bộ lọc "`smudge`" được chạy khi checkout
image::images/smudge.png[Bộ lọc “smudge” được chạy khi checkout]

[[filters_b]]
.Bộ lọc "`clean`" được chạy khi các tập tin được stage
image::images/clean.png[Bộ lọc “clean” được chạy khi các tập tin được stage]

Thông điệp commit ban đầu cho tính năng này đưa ra một ví dụ đơn giản về việc chạy tất cả mã nguồn C của bạn thông qua chương trình `indent` trước khi commit.
Bạn có thể thiết lập nó bằng cách đặt thuộc tính bộ lọc trong tập tin `.gitattributes` của bạn để lọc các tập tin `\*.c` với bộ lọc "`indent`":

[source,ini]
----
*.c filter=indent
----

Sau đó, bảo Git bộ lọc "`indent`" làm gì khi smudge và clean:

[source,console]
----
$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat
----

Trong trường hợp này, khi bạn commit các tập tin khớp với `*.c`, Git sẽ chạy chúng qua chương trình indent trước khi nó stage chúng và sau đó chạy chúng qua chương trình `cat` trước khi nó check chúng trở lại đĩa.
Chương trình `cat` về cơ bản không làm gì cả: nó nhả ra cùng một dữ liệu mà nó nhận vào.
Sự kết hợp này lọc hiệu quả tất cả các tập tin mã nguồn C qua `indent` trước khi commit.

Một ví dụ thú vị khác nhận được mở rộng từ khóa `$Date$`, kiểu RCS.
Để làm điều này đúng cách, bạn cần một tập tin kịch bản nhỏ nhận tên tập tin, tìm ra ngày commit cuối cùng cho dự án này, và chèn ngày vào tập tin.
Đây là một tập tin kịch bản Ruby nhỏ làm điều đó:

[source,ruby]
----
#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')
----

Tất cả những gì tập tin kịch bản làm là lấy ngày commit mới nhất từ lệnh `git log`, dán nó vào bất kỳ chuỗi `$Date$` nào nó thấy trong stdin, và in kết quả – nó sẽ đơn giản để làm trong bất kỳ ngôn ngữ nào bạn thoải mái nhất.
Bạn có thể đặt tên tập tin này là `expand_date` và đặt nó trong đường dẫn của bạn.
Bây giờ, bạn cần thiết lập một bộ lọc trong Git (gọi nó là `dater`) và bảo nó sử dụng bộ lọc `expand_date` của bạn để smudge các tập tin khi checkout.
Bạn sẽ sử dụng một biểu thức Perl để làm sạch (clean) nó khi commit:

[source,console]
----
$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'
----

Đoạn mã Perl này loại bỏ bất cứ thứ gì nó thấy trong một chuỗi `$Date$`, để quay lại nơi bạn bắt đầu.
Bây giờ bộ lọc của bạn đã sẵn sàng, bạn có thể kiểm tra nó bằng cách thiết lập một thuộc tính Git cho tập tin đó tham gia vào bộ lọc mới và tạo một tập tin với từ khóa `$Date$` của bạn:

[source,ini]
----
date*.txt filter=dater
----

[source,console]
----
$ echo '# $Date$' > date_test.txt
----

Nếu bạn commit những thay đổi đó và check out tập tin một lần nữa, bạn thấy từ khóa được thay thế đúng cách:

[source,console]
----
$ git add date_test.txt .gitattributes
$ git commit -m "Test date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$
----

Bạn có thể thấy kỹ thuật này có thể mạnh mẽ như thế nào cho các ứng dụng tùy chỉnh.
Tuy nhiên, bạn phải cẩn thận, bởi vì tập tin `.gitattributes` được commit và truyền đi cùng với dự án, nhưng trình điều khiển (trong trường hợp này, `dater`) thì không, vì vậy nó sẽ không hoạt động ở mọi nơi.
Khi bạn thiết kế các bộ lọc này, chúng nên có thể thất bại một cách duyên dáng (fail gracefully) và để dự án vẫn hoạt động bình thường.

==== Xuất Kho chứa của Bạn

(((archiving)))
Dữ liệu thuộc tính Git cũng cho phép bạn làm một số điều thú vị khi xuất một bản lưu trữ (archive) của dự án của bạn.

===== `export-ignore`

Bạn có thể bảo Git không xuất một số tập tin hoặc thư mục nhất định khi tạo một bản lưu trữ.
Nếu có một thư mục con hoặc tập tin mà bạn không muốn bao gồm trong tập tin lưu trữ của mình nhưng bạn muốn check vào dự án của mình, bạn có thể xác định các tập tin đó thông qua thuộc tính `export-ignore`.

Ví dụ, giả sử bạn có một số tập tin kiểm tra trong thư mục con `test/`, và việc bao gồm chúng trong bản xuất tarball của dự án của bạn là không hợp lý.
Bạn có thể thêm dòng sau vào tập tin thuộc tính Git của mình:

[source,ini]
----
test/ export-ignore
----

Bây giờ, khi bạn chạy `git archive` để tạo một tarball của dự án của bạn, thư mục đó sẽ không được bao gồm trong bản lưu trữ.

===== `export-subst`

Khi xuất các tập tin để triển khai, bạn có thể áp dụng định dạng và xử lý mở rộng từ khóa của ``git log`` cho các phần được chọn của các tập tin được đánh dấu bằng thuộc tính ``export-subst``.

Ví dụ, nếu bạn muốn bao gồm một tập tin có tên `LAST_COMMIT` trong dự án của mình, và có siêu dữ liệu về commit cuối cùng được tự động tiêm vào nó khi `git archive` chạy, bạn có thể ví dụ thiết lập các tập tin `.gitattributes` và `LAST_COMMIT` của mình như thế này:

[source,ini]
----
LAST_COMMIT export-subst
----

[source,console]
----
$ echo 'Last commit date: $Format:%cd by %aN$' > LAST_COMMIT
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'
----

Khi bạn chạy `git archive`, nội dung của tập tin được lưu trữ sẽ trông giống như thế này:

[source,console]
----
$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon
----

Các thay thế có thể bao gồm ví dụ thông điệp commit và bất kỳ `git notes` nào, và `git log` có thể thực hiện ngắt dòng đơn giản:

[source,console]
----
$ echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' > LAST_COMMIT
$ git commit -am 'export-subst uses git log'\''s custom formatter

git archive uses git log'\''s `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
'
$ git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log's custom formatter

         git archive uses git log's `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.
----

Bản lưu trữ kết quả phù hợp cho công việc triển khai, nhưng giống như bất kỳ bản lưu trữ được xuất nào, nó không phù hợp cho công việc phát triển tiếp theo.

==== Chiến lược Trộn

(((merging, strategies)))
Bạn cũng có thể sử dụng các thuộc tính Git để bảo Git sử dụng các chiến lược trộn khác nhau cho các tập tin cụ thể trong dự án của bạn.
Một tùy chọn rất hữu ích là bảo Git không cố gắng trộn các tập tin cụ thể khi chúng có xung đột, mà thay vào đó sử dụng phía của bạn trong việc trộn thay vì của người khác.

Điều này hữu ích nếu một nhánh trong dự án của bạn đã phân kỳ hoặc được chuyên biệt hóa, nhưng bạn muốn có thể trộn các thay đổi trở lại từ nó, và bạn muốn bỏ qua một số tập tin nhất định.
Giả sử bạn có một tập tin thiết lập cơ sở dữ liệu gọi là `database.xml` khác nhau trong hai nhánh, và bạn muốn trộn vào nhánh khác của mình mà không làm hỏng tập tin cơ sở dữ liệu.
Bạn có thể thiết lập một thuộc tính như thế này:

[source,ini]
----
database.xml merge=ours
----

Và sau đó định nghĩa một chiến lược trộn `ours` giả với:

[source,console]
----
$ git config --global merge.ours.driver true
----

Nếu bạn trộn vào nhánh khác, thay vì có xung đột trộn với tập tin `database.xml`, bạn thấy một cái gì đó như thế này:

[source,console]
----
$ git merge topic
Auto-merging database.xml
Merge made by recursive.
----

Trong trường hợp này, `database.xml` giữ nguyên ở bất kỳ phiên bản nào bạn có ban đầu.
