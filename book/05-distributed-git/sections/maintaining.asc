[[_maintaining_project]]
=== Duy trì một Dự án

Ngoài việc biết cách đóng góp hiệu quả vào một dự án, bạn có thể sẽ cần biết cách duy trì một dự án.
Điều này có thể bao gồm việc chấp nhận và áp dụng các bản vá được tạo qua `format-patch` và được gửi qua email cho bạn, hoặc tích hợp các thay đổi trong các nhánh từ xa cho các kho lưu trữ bạn đã thêm làm điều khiển từ xa.
Cho dù bạn duy trì một kho lưu trữ chính tắc hay muốn giúp đỡ bằng cách xác minh hoặc phê duyệt các bản vá, bạn cần biết cách chấp nhận công việc theo cách rõ ràng nhất cho những người đóng góp khác và bền vững cho bạn về lâu dài.

==== Làm việc trong các Nhánh Chủ đề

(((maintaining, topic branches)))
Khi bạn đang nghĩ đến việc tích hợp công việc mới, một ý tưởng hay là thử nó trong một nhánh chủ đề -- một nhánh tạm thời được tạo riêng để thử nghiệm công việc mới đó.
Bằng cách này, thật dễ dàng để tinh chỉnh một bản vá một cách riêng lẻ và để nó lại nếu nó không hoạt động cho đến khi bạn có thời gian để quay lại với nó.
Nếu bạn tạo một tên nhánh đơn giản dựa trên chủ đề của công việc bạn sẽ thử, chẳng hạn như `ruby_client` hoặc một cái gì đó tương tự mô tả, bạn có thể dễ dàng nhớ nó nếu bạn phải từ bỏ nó một thời gian và quay lại sau.
Người bảo trì của dự án Git cũng có xu hướng đặt không gian tên cho các nhánh này -- chẳng hạn như `sc/ruby_client`, trong đó `sc` là viết tắt của người đang đóng góp công việc.
Như bạn sẽ nhớ, bạn có thể tạo nhánh dựa trên nhánh `master` của mình như thế này:

[source,console]
----
$ git branch sc/ruby_client master
----

Hoặc, nếu bạn cũng muốn chuyển sang nó ngay lập tức, bạn có thể sử dụng lệnh `checkout -b`:

[source,console]
----
$ git checkout -b sc/ruby_client master
----

Bây giờ bạn đã sẵn sàng để thêm công việc được đóng góp vào nhánh chủ đề này và xác định xem bạn có muốn hợp nhất nó vào các nhánh dài hạn của mình hay không.

[[_applying_patches_from_email]]
==== Áp dụng các Bản vá từ Email

(((patches, applying from email)))
Nếu bạn nhận được một bản vá qua email mà bạn cần tích hợp vào dự án của mình, bạn cần áp dụng bản vá trong nhánh chủ đề của mình để đánh giá nó.
Có hai cách để áp dụng một bản vá được gửi qua email: với `git apply` hoặc với `git am`.

===== Áp dụng một Bản vá với `apply`

Nếu bạn nhận được bản vá từ một người đã tạo nó bằng lệnh `git diff` hoặc một lệnh `diff` của Unix, bạn có thể áp dụng nó bằng lệnh `git apply`.
Giả sử bạn đã lưu bản vá tại `/tmp/patch-ruby-client.patch`, bạn có thể áp dụng bản vá như thế này:

[source,console]
----
$ git apply /tmp/patch-ruby-client.patch
----

Điều này sửa đổi các tệp trong thư mục làm việc của bạn.
Nó gần như giống hệt với việc chạy lệnh `patch -p1` để áp dụng bản vá, nhưng nó thận trọng hơn và chấp nhận ít kết quả khớp mờ hơn so với patch.
Nó cũng xử lý việc thêm, xóa và đổi tên tệp nếu chúng được mô tả ở định dạng `git diff`, điều mà `patch` sẽ không làm.
Cuối cùng, `git apply` là một mô hình "áp dụng tất cả hoặc hủy bỏ tất cả" trong đó hoặc mọi thứ được áp dụng hoặc không có gì cả, trong khi `patch` có thể áp dụng một phần các tệp vá, để lại thư mục làm việc của bạn ở trạng thái kỳ lạ.
`git apply` nói chung là thận trọng hơn nhiều so với `patch`.
Nó sẽ không tạo ra một cam kết cho bạn -- sau khi chạy nó, bạn phải tự tổ chức và cam kết các thay đổi được giới thiệu.

Bạn cũng có thể sử dụng `git apply` để xem liệu một bản vá có được áp dụng sạch sẽ hay không trước khi bạn thực sự cố gắng áp dụng nó -- bạn có thể chạy `git apply --check` với bản vá:

[source,console]
----
$ git apply --check 0001-see-if-this-helps-the-gem.patch
error: patch failed: lib/simplegit.rb:29
error: lib/simplegit.rb: patch does not apply
----

Nếu không có đầu ra, thì bản vá sẽ được áp dụng sạch sẽ.
Lệnh này cũng thoát với trạng thái khác không nếu kiểm tra không thành công, vì vậy bạn có thể sử dụng nó trong các tập lệnh nếu bạn muốn.

===== Áp dụng một Bản vá với `am`

(((git commands, am)))
Nếu người đóng góp là người dùng Git và đủ tốt để sử dụng lệnh `format-patch` để tạo bản vá của họ, thì công việc của bạn sẽ dễ dàng hơn vì bản vá chứa thông tin tác giả và thông điệp cam kết.
Nếu có thể, hãy khuyến khích những người đóng góp của bạn sử dụng `format-patch` thay vì `diff` để tạo các bản vá cho bạn.
Bạn chỉ nên sử dụng `git apply` cho các bản vá cũ và những thứ tương tự.

Để áp dụng một bản vá được tạo bởi `format-patch`, bạn sử dụng `git am` (lệnh được đặt tên là `am` vì nó được sử dụng để "áp dụng một loạt các bản vá từ một hộp thư").
Về mặt kỹ thuật, `git am` được xây dựng để đọc một tệp mbox, đây là một định dạng văn bản thuần túy, đơn giản để lưu trữ một hoặc nhiều thư email trong một tệp văn bản.
Nó trông giống như thế này:

[source]
----
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] Add limit to log function

Limit log functionality to the first 20
----

Đây là phần đầu của đầu ra của lệnh `format-patch` mà bạn đã thấy trong phần trước; nó cũng tạo thành một định dạng email mbox hợp lệ.
Nếu ai đó đã gửi email cho bạn bản vá đúng cách bằng `git send-email`, và bạn tải xuống nó ở định dạng mbox, thì bạn có thể trỏ `git am` vào tệp mbox đó, và nó sẽ bắt đầu áp dụng tất cả các bản vá mà nó thấy.
Nếu bạn chạy một ứng dụng thư khách có thể lưu nhiều email ra ở định dạng mbox, bạn có thể lưu toàn bộ một loạt các bản vá vào một tệp và sau đó sử dụng `git am` để áp dụng tất cả chúng cùng một lúc.

Tuy nhiên, nếu ai đó đã tải lên một tệp vá được tạo qua `format-patch` lên một hệ thống vé hoặc một cái gì đó, bạn có thể lưu tệp cục bộ và sau đó chuyển tệp đó cho `git am` để áp dụng nó:

[source,console]
----
$ git am 0001-limit-log-function.patch
Applying: Add limit to log function
----

Bạn có thể thấy rằng nó đã được áp dụng sạch sẽ và tự động tạo ra cam kết mới cho bạn.
Thông tin tác giả được lấy từ các tiêu đề `From` và `Date` của email, và thông điệp cho cam kết được lấy từ `Subject` và phần thân (trước bản vá) của email.
Ví dụ, nếu bản vá này được áp dụng từ ví dụ mbox ở trên, cam kết được tạo sẽ trông giống như thế này:

[source,console]
----
$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith <jessica@example.com>
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon <schacon@gmail.com>
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   Add limit to log function

   Limit log functionality to the first 20
----

Thông tin `Commit` cho biết người đã áp dụng bản vá và thời gian nó được áp dụng.
Thông tin `Author` là cá nhân đã tạo ra bản vá ban đầu và khi nó được tạo ra ban đầu.

Nhưng có thể bản vá sẽ không được áp dụng sạch sẽ.
Có lẽ nhánh chính của bạn đã phân kỳ quá xa so với nhánh mà bản vá được xây dựng từ đó, hoặc bản vá phụ thuộc vào một bản vá khác mà bạn chưa áp dụng.
Trong trường hợp đó, quá trình `git am` sẽ thất bại và hỏi bạn muốn làm gì:

[source,console]
----
$ git am 0001-see-if-this-helps-the-gem.patch
Applying: See if this helps the gem
error: patch failed: lib/simplegit.rb:29
error: lib/simplegit.rb: patch does not apply
Patch failed at 0001.
When you have resolved this problem, run "git am --continue".
If you prefer to skip this patch, run "git am --skip".
To restore the original branch and stop patching, run "git am --abort".
----

Lệnh này đặt các dấu xung đột trong bất kỳ tệp nào nó có vấn đề, giống như một thao tác `merge` hoặc `rebase` bị xung đột.
Bạn giải quyết vấn đề này theo cách tương tự -- chỉnh sửa tệp để giải quyết xung đột, tổ chức tệp mới, và sau đó chạy `git am --continue` để tiếp tục với bản vá tiếp theo:

[source,console]
----
$ (fix the file)
$ git add .
$ git am --continue
Applying: See if this helps the gem
----

Nếu bạn muốn Git cố gắng giải quyết xung đột một cách thông minh hơn một chút, bạn có thể chuyển tùy chọn `-3` cho nó, điều này làm cho Git cố gắng hợp nhất ba chiều.
Tùy chọn này không được bật theo mặc định vì nó không hoạt động nếu cam kết mà bản vá nói nó dựa trên không có trong kho lưu trữ của bạn.
Nếu bạn có cam kết đó -- nếu bản vá dựa trên một cam kết công khai -- thì tùy chọn `-3` thường thông minh hơn nhiều về việc áp dụng một bản vá xung đột:

[source,console]
----
$ git am -3 0001-see-if-this-helps-the-gem.patch
Applying: See if this helps the gem
error: patch failed: lib/simplegit.rb:29
error: lib/simplegit.rb: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
----

Trong trường hợp này, chúng tôi đang cố gắng áp dụng một bản vá mà chúng tôi đã áp dụng.
Nếu không có tùy chọn `-3`, nó sẽ trông giống như một xung đột.

Nếu bạn đang áp dụng một số bản vá từ một mbox, bạn cũng có thể chạy lệnh `am` ở chế độ tương tác, nó dừng lại ở mỗi bản vá nó tìm thấy và hỏi bạn có muốn áp dụng nó không:

[source,console]
----
$ git am -3 -i mbox
Commit Body is:
--------------------------
See if this helps the gem
--------------------------
Apply? [y]es/[n]o/[q]uit/[a]ll:
----

Điều này rất hay nếu bạn có một số bản vá, bởi vì bạn có thể xem bản vá trước nếu bạn không nhớ nó là gì, hoặc không áp dụng bản vá nếu bạn đã làm như vậy.

Khi tất cả các bản vá cho chủ đề của bạn được áp dụng và cam kết vào nhánh của bạn, bạn có thể chọn có tích hợp chúng vào một nhánh chạy dài hơn hay không và làm thế nào.

==== Kiểm tra các Nhánh Từ xa

Nếu đóng góp của bạn đến từ một người dùng Git đã thiết lập kho lưu trữ của riêng họ, đã đẩy một số thay đổi vào đó, và sau đó gửi cho bạn URL đến kho lưu trữ và tên của nhánh từ xa chứa các thay đổi, bạn có thể thêm chúng làm một điều khiển từ xa và thực hiện hợp nhất cục bộ.

Ví dụ, nếu Jessica gửi cho bạn một email nói rằng cô ấy có một tính năng mới tuyệt vời trong nhánh `ruby-client` của kho lưu trữ của cô ấy, bạn có thể kiểm tra nó bằng cách thêm kho lưu trữ làm một điều khiển từ xa và kiểm tra nhánh đó cục bộ:

[source,console]
----
$ git remote add jessica https://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
----

Nếu cô ấy gửi email cho bạn một lần nữa sau đó với một nhánh khác chứa một tính năng tuyệt vời khác, bạn có thể tìm nạp và kiểm tra nó vì bạn đã thiết lập điều khiển từ xa.

Điều này hữu ích nhất nếu bạn đang làm việc với một người một cách nhất quán.
Nếu ai đó chỉ có một bản vá duy nhất để đóng góp một lần, thì việc chấp nhận nó qua email có thể ít tốn thời gian hơn so với việc yêu cầu mọi người chạy máy chủ của riêng họ và phải liên tục thêm và xóa các điều khiển từ xa để nhận được một vài bản vá.
Bạn cũng không có khả năng muốn có hàng trăm điều khiển từ xa cho những người chỉ đóng góp một hoặc hai bản vá.
Tuy nhiên, các tập lệnh và các dịch vụ được lưu trữ có thể làm cho điều này dễ dàng hơn -- nó phụ thuộc phần lớn vào cách bạn phát triển và cách những người đóng góp của bạn làm.

Một lợi thế khác của phương pháp này là bạn cũng có được lịch sử của các cam kết.
Mặc dù bạn có thể có các vấn đề hợp pháp với các thông điệp cam kết, bạn nhận được công việc của họ trong lịch sử của bạn; đó là một hợp nhất ba chiều.

Nếu bạn không làm việc với một người một cách nhất quán nhưng vẫn muốn kéo từ họ theo cách này, bạn có thể cung cấp URL của kho lưu trữ từ xa cho lệnh `git pull`.
Điều này thực hiện một lần kéo duy nhất và sẽ không lưu URL làm một tham chiếu từ xa:

[source,console]
----
$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -> FETCH_HEAD
Merge made by the 'recursive' strategy.
...
----

[[_determining_what_is_introduced]]
==== Xác định những gì được giới thiệu

Bây giờ bạn có một nhánh chủ đề chứa công việc được đóng góp.
Tại thời điểm này, bạn có thể xác định những gì bạn muốn làm với nó.
Phần này xem xét lại một vài lệnh để bạn có thể thấy cách bạn có thể sử dụng chúng để xem xét chính xác những gì bạn sẽ giới thiệu nếu bạn hợp nhất điều này vào nhánh chính của mình.

Thường thì một đánh giá tốt là xem tất cả các cam kết trong nhánh này không có trong nhánh `master` của bạn.
Bạn có thể loại trừ các cam kết trong nhánh `master` bằng cách thêm tùy chọn `--not` trước tên nhánh.
Điều này giống như định dạng `master..contrib` chúng ta đã sử dụng trước đó.
Ví dụ, nếu người đóng góp của bạn gửi cho bạn hai bản vá và bạn tạo một nhánh có tên `contrib` và áp dụng các bản vá đó ở đó, bạn có thể chạy lệnh này:

[source,console]
----
$ git log contrib --not master
commit 5b6235bd297351589ff952d52b6de8858ab42d34
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Oct 24 09:53:59 2008 -0700

    See if this helps the gem

commit 7482e0d16d04bea79d0dba898f36c4af2e6b52a5
Author: Scott Chacon <schacon@gmail.com>
Date:   Mon Oct 22 19:38:36 2008 -0700

    Update gemspec to hopefully work better
----

Để xem những thay đổi mà mỗi cam kết giới thiệu, hãy nhớ rằng bạn có thể chuyển tùy chọn `-p` cho `git log` và nó sẽ nối diff của các thay đổi vào mỗi cam kết.

Để xem một diff đầy đủ về những gì sẽ xảy ra nếu bạn hợp nhất nhánh chủ đề này với một nhánh khác, bạn có thể phải sử dụng một mẹo kỳ lạ để có được kết quả chính xác.
Bạn có thể nghĩ đến việc chạy lệnh này:

[source,console]
----
$ git diff master
----

Lệnh này là một diff, nhưng nó có thể gây hiểu lầm.
Nếu nhánh `master` của bạn đã di chuyển về phía trước kể từ khi bạn tạo nhánh chủ đề từ nó, thì bạn sẽ nhận được các kết quả có vẻ kỳ lạ.
Điều này xảy ra bởi vì Git so sánh trực tiếp các ảnh chụp nhanh của cam kết cuối cùng của nhánh chủ đề bạn đang ở và cam kết cuối cùng của nhánh `master`.

Ví dụ, nếu bạn đã thêm một dòng vào một tệp trên nhánh `master`, một diff trực tiếp của nhánh chủ đề sẽ trông giống như bạn sẽ thêm dòng đó, trong khi thực tế bạn đang xóa nó trong nhánh chủ đề.

Nếu `master` là một tổ tiên trực tiếp của nhánh chủ đề của bạn, đây không phải là vấn đề; nhưng nếu hai lịch sử đã phân kỳ, diff sẽ trông giống như bạn đang thêm tất cả những thứ mới trong nhánh chủ đề của bạn và xóa mọi thứ là duy nhất đối với nhánh `master`.

Những gì bạn thực sự muốn thấy là những thay đổi được thêm vào trong nhánh chủ đề -- công việc bạn sẽ giới thiệu nếu bạn hợp nhất nhánh này với `master`.
Bạn có được điều này bằng cách để Git so sánh cam kết cuối cùng trên nhánh chủ đề của bạn với tổ tiên chung đầu tiên của nó với nhánh `master`.

Về mặt kỹ thuật, bạn có thể làm điều đó bằng cách tìm ra tổ tiên chung một cách rõ ràng và sau đó chạy `diff` của bạn trên đó:

[source,console]
----
$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7dba
----

Tuy nhiên, điều đó không thuận tiện, vì vậy Git cung cấp một cách ngắn hơn để làm điều tương tự: cú pháp ba chấm.
Với lệnh `diff`, bạn có thể đặt ba dấu chấm sau một nhánh khác để thực hiện một `diff` giữa cam kết cuối cùng của nhánh bạn đang ở và tổ tiên chung của nó với một nhánh khác:

[source,console]
----
$ git diff master...contrib
----

Lệnh này chỉ cho bạn thấy công việc mà nhánh chủ đề hiện tại của bạn đã giới thiệu kể từ tổ tiên chung của nó với `master`.
Đây là một cú pháp rất hữu ích cần nhớ.

==== Tích hợp Công việc được Đóng góp

Khi tất cả công việc trong nhánh chủ đề của bạn đã sẵn sàng để được tích hợp vào một nhánh chính hơn, câu hỏi là làm thế nào để làm điều đó.
Hơn nữa, bạn muốn sử dụng quy trình làm việc tổng thể nào để duy trì dự án của mình?
Bạn có một số lựa chọn, vì vậy chúng tôi sẽ đề cập đến một vài trong số đó.

===== Quy trình làm việc Hợp nhất

Một quy trình làm việc đơn giản là hợp nhất công việc của bạn vào nhánh `master` của bạn.
Trong kịch bản này, bạn có một nhánh `master` chứa mã ổn định.
Khi bạn có công việc trong một nhánh chủ đề mà bạn đã làm hoặc ai đó đã đóng góp và bạn đã xác minh, bạn hợp nhất nó vào nhánh `master` của mình, xóa nhánh chủ đề, và sau đó tiếp tục.

Nếu chúng ta có một kho lưu trữ với công việc trong hai nhánh có tên `ruby_client` và `php_client` trông giống như <<merging_example>> và chúng ta hợp nhất `ruby_client` trước và sau đó `php_client` thứ hai, thì lịch sử của bạn sẽ kết thúc trông giống như <<merging_example_2>>.

[[merging_example]]
.Một lịch sử với nhiều nhánh chủ đề
image::images/large-merges-1.png[Một lịch sử với nhiều nhánh chủ đề]

[[merging_example_2]]
.Sau khi hợp nhất nhánh chủ đề
image::images/large-merges-2.png[Sau khi hợp nhất nhánh chủ đề]

Đó có lẽ là quy trình làm việc đơn giản nhất, nhưng nó có thể có vấn đề nếu bạn đang xử lý các dự án lớn hơn hoặc ổn định hơn nơi bạn muốn cẩn thận hơn về những gì bạn giới thiệu.

Nếu bạn có một dự án quan trọng hơn, bạn có thể muốn sử dụng một chu trình hợp nhất hai pha.
Trong kịch bản này, bạn có hai nhánh chạy dài, `master` và `develop`, trong đó bạn xác định rằng `master` chỉ được cập nhật khi một bản phát hành rất ổn định được cắt và tất cả mã mới được tích hợp vào nhánh `develop`.
Bạn thường xuyên đẩy cả hai nhánh này lên kho lưu trữ công khai.
Mỗi khi bạn có một nhánh chủ đề mới để hợp nhất vào (<<merging_cycle_1>>), bạn hợp nhất nó vào `develop` (<<merging_cycle_2>>); sau đó, khi bạn gắn thẻ một bản phát hành, bạn tua nhanh `master` đến bất cứ đâu mà nhánh `develop` hiện đã ổn định (<<merging_cycle_3>>).

[[merging_cycle_1]]
.Trước khi hợp nhất nhánh chủ đề
image::images/merging-cycle-1.png[Trước khi hợp nhất nhánh chủ đề]

[[merging_cycle_2]]
.Sau khi hợp nhất nhánh chủ đề
image::images/merging-cycle-2.png[Sau khi hợp nhất nhánh chủ đề]

[[merging_cycle_3]]
.Sau khi phát hành dự án
image::images/merging-cycle-3.png[Sau khi phát hành dự án]

Bằng cách này, khi mọi người sao chép kho lưu trữ của dự án của bạn, họ có thể kiểm tra `master` để xây dựng phiên bản ổn định mới nhất và dễ dàng cập nhật trên đó, hoặc họ có thể kiểm tra `develop`, đó là nội dung tiên tiến hơn.
Bạn cũng có thể mở rộng khái niệm này bằng cách có một nhánh `integrate` nơi tất cả công việc được hợp nhất lại với nhau.
Sau đó, khi cơ sở mã trên nhánh đó ổn định và vượt qua các bài kiểm tra, bạn hợp nhất nó vào một nhánh `develop`; và khi điều đó đã chứng tỏ mình ổn định một thời gian, bạn tua nhanh nhánh `master` của mình.

===== Quy trình làm việc Hợp nhất Lớn

Dự án Git có bốn nhánh chạy dài: `master`, `next`, và `seen` (trước đây là `pu` cho các bản cập nhật được đề xuất) cho công việc mới, và `maint` cho các bản vá bảo trì.
Khi công việc mới được giới thiệu bởi những người đóng góp, nó được thu thập vào các nhánh chủ đề trong kho lưu trữ của người bảo trì theo cách tương tự như những gì chúng ta đã mô tả (xem <<large_merging_1>>).
Tại thời điểm này, các chủ đề được đánh giá để xác định xem chúng có an toàn và sẵn sàng để sử dụng hay không hoặc liệu chúng có cần thêm công việc hay không.
Nếu chúng an toàn, chúng được hợp nhất vào `next`, và nhánh đó được đẩy lên để mọi người có thể thử các chủ đề được tích hợp lại với nhau.

[[large_merging_1]]
.Quản lý một loạt các nhánh chủ đề được đóng góp song song phức tạp
image::images/large-merging-1.png[Quản lý một loạt các nhánh chủ đề được đóng góp song song phức tạp]

Nếu các chủ đề vẫn cần công việc, chúng được hợp nhất vào `seen` thay thế.
Khi được xác định rằng chúng hoàn toàn ổn định, các chủ đề được hợp nhất lại vào `master`.
Các nhánh `next` và `seen` sau đó được xây dựng lại từ nhánh `master`. Điều này thường có nghĩa là `next` được xây dựng lại bằng một rebase, và `seen` bằng một hợp nhất (xem <<large_merging_2>>).

[[large_merging_2]]
.Hợp nhất các nhánh chủ đề vào các nhánh tích hợp dài hạn
image::images/large-merging-2.png[Hợp nhất các nhánh chủ đề vào các nhánh tích hợp dài hạn]

Khi một nhánh chủ đề cuối cùng đã được hợp nhất vào `master`, nó sẽ bị xóa khỏi kho lưu trữ.

===== Quy trình làm việc Rebase và Cherry-Pick

(((workflows, rebasing and cherry-picking)))
Các người bảo trì khác thích rebase hoặc cherry-pick công việc được đóng góp trên đỉnh của nhánh `master` của họ, thay vì hợp nhất nó vào, để giữ một lịch sử gần như tuyến tính.
Khi bạn có công việc trong một nhánh chủ đề và đã xác định rằng bạn muốn tích hợp nó, bạn di chuyển đến nhánh đó và chạy lệnh `rebase` để xây dựng lại các thay đổi trên đỉnh của nhánh `master` (hoặc `develop`, v.v.) hiện tại của bạn.
Nếu điều đó hoạt động tốt, thì bạn có thể tua nhanh nhánh `master` của mình, và bạn sẽ có một lịch sử dự án tuyến tính.

Cách khác để di chuyển công việc được giới thiệu từ nhánh này sang nhánh khác là cherry-pick nó.
Một cherry-pick trong Git giống như một rebase cho một cam kết duy nhất.
Nó lấy bản vá được giới thiệu trong một cam kết và cố gắng áp dụng lại nó trên nhánh bạn đang ở hiện tại.
Điều này hữu ích nếu bạn có một số cam kết trong một nhánh chủ đề và bạn chỉ muốn tích hợp một trong số chúng, hoặc nếu bạn chỉ có một cam kết trong một nhánh chủ đề và bạn thích cherry-pick nó hơn là chạy rebase.
Ví dụ, giả sử bạn có một dự án trông như thế này:

.Lịch sử ví dụ trước khi cherry-pick
image::images/rebase-cycle-1.png[Lịch sử ví dụ trước khi cherry-pick]

Nếu bạn muốn kéo cam kết `e43a6` vào nhánh `master` của mình, bạn có thể chạy:

[source,console]
----
$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message"
 3 files changed, 17 insertions(+), 3 deletions(-)
----

Điều này kéo cùng một thay đổi được giới thiệu trong `e43a6`, nhưng bạn nhận được một giá trị SHA-1 cam kết mới, bởi vì bạn đang áp dụng thay đổi tại một điểm khác trong lịch sử.
Bây giờ lịch sử của bạn trông như thế này:

.Lịch sử sau khi cherry-pick một cam kết từ một nhánh chủ đề
image::images/rebase-cycle-2.png[Lịch sử sau khi cherry-pick một cam kết từ một nhánh chủ đề]

Bây giờ bạn có thể xóa nhánh chủ đề của mình và bỏ các cam kết bạn không muốn kéo vào.

==== Rerere

(((rerere)))
Nếu bạn đang thực hiện nhiều việc hợp nhất và rebase, hoặc nếu bạn duy trì một nhánh chủ đề chạy dài, Git có một tính năng gọi là "rerere" có thể giúp ích.

Rerere là viết tắt của "reuse recorded resolution" -- đó là một cách để giải quyết xung đột thủ công một cách ngắn gọn.
Khi rerere được bật, Git sẽ giữ một tập hợp các hình ảnh trước và sau từ các lần hợp nhất thành công, và nếu nó thấy một xung đột trông giống hệt như một xung đột bạn đã sửa, nó sẽ chỉ sử dụng bản sửa lỗi từ lần trước, mà không làm phiền bạn với nó.

Tính năng này có hai phần: một cài đặt cấu hình và một lệnh.
Cài đặt cấu hình là `rerere.enabled`, bạn có thể đặt trong cấu hình toàn cục của mình để bắt đầu sử dụng nó:

[source,console]
----
$ git config --global rerere.enabled true
----

Bây giờ, bất cứ khi nào bạn thực hiện một hợp nhất giải quyết các xung đột, giải pháp sẽ được ghi lại trong bộ đệm trong trường hợp bạn cần nó trong tương lai.

Nếu bạn cần tương tác với bộ đệm rerere, bạn có thể sử dụng lệnh `git rerere`.
Khi được gọi một mình, nó sẽ kiểm tra trạng thái giải quyết hợp nhất hiện tại và nếu cần giải quyết xung đột nhưng không có trong bộ đệm, nó sẽ không làm gì cả.
Nếu một giải pháp có trong bộ đệm, nó sẽ giải quyết bất kỳ xung đột nào theo cách tương tự như đã làm trước đó.
Cũng có một số lệnh con để xem những gì sẽ được ghi lại, để xóa trạng thái cụ thể khỏi bộ đệm, và để xóa toàn bộ bộ đệm.
Chúng tôi sẽ đề cập đến rerere chi tiết hơn trong <<ch10-git-internals#ch10-rerere>>.

==== Gắn thẻ các Bản phát hành của bạn

Khi bạn sẵn sàng thực hiện một bản phát hành, bạn có thể sẽ muốn tạo một thẻ để bạn có thể tạo lại bản phát hành đó bất cứ lúc nào trong tương lai.
Bạn có thể tạo một thẻ mới như đã thảo luận trong <<ch02-git-basics#_git_tagging>>.
Nếu bạn quyết định ký thẻ với tư cách là người bảo trì, việc gắn thẻ có thể trông giống như thế này:

[source,console]
----
$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon <schacon@gmail.com>"
1024-bit DSA key, ID F721C45A, created 2009-02-09
----

Nếu bạn ký các thẻ của mình, bạn có vấn đề về việc phân phối khóa PGP công khai được sử dụng để ký chúng.
Người bảo trì của dự án Git đã giải quyết vấn đề này bằng cách bao gồm khóa công khai của họ dưới dạng một blob trong kho lưu trữ và sau đó thêm một thẻ trỏ trực tiếp đến nội dung đó.
Để làm điều này, bạn có thể tìm ra khóa nào bạn muốn bằng cách chạy `gpg --list-keys`:

[source,console]
----
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon <schacon@gmail.com>
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
----

Sau đó, bạn có thể nhập trực tiếp khóa vào cơ sở dữ liệu Git bằng cách xuất nó và chuyển nó qua `git hash-object`, nó sẽ viết một blob mới với nội dung đó vào Git và trả về cho bạn SHA-1 của blob:

[source,console]
----
$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
----

Bây giờ bạn đã có nội dung của khóa của mình trong Git, bạn có thể tạo một thẻ trỏ trực tiếp đến nó bằng cách chỉ định giá trị SHA-1 mới mà lệnh `hash-object` đã cho bạn:

[source,console]
----
$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
----

Nếu bạn chạy `git push --tags`, thẻ `maintainer-pgp-pub` sẽ được chia sẻ với mọi người.
Nếu họ muốn xác minh một thẻ, họ có thể nhập khóa PGP của bạn bằng cách kéo blob trực tiếp ra khỏi cơ sở dữ liệu và nhập nó vào GPG:

[source,console]
----
$ git show maintainer-pgp-pub | gpg --import
----

Sau đó, họ có thể sử dụng khóa đó để xác minh tất cả các thẻ đã ký của bạn.
Ngoài ra, nếu bạn bao gồm các hướng dẫn trong thông điệp thẻ, việc chạy `git show <tag>` sẽ cho phép bạn cung cấp cho người dùng cuối các hướng dẫn cụ thể hơn về việc xác minh thẻ.

==== Tạo một Số bản dựng

Git không có một số tăng dần đơn điệu như "v123" hoặc tương đương với mỗi cam kết -- và vì lý do chính đáng.
Nếu bạn có một kho lưu trữ trung tâm duy nhất mà mọi người đều đẩy đến, sẽ dễ dàng có một số tăng dần cho mỗi cam kết.
Tuy nhiên, trong một hệ thống phân tán, bạn có thể có hai nhà phát triển thực hiện các cam kết cùng một lúc, và sẽ không có cách nào để biết số nào sẽ đến trước.
Trong Subversion, nếu bạn cam kết, bạn nhận được số 123; nếu tôi cam kết, tôi nhận được số 124.
Trong Git, cả hai chúng ta sẽ thực hiện một cam kết trên máy của riêng mình, mà không biết người kia đang làm gì.

Điều này có nghĩa là nếu bạn muốn có một số có thể đọc được bởi con người để sử dụng cho các cam kết của mình, bạn phải làm điều đó sau đó, khi bạn chia sẻ chúng với những người khác.
Bạn có thể làm điều đó ở phía máy chủ: có một tập lệnh chạy mỗi khi ai đó đẩy, nó sẽ tăng một số và liên kết nó với cam kết.
Hoặc, bạn có thể sử dụng một lệnh có thể giúp bạn với điều này.

Lệnh `git describe` sẽ lấy bất kỳ cam kết nào có thể truy cập được và cung cấp cho bạn một chuỗi có phần nào đó có thể đọc được bởi con người và sẽ không thay đổi.
Bằng cách này, bạn có thể nhận được một tên cho một ảnh chụp nhanh dễ hiểu hơn so với SHA-1 cam kết.

[source,console]
----
$ git describe master
v2.2.0-8-g5082d49
----

Git lấy tên của một ảnh chụp nhanh ở định dạng `<tag>-<num>-g<short_sha>`.
Đây là những gì nó trông như thế nào nếu bạn đã gắn thẻ cam kết bạn đang mô tả.
Nếu bạn chưa, nó sẽ tìm thẻ gần nhất và sử dụng thẻ đó thay thế.

Lệnh `git describe` phụ thuộc rất nhiều vào việc có các thẻ, vì vậy nếu bạn muốn sử dụng nó, bạn nên đảm bảo rằng bạn gắn thẻ các bản phát hành của mình một cách thích hợp.
Bạn cũng có thể sử dụng chuỗi này làm mục tiêu của lệnh `checkout` hoặc `show`, mặc dù nó dựa vào SHA-1 viết tắt ở cuối, vì vậy nó có thể không hợp lệ mãi mãi.
Ví dụ, nhân Linux gần đây đã tăng từ 8 lên 10 ký tự để đảm bảo tính duy nhất của các đối tượng SHA-1, vì vậy đầu ra `git describe` cũ hơn đã bị vô hiệu hóa.

==== Chuẩn bị một Bản phát hành

Bây giờ bạn muốn chuẩn bị một bản phát hành.
Bạn có một loạt công việc đã được đóng góp, và bạn muốn đóng gói tất cả lại để người khác sử dụng.

Vấn đề đầu tiên bạn sẽ gặp phải là Git không có hỗ trợ cho `svn export` hoặc `cvs export`.
Đây là một tính năng mà nhiều người muốn, nhưng Git muốn trở thành một hệ thống kiểm soát phiên bản, không phải là một công cụ tạo tarball.

Để có được một ảnh chụp nhanh của dự án của bạn mà không có thư mục `.git`, bạn có thể sử dụng `git archive`:

[source,console]
----
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
----

Nếu ai đó giải nén tệp đó, họ sẽ nhận được ảnh chụp nhanh mới nhất của dự án của bạn trong một thư mục `project`.
Bạn cũng có thể làm điều này với định dạng `tar`:

[source,console]
----
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
----

Bạn có thể làm điều này cho bất kỳ cam kết nào, không chỉ là cam kết mới nhất.

==== The Shortlog

Bây giờ là lúc để gửi email cho danh sách gửi thư của bạn để cho họ biết rằng bản phát hành mới nhất của bạn đã sẵn sàng.
Lệnh `git shortlog` có thể giúp bạn nhanh chóng tạo một bản ghi thay đổi về những gì đã được thêm vào dự án của bạn kể từ bản phát hành cuối cùng của bạn.
Nó tóm tắt tất cả các cam kết trong phạm vi bạn cung cấp; ví dụ, điều này sẽ cung cấp cho bạn một bản tóm tắt của tất cả các cam kết kể từ bản phát hành cuối cùng của bạn, nếu bản phát hành cuối cùng của bạn được đặt tên là v1.0.1:

[source,console]
----
$ git shortlog --no-merges master --not v1.0.1
Chris Lopez (1):
      Fix a bug in the build system

Joel Wurtz (1):
      Add 'gc --aggressive' to the manuals

Junio C Hamano (1):
      Merge branch 'sd/gc-autodetect'

----

Bạn nhận được một bản tóm tắt sạch sẽ của tất cả các cam kết kể từ v1.0.1, được nhóm theo tác giả, mà bạn có thể gửi email cho danh sách của mình.