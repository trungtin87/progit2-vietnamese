[[_contributing_project]]
=== Đóng góp vào một Dự án

(((contributing)))
Khó khăn chính khi mô tả cách đóng góp vào một dự án là có vô số biến thể về cách thực hiện điều đó.
Bởi vì Git rất linh hoạt, mọi người có thể và thực sự làm việc cùng nhau theo nhiều cách, và thật khó để mô tả cách bạn nên đóng góp -- mỗi dự án đều có một chút khác biệt.
Một số biến số liên quan là số lượng người đóng góp tích cực, quy trình làm việc được chọn, quyền truy cập cam kết của bạn và có thể là phương pháp đóng góp bên ngoài.

Biến số đầu tiên là số lượng người đóng góp tích cực -- có bao nhiêu người dùng đang tích cực đóng góp mã cho dự án này, và tần suất như thế nào?
Trong nhiều trường hợp, bạn sẽ có hai hoặc ba nhà phát triển với một vài cam kết mỗi ngày, hoặc có thể ít hơn đối với các dự án hơi im lìm.
Đối với các công ty hoặc dự án lớn hơn, số lượng nhà phát triển có thể lên tới hàng nghìn, với hàng trăm hoặc hàng nghìn cam kết đến mỗi ngày.
Điều này quan trọng bởi vì với ngày càng nhiều nhà phát triển, bạn gặp phải nhiều vấn đề hơn trong việc đảm bảo mã của bạn áp dụng sạch sẽ hoặc có thể dễ dàng hợp nhất.
Các thay đổi bạn gửi có thể trở nên lỗi thời hoặc bị hỏng nghiêm trọng bởi công việc được hợp nhất trong khi bạn đang làm việc hoặc trong khi các thay đổi của bạn đang chờ được phê duyệt hoặc áp dụng.
Làm thế nào bạn có thể giữ cho mã của mình luôn cập nhật và các cam kết của bạn hợp lệ?

Biến số tiếp theo là quy trình làm việc được sử dụng cho dự án.
Nó có phải là tập trung, với mỗi nhà phát triển có quyền ghi ngang nhau vào dòng mã chính không?
Dự án có người bảo trì hoặc người quản lý tích hợp kiểm tra tất cả các bản vá không?
Tất cả các bản vá có được bình duyệt và phê duyệt không?
Bạn có tham gia vào quá trình đó không?
Có hệ thống cấp phó (lieutenant) nào được áp dụng không, và bạn có phải gửi công việc của mình cho họ trước không?

Biến số tiếp theo là quyền truy cập cam kết của bạn.
Quy trình làm việc cần thiết để đóng góp vào một dự án khác nhau nhiều nếu bạn có quyền ghi vào dự án so với nếu bạn không có.
Nếu bạn không có quyền ghi, dự án thích chấp nhận công việc đóng góp như thế nào?
Nó thậm chí có chính sách không?
Bạn đang đóng góp bao nhiêu công việc cùng một lúc?
Bạn đóng góp thường xuyên như thế nào?

Tất cả những câu hỏi này có thể ảnh hưởng đến cách bạn đóng góp hiệu quả cho một dự án và quy trình làm việc nào được ưu tiên hoặc có sẵn cho bạn.
Chúng tôi sẽ đề cập đến các khía cạnh của từng vấn đề này trong một loạt các trường hợp sử dụng, chuyển từ đơn giản đến phức tạp hơn; bạn sẽ có thể xây dựng các quy trình làm việc cụ thể mà bạn cần trong thực tế từ các ví dụ này.

[[_commit_guidelines]]
==== Hướng dẫn Cam kết (Commit Guidelines)

Trước khi chúng ta bắt đầu xem xét các trường hợp sử dụng cụ thể, đây là một lưu ý nhanh về thông báo cam kết.
Có một hướng dẫn tốt để tạo các cam kết và tuân thủ nó làm cho việc làm việc với Git và cộng tác với những người khác dễ dàng hơn nhiều.
Dự án Git cung cấp một tài liệu đưa ra một số mẹo hay để tạo các cam kết để gửi các bản vá -- bạn có thể đọc nó trong mã nguồn Git trong tệp `Documentation/SubmittingPatches`.

(((git commands, diff, check)))
Đầu tiên, các bài nộp của bạn không được chứa bất kỳ lỗi khoảng trắng nào.
Git cung cấp một cách dễ dàng để kiểm tra điều này -- trước khi bạn cam kết, hãy chạy `git diff --check`, lệnh này xác định các lỗi khoảng trắng có thể có và liệt kê chúng cho bạn.

.Đầu ra của `git diff --check`
image::images/git-diff-check.png[Đầu ra của `git diff --check`]

Nếu bạn chạy lệnh đó trước khi cam kết, bạn có thể biết liệu bạn có sắp cam kết các vấn đề về khoảng trắng có thể gây khó chịu cho các nhà phát triển khác hay không.

Tiếp theo, hãy cố gắng làm cho mỗi cam kết trở thành một bộ thay đổi (changeset) tách biệt về mặt logic.
Nếu có thể, hãy cố gắng làm cho các thay đổi của bạn dễ hiểu -- đừng viết mã cho cả cuối tuần về năm vấn đề khác nhau và sau đó gửi tất cả chúng dưới dạng một cam kết lớn vào thứ Hai.
Ngay cả khi bạn không cam kết trong cuối tuần, hãy sử dụng khu vực tổ chức (staging area) vào thứ Hai để chia công việc của bạn thành ít nhất một cam kết cho mỗi vấn đề, với một thông báo hữu ích cho mỗi cam kết.
Nếu một số thay đổi sửa đổi cùng một tệp, hãy thử sử dụng `git add --patch` để tổ chức một phần các tệp (được đề cập chi tiết trong <<ch07-git-tools#_interactive_staging>>).
Ảnh chụp nhanh dự án ở đầu nhánh là giống hệt nhau cho dù bạn thực hiện một cam kết hay năm cam kết, miễn là tất cả các thay đổi được thêm vào tại một thời điểm nào đó, vì vậy hãy cố gắng làm cho mọi thứ dễ dàng hơn cho các nhà phát triển đồng nghiệp của bạn khi họ phải xem xét các thay đổi của bạn.

Cách tiếp cận này cũng giúp dễ dàng hơn trong việc lấy ra hoặc hoàn tác một trong các bộ thay đổi nếu bạn cần sau này.
<<ch07-git-tools#_rewriting_history>> mô tả một số thủ thuật Git hữu ích để viết lại lịch sử và tổ chức tệp tương tác -- hãy sử dụng các công cụ này để giúp tạo ra một lịch sử sạch sẽ và dễ hiểu trước khi gửi công việc cho người khác.

Điều cuối cùng cần ghi nhớ là thông báo cam kết.
Tạo thói quen tạo các thông báo cam kết chất lượng giúp việc sử dụng và cộng tác với Git dễ dàng hơn nhiều.
Theo quy tắc chung, các thông báo của bạn nên bắt đầu bằng một dòng đơn không quá khoảng 50 ký tự và mô tả bộ thay đổi một cách ngắn gọn, tiếp theo là một dòng trống, tiếp theo là một lời giải thích chi tiết hơn.
Dự án Git yêu cầu lời giải thích chi tiết hơn bao gồm động lực của bạn cho sự thay đổi và đối chiếu việc thực hiện nó với hành vi trước đó -- đây là một hướng dẫn tốt để làm theo.
Viết thông báo cam kết của bạn ở thể mệnh lệnh: "Fix bug" (Sửa lỗi) và không phải "Fixed bug" (Đã sửa lỗi) hoặc "Fixes bug" (Sửa lỗi).
Dưới đây là một mẫu bạn có thể làm theo, chúng tôi đã điều chỉnh nhẹ từ một mẫu https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[được viết ban đầu bởi Tim Pope^]:

[source,text]
----
Capitalized, short (50 chars or less) summary

More detailed explanatory text, if necessary.  Wrap it to about 72
characters or so.  In some contexts, the first line is treated as the
subject of an email and the rest of the text as the body.  The blank
line separating the summary from the body is critical (unless you omit
the body entirely); tools like rebase will confuse you if you run the
two together.

Write your commit message in the imperative: "Fix bug" and not "Fixed bug"
or "Fixes bug."  This convention matches up with commit messages generated
by commands like git merge and git revert.

Further paragraphs come after blank lines.

- Bullet points are okay, too

- Typically a hyphen or asterisk is used for the bullet, followed by a
  single space, with blank lines in between, but conventions vary here

- Use a hanging indent
----

Nếu tất cả các thông báo cam kết của bạn tuân theo mô hình này, mọi thứ sẽ dễ dàng hơn nhiều cho bạn và các nhà phát triển mà bạn cộng tác.
Dự án Git có các thông báo cam kết được định dạng tốt -- hãy thử chạy `git log --no-merges` ở đó để xem lịch sử cam kết dự án được định dạng đẹp mắt trông như thế nào.

[NOTE]
.Làm như chúng tôi nói, không phải như chúng tôi làm.
====
Vì mục đích ngắn gọn, nhiều ví dụ trong cuốn sách này không có thông báo cam kết được định dạng đẹp mắt như thế này; thay vào đó, chúng tôi chỉ đơn giản sử dụng tùy chọn `-m` cho `git commit`.

Tóm lại, hãy làm như chúng tôi nói, không phải như chúng tôi làm.
====

[[_private_team]]
==== Nhóm Nhỏ Riêng tư (Private Small Team)

(((contributing, private small team)))
Thiết lập đơn giản nhất mà bạn có thể gặp phải là một dự án riêng tư với một hoặc hai nhà phát triển khác.
"`Riêng tư,`" trong bối cảnh này, có nghĩa là nguồn đóng -- không thể truy cập được đối với thế giới bên ngoài.
Bạn và các nhà phát triển khác đều có quyền đẩy (push) vào kho lưu trữ.

Trong môi trường này, bạn có thể tuân theo quy trình làm việc tương tự như những gì bạn có thể làm khi sử dụng Subversion hoặc một hệ thống tập trung khác.
Bạn vẫn nhận được những lợi thế của những thứ như cam kết ngoại tuyến và phân nhánh và hợp nhất đơn giản hơn nhiều, nhưng quy trình làm việc có thể rất giống nhau; sự khác biệt chính là việc hợp nhất diễn ra ở phía máy khách thay vì trên máy chủ tại thời điểm cam kết.
Hãy xem nó có thể trông như thế nào khi hai nhà phát triển bắt đầu làm việc cùng nhau với một kho lưu trữ được chia sẻ.
Nhà phát triển đầu tiên, John, sao chép kho lưu trữ, thực hiện thay đổi và cam kết cục bộ.
Các thông báo giao thức đã được thay thế bằng `...` trong các ví dụ này để rút ngắn chúng đôi chút.

[source,console]
----
# John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'Remove invalid default value'
[master 738ee87] Remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Nhà phát triển thứ hai, Jessica, làm điều tương tự -- sao chép kho lưu trữ và cam kết một thay đổi:

[source,console]
----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'Add reset task'
[master fbff5bc] Add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Bây giờ, Jessica đẩy công việc của cô ấy lên máy chủ, điều này hoạt động tốt:

[source,console]
----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
----

Dòng cuối cùng của đầu ra ở trên hiển thị một thông báo trả về hữu ích từ thao tác đẩy.
Định dạng cơ bản là `<oldref>..<newref> fromref -> toref`, trong đó `oldref` có nghĩa là tham chiếu cũ, `newref` có nghĩa là tham chiếu mới, `fromref` là tên của tham chiếu cục bộ đang được đẩy, và `toref` là tên của tham chiếu từ xa đang được cập nhật.
Bạn sẽ thấy đầu ra tương tự như thế này bên dưới trong các cuộc thảo luận, vì vậy có một ý tưởng cơ bản về ý nghĩa sẽ giúp hiểu các trạng thái khác nhau của các kho lưu trữ.
Thông tin chi tiết có sẵn trong tài liệu cho https://git-scm.com/docs/git-push[git-push^].

Tiếp tục với ví dụ này, ngay sau đó, John thực hiện một số thay đổi, cam kết chúng vào kho lưu trữ cục bộ của mình và cố gắng đẩy chúng lên cùng một máy chủ:

[source,console]
----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
----

Trong trường hợp này, việc đẩy của John thất bại vì việc đẩy các thay đổi _của cô ấy_ trước đó của Jessica.
Điều này đặc biệt quan trọng cần hiểu nếu bạn đã quen với Subversion, bởi vì bạn sẽ nhận thấy rằng hai nhà phát triển không chỉnh sửa cùng một tệp.
Mặc dù Subversion tự động thực hiện hợp nhất như vậy trên máy chủ nếu các tệp khác nhau được chỉnh sửa, với Git, bạn phải _trước tiên_ hợp nhất các cam kết cục bộ.
Nói cách khác, John trước tiên phải tìm nạp (fetch) các thay đổi ngược dòng của Jessica và hợp nhất chúng vào kho lưu trữ cục bộ của mình trước khi anh ta được phép đẩy.

Là bước đầu tiên, John tìm nạp công việc của Jessica (điều này chỉ _tìm nạp_ công việc ngược dòng của Jessica, nó chưa hợp nhất nó vào công việc của John):

[source,console]
----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
----

Tại thời điểm này, kho lưu trữ cục bộ của John trông giống như thế này:

.Lịch sử phân kỳ của John
image::images/small-team-1.png[Lịch sử phân kỳ của John]

Bây giờ John có thể hợp nhất công việc của Jessica mà anh ấy đã tìm nạp vào công việc cục bộ của chính mình:

[source,console]
----
$ git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +

(((git commands, request-pull)))
Once your work has been pushed to your fork of the repository, you need to notify the maintainers of the original project that you have work you'd like them to merge.
This is often called a _pull request_, and you typically generate such a request either via the website -- GitHub has its own "`Pull Request`" mechanism that we'll go over in <<ch06-github#ch06-github>> -- or you can run the `git request-pull` command and email the subsequent output to the project maintainer manually.

The `git request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and produces a summary of all the changes you're asking to be pulled.
For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed, she can run this:

[source,console]
----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
Jessica Smith (1):
        Create new function

are available in the git repository at:

  https://githost/simplegit.git featureA

Jessica Smith (2):
      Add limit to log function
      Increase log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
----

This output can be sent to the maintainer -- it tells them where the work was branched from, summarizes the commits, and identifies from where the new work is to be pulled.

On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up -- start over from the main repository's `master` branch:

[source,console]
----
$ git checkout -b featureB origin/master
  ... work ...
$ git commit
$ git push myfork featureB
$ git request-pull origin/master myfork
  ... email generated request pull to maintainer ...
$ git fetch origin
----

Now, each of your topics is contained within a silo -- similar to a patch queue -- that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:

.Initial commit history with `featureB` work
image::images/public-small-1.png[Initial commit history with `featureB` work]

Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:

[source,console]
----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
----

This rewrites your history to now look like <<psp_b>>.

[[psp_b]]
.Commit history after `featureA` work
image::images/public-small-2.png[Commit history after `featureA` work]

Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).

Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that as a new branch:

(((git commands, merge, squash)))
[source,console]
----
$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
  ... change implementation ...
$ git commit
$ git push myfork featureBv2
----

The `--squash` option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit.
This means your future commit will have one parent only and allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
Also the `--no-commit` option can be useful to delay the merge commit in case of the default merge process.

At this point, you can notify the maintainer that you've made the requested changes, and that they can find those changes in your `featureBv2` branch.

.Commit history after `featureBv2` work
image::images/public-small-3.png[Commit history after `featureBv2` work]

[[_project_over_email]]
==== Public Project over Email

(((contributing, public large project)))
Many projects have established procedures for accepting patches -- you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.

The workflow is similar to the previous use case -- you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate email versions of each commit series and email them to the developer mailing list:

[source,console]
----
$ git checkout -b topicA
  ... work ...
$ git commit
  ... work ...
$ git commit
----

(((git commands, format-patch)))
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can email to the list -- it turns each commit into an email message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an email generated with `format-patch` preserves all the commit information properly.

[source,console]
----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-increase-log-output-to-30-from-25.patch
----

The `format-patch` command prints out the names of the patch files it creates.
The `-M` switch tells Git to look for renames.
The files end up looking like this:

[source,console]
----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] Add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
----

You can also edit these patch files to add more information for the email list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), the developers can read it, but that content is ignored by the patching process.

To email this to a mailing list, you can either paste the file into your email program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with "`smarter`" clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the email agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.

(((git commands, config)))(((email)))
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:

[source,ini]
----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = YX]8g76G_2^sFbd
  port = 993
  sslverify = false
----

If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git imap-send` to place the patch series in the Drafts folder of the specified IMAP server:

[source,console]
----
$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done
----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

Bạn cũng có thể gửi các bản vá thông qua một máy chủ SMTP.
Như trước đây, bạn có thể đặt từng giá trị riêng biệt với một loạt các lệnh `git config`, hoặc bạn có thể thêm chúng thủ công trong phần sendemail trong tệp `~/.gitconfig` của bạn:

[source,ini]
----
[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587
----

Sau khi thực hiện xong, bạn có thể sử dụng `git send-email` để gửi các bản vá của mình:

[source,console]
----
$ git send-email *.patch
0001-add-limit-to-log-function.patch
0002-increase-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
----

Sau đó, Git nhổ ra một loạt thông tin nhật ký trông giống như thế này cho mỗi bản vá bạn đang gửi:

[source,text]
----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] Add limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
----

[TIP]
====
Để được trợ giúp về cấu hình hệ thống và email của bạn, thêm các mẹo và thủ thuật, và một hộp cát để gửi bản vá thử nghiệm qua email, hãy truy cập https://git-send-email.io[git-send-email.io^].
====

==== Tóm tắt

Trong phần này, chúng tôi đã đề cập đến nhiều quy trình làm việc, và nói về sự khác biệt giữa làm việc như một phần của một nhóm nhỏ trong các dự án nguồn đóng so với đóng góp cho một dự án công khai lớn.
Bạn biết kiểm tra các lỗi khoảng trắng trước khi cam kết, và có thể viết một thông báo cam kết tuyệt vời.
Bạn đã học cách định dạng các bản vá, và gửi email chúng đến danh sách gửi thư của nhà phát triển.
Việc xử lý các hợp nhất cũng đã được đề cập trong bối cảnh của các quy trình làm việc khác nhau.
Bây giờ bạn đã chuẩn bị tốt để cộng tác trên bất kỳ dự án nào.

Tiếp theo, bạn sẽ thấy cách làm việc ở mặt bên kia của đồng xu: duy trì một dự án Git.
Bạn sẽ học cách trở thành một nhà độc tài nhân từ hoặc người quản lý tích hợp.
