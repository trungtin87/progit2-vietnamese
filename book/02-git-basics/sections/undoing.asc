[[_undoing]]
=== Hoàn tác Mọi thứ

Ở bất kỳ giai đoạn nào, bạn có thể muốn hoàn tác một cái gì đó.
Ở đây, chúng tôi sẽ xem xét một vài công cụ cơ bản để hoàn tác các thay đổi mà bạn đã thực hiện.
Hãy cẩn thận, bởi vì bạn không thể luôn luôn hoàn tác một số trong những lần hoàn tác này.
Đây là một trong số ít các khu vực trong Git mà bạn có thể mất một số công việc nếu bạn làm sai.

Một trong những lần hoàn tác phổ biến diễn ra khi bạn cam kết quá sớm và có thể quên thêm một số tệp, hoặc bạn làm hỏng thông điệp cam kết của mình.
Nếu bạn muốn làm lại cam kết đó, hãy thực hiện các thay đổi bổ sung mà bạn đã quên, tổ chức chúng và cam kết lại bằng cách sử dụng tùy chọn `--amend`:

[source,console]
----
$ git commit --amend
----

Lệnh này lấy khu vực tổ chức của bạn và sử dụng nó cho cam kết.
Nếu bạn không thực hiện thay đổi nào kể từ lần cam kết cuối cùng của mình (ví dụ: bạn chạy lệnh này ngay sau lần cam kết trước đó của mình), thì ảnh chụp nhanh của bạn sẽ trông giống hệt nhau và tất cả những gì bạn sẽ thay đổi là thông điệp cam kết của bạn.

Trình soạn thảo thông điệp cam kết tương tự sẽ kích hoạt, nhưng nó đã chứa thông điệp của cam kết trước đó của bạn.
Bạn có thể chỉnh sửa thông điệp giống như mọi khi, nhưng nó ghi đè lên cam kết trước đó của bạn.

Ví dụ, nếu bạn cam kết và sau đó nhận ra bạn quên tổ chức các thay đổi trong một tệp bạn muốn thêm vào cam kết này, bạn có thể làm một cái gì đó như thế này:

[source,console]
----
$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend
----

Bạn kết thúc với một cam kết duy nhất -- cam kết thứ hai thay thế kết quả của cam kết đầu tiên.

[NOTE]
====
Điều quan trọng là phải hiểu rằng khi bạn sửa đổi cam kết cuối cùng của mình, bạn không sửa nó nhiều bằng việc _thay thế_ nó hoàn toàn bằng một cam kết mới, được cải thiện đẩy cam kết cũ ra khỏi đường và đặt cam kết mới vào vị trí của nó.
Về hiệu quả, nó giống như cam kết trước đó chưa bao giờ xảy ra và nó sẽ không hiển thị trong lịch sử kho lưu trữ của bạn.

Giá trị rõ ràng của việc sửa đổi các cam kết là thực hiện các cải tiến nhỏ cho cam kết cuối cùng của bạn, mà không làm lộn xộn lịch sử kho lưu trữ của bạn với các thông điệp cam kết có dạng, "`Oops, forgot to add a file`" hoặc "`Darn, fixing a typo in last commit`".
====

[NOTE]
====
Chỉ sửa đổi các cam kết vẫn còn cục bộ và chưa được đẩy đi đâu đó.
Sửa đổi các cam kết đã đẩy trước đó và buộc đẩy nhánh sẽ gây ra vấn đề cho các cộng tác viên của bạn.
Để biết thêm về những gì xảy ra khi bạn làm điều này và cách khôi phục nếu bạn là người nhận, hãy đọc <<_rebase_peril>>.
====

[[_unstaging]]
==== Hủy tổ chức một Tệp đã Tổ chức

Hai phần tiếp theo minh họa cách làm việc với khu vực tổ chức và các thay đổi thư mục làm việc của bạn.
Phần hay là lệnh bạn sử dụng để xác định trạng thái của hai khu vực đó cũng nhắc nhở bạn cách hoàn tác các thay đổi đối với chúng.
Ví dụ: giả sử bạn đã thay đổi hai tệp và muốn cam kết chúng dưới dạng hai thay đổi riêng biệt, nhưng bạn vô tình nhập `git add *` và tổ chức cả hai.
Làm thế nào bạn có thể hủy tổ chức một trong hai?
Lệnh `git status` nhắc nhở bạn:

[source,console]
----
$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
    modified:   CONTRIBUTING.md
----

Ngay bên dưới văn bản "`Changes to be committed`", nó nói sử dụng `git reset HEAD <file>...` để hủy tổ chức.
Vì vậy, hãy sử dụng lời khuyên đó để hủy tổ chức tệp `CONTRIBUTING.md`:

[source,console]
----
$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Lệnh này hơi lạ, nhưng nó hoạt động.
Tệp `CONTRIBUTING.md` được sửa đổi nhưng một lần nữa không được tổ chức.

[NOTE]
=====
Đúng là `git reset` có thể là một lệnh nguy hiểm, đặc biệt nếu bạn cung cấp cờ `--hard`.
Tuy nhiên, trong kịch bản được mô tả ở trên, tệp trong thư mục làm việc của bạn không bị chạm vào, vì vậy nó tương đối an toàn.
=====

Hiện tại, lời gọi ma thuật này là tất cả những gì bạn cần biết về lệnh `git reset`.
Chúng ta sẽ đi sâu hơn vào chi tiết về những gì `reset` làm và cách làm chủ nó để làm những điều thực sự thú vị trong <<ch07-git-tools#_git_reset>>.

==== Hủy sửa đổi một Tệp đã Sửa đổi

Điều gì sẽ xảy ra nếu bạn nhận ra rằng bạn không muốn giữ các thay đổi của mình đối với tệp `CONTRIBUTING.md`?
Làm thế nào bạn có thể dễ dàng hủy sửa đổi nó -- hoàn nguyên nó về trạng thái như khi bạn cam kết lần cuối (hoặc sao chép ban đầu, hoặc bất cứ cách nào bạn đưa nó vào thư mục làm việc của mình)?
May mắn thay, `git status` cũng cho bạn biết cách làm điều đó.
Trong đầu ra ví dụ cuối cùng, khu vực chưa được tổ chức trông giống như thế này:

[source,console]
----
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Nó cho bạn biết khá rõ ràng cách loại bỏ các thay đổi bạn đã thực hiện.
Hãy làm những gì nó nói:

[source,console]
----
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

----

Bạn có thể thấy rằng các thay đổi đã được hoàn nguyên.

[IMPORTANT]
=====
Điều quan trọng là phải hiểu rằng `git checkout \-- <file>` là một lệnh nguy hiểm.
Bất kỳ thay đổi cục bộ nào bạn đã thực hiện đối với tệp đó đều biến mất -- Git chỉ cần thay thế tệp đó bằng phiên bản đã tổ chức hoặc cam kết cuối cùng.
Đừng bao giờ sử dụng lệnh này trừ khi bạn hoàn toàn biết rằng bạn không muốn những thay đổi cục bộ chưa được lưu đó.
=====

Nếu bạn muốn giữ các thay đổi bạn đã thực hiện đối với tệp đó nhưng vẫn cần loại bỏ nó ngay bây giờ, chúng ta sẽ xem xét việc stash và phân nhánh trong <<ch03-git-branching#ch03-git-branching>>; đây thường là những cách tốt hơn để đi.

Hãy nhớ rằng, bất cứ điều gì được _cam kết_ trong Git hầu như luôn có thể được phục hồi.
Ngay cả các cam kết trên các nhánh đã bị xóa hoặc các cam kết bị ghi đè bằng cam kết `--amend` cũng có thể được phục hồi (xem <<ch10-git-internals#_data_recovery>> để phục hồi dữ liệu).
Tuy nhiên, bất cứ điều gì bạn mất mà chưa bao giờ được cam kết có khả năng không bao giờ được nhìn thấy nữa.

[[undoing_git_restore]]
==== Hoàn tác mọi thứ với git restore

Git phiên bản 2.23.0 đã giới thiệu một lệnh mới: `git restore`.
Về cơ bản, nó là một sự thay thế cho `git reset` mà chúng ta vừa đề cập.
Từ phiên bản Git 2.23.0 trở đi, Git sẽ sử dụng `git restore` thay vì `git reset` cho nhiều thao tác hoàn tác.

Hãy quay lại các bước của chúng ta và hoàn tác mọi thứ với `git restore` thay vì `git reset`.

===== Hủy tổ chức một Tệp đã Tổ chức với git restore

Hai phần tiếp theo minh họa cách làm việc với khu vực tổ chức và các thay đổi thư mục làm việc của bạn với `git restore`.
Phần hay là lệnh bạn sử dụng để xác định trạng thái của hai khu vực đó cũng nhắc nhở bạn cách hoàn tác các thay đổi đối với chúng.
Ví dụ: giả sử bạn đã thay đổi hai tệp và muốn cam kết chúng dưới dạng hai thay đổi riêng biệt, nhưng bạn vô tình nhập `git add *` và tổ chức cả hai.
Làm thế nào bạn có thể hủy tổ chức một trong hai?
Lệnh `git status` nhắc nhở bạn:

[source,console]
----
$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   CONTRIBUTING.md
	renamed:    README.md -> README

----

Ngay bên dưới văn bản "`Changes to be committed`", nó nói sử dụng `git restore --staged <file>...` để hủy tổ chức.
Vì vậy, hãy sử dụng lời khuyên đó để hủy tổ chức tệp `CONTRIBUTING.md`:

[source,console]
----
$ git restore --staged CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   CONTRIBUTING.md

----

Tệp `CONTRIBUTING.md` được sửa đổi nhưng một lần nữa không được tổ chức.

===== Hủy sửa đổi một Tệp đã Sửa đổi với git restore

Điều gì sẽ xảy ra nếu bạn nhận ra rằng bạn không muốn giữ các thay đổi của mình đối với tệp `CONTRIBUTING.md`?
Làm thế nào bạn có thể dễ dàng hủy sửa đổi nó -- hoàn nguyên nó về trạng thái như khi bạn cam kết lần cuối (hoặc sao chép ban đầu, hoặc bất cứ cách nào bạn đưa nó vào thư mục làm việc của mình)?
May mắn thay, `git status` cũng cho bạn biết cách làm điều đó.
Trong đầu ra ví dụ cuối cùng, khu vực chưa được tổ chức trông giống như thế này:

[source,console]
----
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   CONTRIBUTING.md

----

Nó cho bạn biết khá rõ ràng cách loại bỏ các thay đổi bạn đã thực hiện.
Hãy làm những gì nó nói:

[source,console]
----
$ git restore CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    README.md -> README

----

[IMPORTANT]
=====
Điều quan trọng là phải hiểu rằng `git restore <file>` là một lệnh nguy hiểm.
Bất kỳ thay đổi cục bộ nào bạn đã thực hiện đối với tệp đó đều biến mất -- Git chỉ cần thay thế tệp đó bằng phiên bản đã tổ chức hoặc cam kết cuối cùng.
Đừng bao giờ sử dụng lệnh này trừ khi bạn hoàn toàn biết rằng bạn không muốn những thay đổi cục bộ chưa được lưu đó.
=====
