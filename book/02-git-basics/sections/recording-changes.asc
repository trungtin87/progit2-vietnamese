=== Ghi lại các Thay đổi vào Kho chứa

Đến đây, bạn đã có một kho chứa Git _thực thụ_ trên máy cục bộ của mình, và một bản checkout hay _bản sao làm việc_ của tất cả các file của nó ở trước mặt.
Thông thường, bạn sẽ muốn bắt đầu thực hiện các thay đổi và commit các snapshot của những thay đổi đó vào kho chứa của mình mỗi khi dự án đạt đến một trạng thái mà bạn muốn ghi lại.

Hãy nhớ rằng mỗi file trong thư mục làm việc của bạn có thể ở một trong hai trạng thái: _được theo dõi_ (tracked) hoặc _không được theo dõi_ (untracked).
Các file được theo dõi là những file đã có trong snapshot cuối cùng, cũng như bất kỳ file mới nào được đưa vào khu vực tổ chức (staged); chúng có thể ở trạng thái chưa bị sửa đổi, đã bị sửa đổi, hoặc đã được tổ chức.
Nói tóm lại, các file được theo dõi là những file mà Git biết đến.

Các file không được theo dõi là tất cả những file còn lại -- bất kỳ file nào trong thư mục làm việc của bạn mà không có trong snapshot cuối cùng của bạn và không nằm trong khu vực tổ chức của bạn.
Khi bạn lần đầu tiên sao chép (clone) một kho chứa, tất cả các file của bạn sẽ ở trạng thái được theo dõi và chưa bị sửa đổi vì Git vừa mới checkout chúng và bạn chưa chỉnh sửa bất cứ thứ gì.

Khi bạn chỉnh sửa các file, Git xem chúng là đã bị sửa đổi, bởi vì bạn đã thay đổi chúng kể từ lần commit cuối cùng của mình.
Khi bạn làm việc, bạn chọn lọc đưa các file đã bị sửa đổi này vào khu vực tổ chức và sau đó commit tất cả những thay đổi đã được tổ chức đó, và chu trình lặp lại.

.Vòng đời trạng thái của các file của bạn
image::images/lifecycle.png[Vòng đời trạng thái của các file của bạn]

[[_checking_status]]
==== Kiểm tra Trạng thái các File của bạn

Công cụ chính bạn sử dụng để xác định file nào đang ở trạng thái nào là lệnh `git status`.(((git commands, status)))
Nếu bạn chạy lệnh này ngay sau khi clone, bạn sẽ thấy kết quả tương tự như sau:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
----

Điều này có nghĩa là bạn có một thư mục làm việc sạch; nói cách khác, không có file nào được theo dõi của bạn bị sửa đổi.
Git cũng không thấy bất kỳ file không được theo dõi nào, nếu có chúng sẽ được liệt kê ở đây.
Cuối cùng, lệnh này cho bạn biết bạn đang ở trên nhánh nào và thông báo rằng nó không bị phân kỳ so với nhánh cùng tên trên máy chủ.
Hiện tại, nhánh đó luôn là `master`, là nhánh mặc định; bạn không cần lo lắng về nó ở đây.
<<ch03-git-branching#ch03-git-branching>> sẽ đi sâu vào các nhánh và tham chiếu một cách chi tiết.

[NOTE]
====
GitHub đã thay đổi tên nhánh mặc định từ `master` thành `main` vào giữa năm 2020, và các host Git khác cũng làm theo.
Vì vậy, bạn có thể thấy rằng tên nhánh mặc định trong một số kho chứa mới tạo là `main` chứ không phải `master`.
Ngoài ra, tên nhánh mặc định có thể được thay đổi (như bạn đã thấy trong <<ch01-getting-started#_new_default_branch>>), vì vậy bạn có thể thấy một tên khác cho nhánh mặc định.

Tuy nhiên, bản thân Git vẫn sử dụng `master` làm mặc định, vì vậy chúng tôi sẽ sử dụng nó trong suốt cuốn sách này.
====

Giả sử bạn thêm một file mới vào dự án của mình, một file `README` đơn giản.
Nếu file này chưa tồn tại trước đó, và bạn chạy `git status`, bạn sẽ thấy file không được theo dõi của mình như sau:

[source,console]
----
$ echo 'Dự án của tôi' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

Bạn có thể thấy rằng file `README` mới của bạn không được theo dõi, bởi vì nó nằm dưới tiêu đề "`Untracked files`" trong kết quả trạng thái của bạn.
Không được theo dõi về cơ bản có nghĩa là Git thấy một file mà bạn không có trong snapshot trước đó (commit), và nó chưa được tổ chức; Git sẽ không bắt đầu bao gồm nó trong các snapshot commit của bạn cho đến khi bạn nói rõ cho nó làm vậy.
Nó làm điều này để bạn không vô tình bắt đầu bao gồm các file nhị phân được tạo ra hoặc các file khác mà bạn không có ý định bao gồm.
Bạn muốn bắt đầu bao gồm `README`, vậy hãy bắt đầu theo dõi file này.

[[_tracking_files]]
==== Theo dõi File mới

Để bắt đầu theo dõi một file mới, bạn sử dụng lệnh `git add`.(((git commands, add)))
Để bắt đầu theo dõi file `README`, bạn có thể chạy:

[source,console]
----
$ git add README
----

Nếu bạn chạy lại lệnh status, bạn có thể thấy rằng file `README` của bạn hiện đã được theo dõi và được tổ chức để commit:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README

----

Bạn có thể biết rằng nó đã được tổ chức vì nó nằm dưới tiêu đề "`Changes to be committed`".
Nếu bạn commit tại thời điểm này, phiên bản của file tại thời điểm bạn chạy `git add` là phiên bản sẽ có trong snapshot lịch sử tiếp theo.
Bạn có thể nhớ lại rằng khi bạn chạy `git init` trước đó, bạn sau đó đã chạy `git add <files>` -- đó là để bắt đầu theo dõi các file trong thư mục của bạn.(((git commands, init)))(((git commands, add)))
Lệnh `git add` nhận một tên đường dẫn cho một file hoặc một thư mục; nếu đó là một thư mục, lệnh sẽ thêm tất cả các file trong thư mục đó một cách đệ quy.

==== Tổ chức các File đã bị sửa đổi

Hãy thay đổi một file đã được theo dõi.
Nếu bạn thay đổi một file đã được theo dõi trước đó có tên là `CONTRIBUTING.md` và sau đó chạy lại lệnh `git status`, bạn sẽ nhận được một kết quả trông như thế này:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

File `CONTRIBUTING.md` xuất hiện dưới một phần có tên "`Changes not staged for commit`" -- điều này có nghĩa là một file đang được theo dõi đã bị sửa đổi trong thư mục làm việc nhưng chưa được tổ chức.
Để tổ chức nó, bạn chạy lệnh `git add`.
`git add` là một lệnh đa năng -- bạn sử dụng nó để bắt đầu theo dõi các file mới, để tổ chức các file, và để làm những việc khác như đánh dấu các file bị xung đột khi gộp (merge-conflicted) là đã được giải quyết.
Có thể hữu ích khi nghĩ về nó nhiều hơn như là "`thêm chính xác nội dung này vào commit tiếp theo`" hơn là "`thêm file này vào dự án`".(((git commands, add)))
Hãy chạy `git add` ngay bây giờ để tổ chức file `CONTRIBUTING.md`, và sau đó chạy lại `git status`:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

Cả hai file đều đã được tổ chức và sẽ được đưa vào commit tiếp theo của bạn.
Tại thời điểm này, giả sử bạn nhớ ra một thay đổi nhỏ mà bạn muốn thực hiện trong `CONTRIBUTING.md` trước khi commit.
Bạn mở lại nó và thực hiện thay đổi đó, và bạn đã sẵn sàng để commit.
Tuy nhiên, hãy chạy `git status` một lần nữa:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Cái quái gì vậy?
Bây giờ `CONTRIBUTING.md` được liệt kê là vừa được tổ chức _và_ chưa được tổ chức.
Làm thế nào điều đó có thể xảy ra?
Hóa ra Git tổ chức một file chính xác như nó có khi bạn chạy lệnh `git add`.
Nếu bạn commit bây giờ, phiên bản của `CONTRIBUTING.md` như khi bạn chạy lệnh `git add` lần cuối là cách nó sẽ được đưa vào commit, chứ không phải phiên bản của file như nó trông trong thư mục làm việc của bạn khi bạn chạy `git commit`.
Nếu bạn sửa đổi một file sau khi bạn chạy `git add`, bạn phải chạy `git add` một lần nữa để tổ chức phiên bản mới nhất của file:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

==== Trạng thái Ngắn gọn

Trong khi kết quả `git status` khá toàn diện, nó cũng khá dài dòng.
Git cũng có một cờ trạng thái ngắn gọn để bạn có thể xem các thay đổi của mình một cách gọn gàng hơn.
Nếu bạn chạy `git status -s` hoặc `git status --short`, bạn sẽ nhận được một kết quả đơn giản hơn nhiều từ lệnh:

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

Các file mới không được theo dõi có một dấu `??` bên cạnh, các file mới đã được thêm vào khu vực tổ chức có một `A`, các file bị sửa đổi có một `M`, v.v.
Có hai cột trong kết quả -- cột bên trái cho biết trạng thái của khu vực tổ chức và cột bên phải cho biết trạng thái của cây làm việc.
Ví dụ trong kết quả đó, file `README` bị sửa đổi trong thư mục làm việc nhưng chưa được tổ chức, trong khi file `lib/simplegit.rb` bị sửa đổi và đã được tổ chức.
File `Rakefile` đã bị sửa đổi, được tổ chức và sau đó bị sửa đổi một lần nữa, vì vậy có những thay đổi cho nó vừa được tổ chức vừa chưa được tổ chức.

[[_ignoring]]
==== Bỏ qua các File

Thường thì, bạn sẽ có một loại file mà bạn không muốn Git tự động thêm hoặc thậm chí hiển thị cho bạn là đang không được theo dõi.
Đây thường là các file được tạo tự động như file log hoặc các file được tạo ra bởi hệ thống build của bạn.
Trong những trường hợp như vậy, bạn có thể tạo một file liệt kê các mẫu để khớp với chúng có tên là `.gitignore`.(((ignoring files)))
Đây là một ví dụ về file `.gitignore`:

[source,console]
----
$ cat .gitignore
*.a
*~
----

Dòng đầu tiên yêu cầu Git bỏ qua bất kỳ file nào kết thúc bằng ".a" -- các file đối tượng và file lưu trữ có thể là sản phẩm của việc build mã của bạn.
Dòng thứ hai yêu cầu Git bỏ qua tất cả các file có tên kết thúc bằng dấu ngã (`~`), được nhiều trình soạn thảo văn bản như Emacs sử dụng để đánh dấu các file tạm thời.
Bạn cũng có thể bao gồm một thư mục log, tmp, hoặc pid; tài liệu được tạo tự động; v.v.
Việc thiết lập một file `.gitignore` cho kho chứa mới của bạn trước khi bắt đầu thường là một ý kiến hay để bạn không vô tình commit các file mà bạn thực sự không muốn có trong kho chứa Git của mình.

Các quy tắc cho các mẫu bạn có thể đặt trong file `.gitignore` như sau:

* Các dòng trống hoặc các dòng bắt đầu bằng `#` sẽ bị bỏ qua.
* Các mẫu glob tiêu chuẩn hoạt động và sẽ được áp dụng đệ quy trong toàn bộ cây làm việc.
* Bạn có thể bắt đầu các mẫu bằng một dấu gạch chéo (`/`) để tránh đệ quy.
* Bạn có thể kết thúc các mẫu bằng một dấu gạch chéo (`/`) để chỉ định một thư mục.
* Bạn có thể phủ định một mẫu bằng cách bắt đầu nó bằng một dấu chấm than (`!`).

Các mẫu glob giống như các biểu thức chính quy được đơn giản hóa mà các shell sử dụng.
Một dấu hoa thị (`*`) khớp với không hoặc nhiều ký tự; `[abc]` khớp với bất kỳ ký tự nào bên trong dấu ngoặc (trong trường hợp này là a, b, hoặc c); một dấu chấm hỏi (`?`) khớp với một ký tự duy nhất; và dấu ngoặc vuông chứa các ký tự được phân tách bằng dấu gạch ngang (`[0-9]`) khớp với bất kỳ ký tự nào giữa chúng (trong trường hợp này là từ 0 đến 9).
Bạn cũng có thể sử dụng hai dấu hoa thị để khớp với các thư mục lồng nhau; `a/**/z` sẽ khớp với `a/z`, `a/b/z`, `a/b/c/z`, v.v.

Đây là một ví dụ khác về file `.gitignore`:

[source]
----
# bỏ qua tất cả các file .a
*.a

# nhưng theo dõi lib.a, mặc dù bạn đang bỏ qua các file .a ở trên
!lib.a

# chỉ bỏ qua file TODO trong thư mục hiện tại, không phải subdir/TODO
/TODO

# bỏ qua tất cả các file trong bất kỳ thư mục nào có tên là build
build/

# bỏ qua doc/notes.txt, nhưng không phải doc/server/arch.txt
doc/*.txt

# bỏ qua tất cả các file .pdf trong thư mục doc/ và bất kỳ thư mục con nào của nó
doc/**/*.pdf
----

[TIP]
====
GitHub duy trì một danh sách khá toàn diện các ví dụ file `.gitignore` tốt cho hàng tá dự án và ngôn ngữ tại https://github.com/github/gitignore[^] nếu bạn muốn có một điểm khởi đầu cho dự án của mình.
====

[NOTE]
====
Trong trường hợp đơn giản, một kho chứa có thể có một file `.gitignore` duy nhất trong thư mục gốc của nó, áp dụng đệ quy cho toàn bộ kho chứa.
Tuy nhiên, cũng có thể có các file `.gitignore` bổ sung trong các thư mục con.
Các quy tắc trong các file `.gitignore` lồng nhau này chỉ áp dụng cho các file dưới thư mục nơi chúng được đặt.
Kho chứa mã nguồn hạt nhân Linux có 206 file `.gitignore`.

Việc đi vào chi tiết về nhiều file `.gitignore` nằm ngoài phạm vi của cuốn sách này; xem `man gitignore` để biết chi tiết.
====

[[_git_diff_staged]]
==== Xem các Thay đổi đã được Tổ chức và Chưa được Tổ chức của bạn

Nếu lệnh `git status` quá mơ hồ đối với bạn -- bạn muốn biết chính xác những gì bạn đã thay đổi, không chỉ là những file nào đã được thay đổi -- bạn có thể sử dụng lệnh `git diff`.(((git commands, diff)))
Chúng ta sẽ tìm hiểu chi tiết hơn về `git diff` sau này, nhưng bạn có thể sẽ sử dụng nó thường xuyên nhất để trả lời hai câu hỏi sau: Bạn đã thay đổi những gì nhưng chưa được tổ chức?
Và bạn đã tổ chức những gì mà bạn sắp commit?
Mặc dù `git status` trả lời những câu hỏi đó một cách rất chung chung bằng cách liệt kê tên file, `git diff` cho bạn thấy các dòng chính xác đã được thêm và xóa -- bản vá, có thể nói như vậy.

Giả sử bạn chỉnh sửa và tổ chức file `README` một lần nữa và sau đó chỉnh sửa file `CONTRIBUTING.md` mà không tổ chức nó.
Nếu bạn chạy lệnh `git status`, bạn sẽ một lần nữa thấy một cái gì đó như thế này:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Để xem những gì bạn đã thay đổi nhưng chưa được tổ chức, hãy gõ `git diff` mà không có đối số nào khác:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

Lệnh đó so sánh những gì có trong thư mục làm việc của bạn với những gì có trong khu vực tổ chức của bạn.
Kết quả cho bạn biết những thay đổi bạn đã thực hiện mà bạn chưa tổ chức.

Nếu bạn muốn xem những gì bạn đã tổ chức sẽ được đưa vào commit tiếp theo, bạn có thể sử dụng `git diff --staged`.
Lệnh này so sánh các thay đổi đã được tổ chức của bạn với commit cuối cùng của bạn:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+Dự án của tôi
----

Điều quan trọng cần lưu ý là `git diff` tự nó không hiển thị tất cả các thay đổi được thực hiện kể từ commit cuối cùng của bạn -- chỉ những thay đổi vẫn chưa được tổ chức.
Nếu bạn đã tổ chức tất cả các thay đổi của mình, `git diff` sẽ không có kết quả đầu ra.

Đối với một ví dụ khác, nếu bạn tổ chức file `CONTRIBUTING.md` và sau đó chỉnh sửa nó, bạn có thể sử dụng `git diff` để xem các thay đổi trong file đã được tổ chức và các thay đổi chưa được tổ chức.
Nếu môi trường của chúng ta trông như thế này:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# dòng test' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Bây giờ bạn có thể sử dụng `git diff` để xem những gì vẫn chưa được tổ chức:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# dòng test
----

và `git diff --cached` để xem những gì bạn đã tổ chức cho đến nay (`--staged` và `--cached` là từ đồng nghĩa):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
.Git Diff trong một Công cụ Bên ngoài
====
Chúng ta sẽ tiếp tục sử dụng lệnh `git diff` theo nhiều cách khác nhau trong phần còn lại của cuốn sách.
Có một cách khác để xem các diff này nếu bạn thích một chương trình xem diff đồ họa hoặc bên ngoài.
Nếu bạn chạy `git difftool` thay vì `git diff`, bạn có thể xem bất kỳ diff nào trong số này trong phần mềm như emerge, vimdiff và nhiều hơn nữa (bao gồm cả các sản phẩm thương mại).
Chạy `git difftool --tool-help` để xem những gì có sẵn trên hệ thống của bạn.
====

[[_committing_changes]]
==== Commit các Thay đổi của bạn

Bây giờ khu vực tổ chức của bạn đã được thiết lập theo cách bạn muốn, bạn có thể commit các thay đổi của mình.
Hãy nhớ rằng bất cứ thứ gì vẫn chưa được tổ chức -- bất kỳ file nào bạn đã tạo hoặc sửa đổi mà bạn chưa chạy `git add` kể từ khi bạn chỉnh sửa chúng -- sẽ không được đưa vào commit này.
Chúng sẽ vẫn là các file đã bị sửa đổi trên đĩa của bạn.
Trong trường hợp này, giả sử rằng lần cuối cùng bạn chạy `git status`, bạn thấy rằng mọi thứ đã được tổ chức, vì vậy bạn đã sẵn sàng để commit các thay đổi của mình.(((git commands, status)))
Cách đơn giản nhất để commit là gõ `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Làm như vậy sẽ khởi chạy trình soạn thảo mà bạn chọn.

[NOTE]
====
Điều này được thiết lập bởi biến môi trường `EDITOR` của shell của bạn -- thường là vim hoặc emacs, mặc dù bạn có thể cấu hình nó với bất cứ thứ gì bạn muốn bằng cách sử dụng lệnh `git config --global core.editor` như bạn đã thấy trong <<ch01-getting-started#ch01-getting-started>>.(((editor, changing default)))(((git commands, config)))
====

Trình soạn thảo hiển thị văn bản sau (ví dụ này là màn hình Vim):

[source]
----

# Vui lòng nhập thông điệp commit cho các thay đổi của bạn. Các dòng bắt đầu
# bằng '#' sẽ bị bỏ qua, và một thông điệp trống sẽ hủy bỏ commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#\tnew file:   README
#\tmodified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

Bạn có thể thấy rằng thông điệp commit mặc định chứa kết quả mới nhất của lệnh `git status` được chú thích và một dòng trống ở trên cùng.
Bạn có thể xóa các chú thích này và gõ thông điệp commit của mình, hoặc bạn có thể để chúng ở đó để giúp bạn nhớ những gì bạn đang commit.

[NOTE]
====
Để có một lời nhắc nhở rõ ràng hơn về những gì bạn đã sửa đổi, bạn có thể truyền tùy chọn `-v` cho `git commit`.
Làm như vậy cũng đưa diff của thay đổi của bạn vào trình soạn thảo để bạn có thể thấy chính xác những thay đổi bạn đang commit.
====

Khi bạn thoát khỏi trình soạn thảo, Git sẽ tạo commit của bạn với thông điệp commit đó (với các chú thích và diff đã được loại bỏ).

Ngoài ra, bạn có thể gõ thông điệp commit của mình cùng với lệnh `commit` bằng cách chỉ định nó sau một cờ `-m`, như thế này:

[source,console]
----
$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Bây giờ bạn đã tạo commit đầu tiên của mình!
Bạn có thể thấy rằng commit đã cho bạn một số kết quả về chính nó: bạn đã commit vào nhánh nào (`master`), commit có checksum SHA-1 nào (`463dc4f`), bao nhiêu file đã được thay đổi, và thống kê về số dòng đã được thêm và xóa trong commit.

Hãy nhớ rằng commit ghi lại snapshot mà bạn đã thiết lập trong khu vực tổ chức của mình.
Bất cứ thứ gì bạn không tổ chức vẫn còn ở đó bị sửa đổi; bạn có thể thực hiện một commit khác để thêm nó vào lịch sử của mình.
Mỗi lần bạn thực hiện một commit, bạn đang ghi lại một snapshot của dự án của mình mà bạn có thể hoàn nguyên về hoặc so sánh với sau này.

==== Bỏ qua Khu vực Tổ chức

(((staging area, skipping)))
Mặc dù nó có thể cực kỳ hữu ích để tạo các commit chính xác như bạn muốn, khu vực tổ chức đôi khi hơi phức tạp hơn bạn cần trong quy trình làm việc của mình.
Nếu bạn muốn bỏ qua khu vực tổ chức, Git cung cấp một phím tắt đơn giản.
Thêm tùy chọn `-a` vào lệnh `git commit` làm cho Git tự động tổ chức mọi file đã được theo dõi trước khi thực hiện commit, cho phép bạn bỏ qua phần `git add`:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'Thêm benchmark mới'
[master 83e38c7] Thêm benchmark mới
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Lưu ý cách bạn không phải chạy `git add` trên file `CONTRIBUTING.md` trong trường hợp này trước khi bạn commit.
Đó là bởi vì cờ `-a` bao gồm tất cả các file đã thay đổi.
Điều này tiện lợi, nhưng hãy cẩn thận; đôi khi cờ này sẽ khiến bạn bao gồm các thay đổi không mong muốn.

[[_removing_files]]
==== Xóa các File

(((files, removing)))
Để xóa một file khỏi Git, bạn phải xóa nó khỏi các file được theo dõi của mình (chính xác hơn là xóa nó khỏi khu vực tổ chức của bạn) và sau đó commit.
Lệnh `git rm` thực hiện điều đó, và cũng xóa file khỏi thư mục làm việc của bạn để bạn không thấy nó là một file không được theo dõi vào lần sau.

Nếu bạn chỉ cần xóa file khỏi thư mục làm việc của mình, nó sẽ xuất hiện dưới khu vực "`Changes not staged for commit`" (nghĩa là, _chưa được tổ chức_) của kết quả `git status` của bạn:

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Sau đó, nếu bạn chạy `git rm`, nó sẽ tổ chức việc xóa file:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

Lần commit tiếp theo, file sẽ biến mất và không còn được theo dõi nữa.
Nếu bạn đã sửa đổi file hoặc đã thêm nó vào khu vực tổ chức, bạn phải buộc xóa bằng tùy chọn `-f`.
Đây là một tính năng an toàn để ngăn chặn việc vô tình xóa dữ liệu chưa được ghi vào snapshot và không thể phục hồi từ Git.

Một điều hữu ích khác bạn có thể muốn làm là giữ file trong cây làm việc của bạn nhưng xóa nó khỏi khu vực tổ chức của bạn.
Nói cách khác, bạn có thể muốn giữ file trên ổ cứng của mình nhưng không muốn Git theo dõi nó nữa.
Điều này đặc biệt hữu ích nếu bạn quên thêm một cái gì đó vào file `.gitignore` của mình và vô tình tổ chức nó, như một file log lớn hoặc một loạt các file đã biên dịch `.a`.
Để làm điều này, hãy sử dụng tùy chọn `--cached`:

[source,console]
----
$ git rm --cached README
----

Bạn có thể truyền các file, thư mục, và các mẫu glob file cho lệnh `git rm`.
Điều đó có nghĩa là bạn có thể làm những việc như sau:

[source,console]
----
$ git rm log/\*.log
----

Lưu ý dấu gạch chéo ngược (`\`) ở phía trước `*`.
Điều này là cần thiết vì Git thực hiện việc mở rộng tên file của riêng nó ngoài việc mở rộng tên file của shell của bạn.
Lệnh này xóa tất cả các file có phần mở rộng `.log` trong thư mục `log/`.
Hoặc, bạn có thể làm một cái gì đó như thế này:

[source,console]
----
$ git rm \*~
----

Lệnh này xóa tất cả các file có tên kết thúc bằng `~`.

[[_git_mv]]
==== Di chuyển các File

(((files, moving)))
Không giống như nhiều VCS khác, Git không theo dõi chuyển động file một cách rõ ràng.
Nếu bạn đổi tên một file trong Git, không có siêu dữ liệu nào được lưu trữ trong Git cho biết bạn đã đổi tên file.
Tuy nhiên, Git khá thông minh trong việc tìm ra điều đó sau đó -- chúng ta sẽ xử lý việc phát hiện chuyển động file một chút sau.

Do đó, hơi khó hiểu khi Git có lệnh `mv`.
Nếu bạn muốn đổi tên một file trong Git, bạn có thể chạy một cái gì đó như:

[source,console]
----
$ git mv file_from file_to
----

và nó hoạt động tốt.
Thực tế, nếu bạn chạy một cái gì đó như thế này và xem trạng thái, bạn sẽ thấy rằng Git coi đó là một file đã được đổi tên:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

Tuy nhiên, điều này tương đương với việc chạy một cái gì đó như thế này:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git tự động tìm ra đó là một lần đổi tên, vì vậy không quan trọng bạn đổi tên một file theo cách đó hay bằng lệnh `mv`.
Sự khác biệt thực sự duy nhất là `git mv` là một lệnh thay vì ba -- đó là một hàm tiện lợi.
Quan trọng hơn, bạn có thể sử dụng bất kỳ công cụ nào bạn thích để đổi tên một file, và giải quyết `add`/`rm` sau, trước khi bạn commit.