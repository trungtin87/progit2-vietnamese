[[_rebasing]]
=== Rebasing

(((rebasing)))
Trong Git, có hai cách chính để tích hợp các thay đổi từ nhánh này sang nhánh khác: `merge` và `rebase`.
Trong phần này, bạn sẽ tìm hiểu rebase là gì, cách thực hiện, tại sao nó là một công cụ tuyệt vời và trong trường hợp nào bạn không nên sử dụng nó.

==== Rebase Cơ bản

Nếu bạn quay lại ví dụ trước đó từ <<_basic_merging>>, bạn có thể thấy rằng bạn đã phân kỳ công việc của mình và thực hiện các cam kết trên hai nhánh khác nhau.

.Lịch sử phân kỳ đơn giản
image::images/basic-rebase-1.png[Lịch sử phân kỳ đơn giản]

Cách dễ nhất để tích hợp các nhánh, như chúng tôi đã đề cập, là lệnh `merge`.
Nó thực hiện hợp nhất ba chiều giữa hai ảnh chụp nhanh mới nhất của nhánh (`C3` và `C4`) và tổ tiên chung mới nhất của cả hai (`C2`), tạo ra một ảnh chụp nhanh mới (và cam kết).

[[rebasing-merging-example]]
.Hợp nhất để tích hợp lịch sử công việc bị phân kỳ
image::images/basic-rebase-2.png[Hợp nhất để tích hợp lịch sử công việc bị phân kỳ]

Tuy nhiên, có một cách khác: bạn có thể lấy bản vá của thay đổi đã được giới thiệu trong `C4` và áp dụng lại nó trên `C3`.
Trong Git, điều này được gọi là _rebasing_.
Với lệnh `rebase`, bạn có thể lấy tất cả các thay đổi đã được cam kết trên một nhánh và phát lại chúng trên một nhánh khác.(((git commands, rebase)))

Trong ví dụ này, bạn sẽ kiểm xuất nhánh `experiment`, và sau đó rebase nó lên nhánh `master` như sau:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Thao tác này hoạt động bằng cách đi tới tổ tiên chung của hai nhánh (nhánh bạn đang ở và nhánh bạn đang rebase), lấy sự khác biệt (diff) được giới thiệu bởi mỗi cam kết của nhánh bạn đang ở, lưu các khác biệt đó vào các tệp tạm thời, đặt lại nhánh hiện tại về cùng một cam kết với nhánh bạn đang rebase, và cuối cùng áp dụng từng thay đổi lần lượt.

.Rebase thay đổi được giới thiệu trong `C4` lên `C3`
image::images/basic-rebase-3.png[Rebase thay đổi được giới thiệu trong `C4` lên `C3`]

Tại thời điểm này, bạn có thể quay lại nhánh `master` và thực hiện hợp nhất tua nhanh (fast-forward merge).

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Tua nhanh nhánh `master`
image::images/basic-rebase-4.png[Tua nhanh nhánh `master`]

Bây giờ, ảnh chụp nhanh được trỏ tới bởi `C4'` hoàn toàn giống với ảnh chụp nhanh được trỏ tới bởi `C5` trong <<rebasing-merging-example,ví dụ hợp nhất>>.
Không có sự khác biệt nào trong sản phẩm cuối cùng của quá trình tích hợp, nhưng rebasing tạo ra một lịch sử sạch hơn.
Nếu bạn kiểm tra nhật ký của một nhánh đã được rebase, nó trông giống như một lịch sử tuyến tính: có vẻ như tất cả công việc đã xảy ra theo chuỗi, ngay cả khi nó thực sự xảy ra song song.

Thông thường, bạn sẽ làm điều này để đảm bảo các cam kết của bạn áp dụng sạch sẽ trên một nhánh từ xa -- có lẽ trong một dự án mà bạn đang cố gắng đóng góp nhưng bạn không duy trì.
Trong trường hợp này, bạn sẽ làm công việc của mình trong một nhánh và sau đó rebase công việc của bạn lên `origin/master` khi bạn sẵn sàng gửi các bản vá của mình cho dự án chính.
Bằng cách đó, người bảo trì không phải thực hiện bất kỳ công việc tích hợp nào -- chỉ cần tua nhanh hoặc áp dụng sạch sẽ.

Lưu ý rằng ảnh chụp nhanh được trỏ tới bởi cam kết cuối cùng bạn nhận được, cho dù đó là cam kết cuối cùng của các cam kết được rebase hay cam kết hợp nhất cuối cùng sau khi hợp nhất, đều giống nhau -- chỉ có lịch sử là khác nhau.
Rebasing phát lại các thay đổi từ dòng công việc này sang dòng công việc khác theo thứ tự chúng được giới thiệu, trong khi hợp nhất lấy các điểm cuối và hợp nhất chúng lại với nhau.

==== Các Rebase Thú vị hơn

Bạn cũng có thể rebase của mình lên một cái gì đó khác ngoài nhánh mục tiêu rebase.
Lấy ví dụ lịch sử như <<rbdiag_e>>, chẳng hạn.
Bạn đã tạo một nhánh chủ đề (`server`) để thêm một số chức năng phía máy chủ vào dự án của mình và thực hiện một cam kết.
Sau đó, bạn phân nhánh đó để thực hiện thay đổi phía máy khách (`client`) và cam kết một vài lần.
Cuối cùng, bạn quay lại nhánh máy chủ của mình và thực hiện thêm một vài cam kết.

[[rbdiag_e]]
.Lịch sử với một nhánh chủ đề tách ra từ một nhánh chủ đề khác
image::images/interesting-rebase-1.png[Lịch sử với một nhánh chủ đề tách ra từ một nhánh chủ đề khác]

Giả sử bạn quyết định rằng bạn muốn hợp nhất các thay đổi phía máy khách của mình vào dòng chính để phát hành, nhưng bạn muốn giữ lại các thay đổi phía máy chủ cho đến khi nó được kiểm tra thêm.
Bạn có thể lấy các thay đổi trên `client` không có trên `server` (`C8` và `C9`) và phát lại chúng trên nhánh `master` của bạn bằng cách sử dụng tùy chọn `--onto` của `git rebase`:

[source,console]
----
$ git rebase --onto master server client
----

Về cơ bản, điều này nói, "`Kiểm xuất nhánh `client`, tìm ra các bản vá từ tổ tiên chung của nhánh `client` và `server`, và sau đó phát lại chúng trên `master`.`"
Nó hơi phức tạp, nhưng kết quả thật tuyệt vời.

.Rebasing một nhánh chủ đề tách ra từ một nhánh chủ đề khác
image::images/interesting-rebase-2.png[Rebasing một nhánh chủ đề tách ra từ một nhánh chủ đề khác]

Bây giờ bạn có thể tua nhanh nhánh `master` của mình (xem <<rbdiag_g>>):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rbdiag_g]]
.Tua nhanh nhánh `master` của bạn để bao gồm các thay đổi của nhánh client
image::images/interesting-rebase-3.png[Tua nhanh nhánh `master` của bạn để bao gồm các thay đổi của nhánh client]

Giả sử bạn quyết định kéo cả nhánh máy chủ của mình vào.
Bạn có thể rebase nhánh `server` lên nhánh `master` mà không cần phải kiểm xuất nó trước bằng cách chạy `git rebase <basebranch> <topicbranch>` -- lệnh này kiểm xuất nhánh chủ đề (trong trường hợp này là `server`) cho bạn và phát lại nó lên nhánh cơ sở (base branch) (`master`):

[source,console]
----
$ git rebase master server
----

Điều này phát lại công việc `server` của bạn lên trên công việc `master` của bạn, như được hiển thị trong <<rbdiag_h>>.

[[rbdiag_h]]
.Rebasing nhánh server của bạn lên trên nhánh master của bạn
image::images/interesting-rebase-4.png[Rebasing nhánh server của bạn lên trên nhánh master của bạn]

Sau đó, bạn có thể tua nhanh nhánh cơ sở (`master`):

[source,console]
----
$ git checkout master
$ git merge server
----

Bạn có thể xóa các nhánh `client` và `server` vì tất cả công việc đã được tích hợp và bạn không cần chúng nữa, để lại lịch sử của bạn cho toàn bộ quá trình này trông giống như <<rbdiag_i>>:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rbdiag_i]]
.Lịch sử cam kết cuối cùng
image::images/interesting-rebase-5.png[Lịch sử cam kết cuối cùng]

[[_rebase_peril]]
==== Sự Nguy hiểm của Rebasing

(((rebasing, perils of)))
Aah, nhưng niềm vui của rebasing không phải là không có nhược điểm của nó, có thể được tóm tắt trong một dòng duy nhất:

*Đừng rebase các cam kết tồn tại bên ngoài kho lưu trữ của bạn và những người khác có thể đã dựa trên công việc đó.*

Nếu bạn tuân theo hướng dẫn đó, bạn sẽ ổn.
Nếu bạn không, mọi người sẽ ghét bạn, và bạn sẽ bị bạn bè và gia đình khinh miệt.

Khi bạn rebase nội dung, bạn đang từ bỏ các cam kết hiện có và tạo ra các cam kết mới tương tự nhưng khác biệt.
Nếu bạn đẩy các cam kết đi đâu đó và những người khác kéo chúng xuống và dựa vào công việc trên đó, và sau đó bạn viết lại các cam kết đó bằng `git rebase` và đẩy chúng lên lại, các cộng tác viên của bạn sẽ phải hợp nhất lại công việc của họ và mọi thứ sẽ trở nên lộn xộn khi bạn cố gắng kéo công việc của họ trở lại vào của bạn.

Hãy xem xét một ví dụ về cách việc rebase công việc mà bạn đã công khai có thể gây ra vấn đề.
Giả sử bạn sao chép từ một máy chủ trung tâm và sau đó thực hiện một số công việc trên đó.
Lịch sử cam kết của bạn trông giống như thế này:

.Sao chép một kho lưu trữ và thực hiện một số công việc trên đó
image::images/perils-of-rebasing-1.png["Sao chép một kho lưu trữ và thực hiện một số công việc trên đó"]

Bây giờ, ai đó khác thực hiện nhiều công việc hơn bao gồm một hợp nhất, và đẩy công việc đó lên máy chủ trung tâm.
Bạn lấy nó và hợp nhất nhánh từ xa mới vào công việc của mình, làm cho lịch sử của bạn trông giống như thế này:

.Lấy thêm cam kết và hợp nhất chúng vào công việc của bạn
image::images/perils-of-rebasing-2.png["Lấy thêm cam kết và hợp nhất chúng vào công việc của bạn"]

Tiếp theo, người đã đẩy công việc đã hợp nhất quyết định quay lại và rebase công việc của họ thay thế; họ thực hiện `git push --force` để ghi đè lên lịch sử trên máy chủ.
Sau đó, bạn lấy từ máy chủ đó, mang xuống các cam kết mới.

[[_pre_merge_rebase_work]]
.Ai đó đẩy các cam kết đã rebase, từ bỏ các cam kết bạn đã dựa trên công việc của mình
image::images/perils-of-rebasing-3.png["Ai đó đẩy các cam kết đã rebase, từ bỏ các cam kết bạn đã dựa trên công việc của mình"]

Bây giờ cả hai bạn đang ở trong tình thế khó khăn.
Nếu bạn thực hiện `git pull`, bạn sẽ tạo ra một cam kết hợp nhất bao gồm cả hai dòng lịch sử, và kho lưu trữ của bạn sẽ trông giống như thế này:

[[_merge_rebase_work]]
.Bạn hợp nhất trong cùng một công việc một lần nữa vào một cam kết hợp nhất mới
image::images/perils-of-rebasing-4.png[Bạn hợp nhất trong cùng một công việc một lần nữa vào một cam kết hợp nhất mới]

Nếu bạn chạy `git log` khi lịch sử của bạn trông giống như thế này, bạn sẽ thấy hai cam kết có cùng tác giả, ngày tháng và thông điệp, điều này sẽ gây nhầm lẫn.
Hơn nữa, nếu bạn đẩy lịch sử này trở lại máy chủ, bạn sẽ giới thiệu lại tất cả các cam kết đã được rebase đó vào máy chủ trung tâm, điều này có thể gây nhầm lẫn thêm cho mọi người.
Khá an toàn khi cho rằng nhà phát triển khác không muốn `C4` và `C6` có trong lịch sử; đó là lý do tại sao họ rebase ngay từ đầu.

[[_rebase_rebase]]
==== Rebase Khi Bạn Rebase

Nếu bạn *thấy* mình trong tình huống như thế này, Git có thêm một số phép thuật có thể giúp bạn.
Nếu ai đó trong nhóm của bạn buộc đẩy các thay đổi ghi đè lên công việc mà bạn đã dựa trên đó, thử thách của bạn là tìm ra cái gì là của bạn và cái gì họ đã viết lại.

Hóa ra là ngoài tổng kiểm tra SHA-1 cam kết, Git cũng tính toán một tổng kiểm tra chỉ dựa trên bản vá được giới thiệu với cam kết.
Đây được gọi là "patch-id".

Nếu bạn kéo xuống công việc đã được viết lại và rebase nó lên trên các cam kết mới từ đối tác của bạn, Git thường có thể tìm ra thành công những gì là duy nhất của bạn và áp dụng lại chúng lên trên nhánh mới.

Ví dụ, trong kịch bản trước, nếu thay vì thực hiện hợp nhất khi chúng ta ở <<_pre_merge_rebase_work>>, chúng ta chạy `git rebase teamone/master`, Git sẽ:

* Xác định công việc nào là duy nhất cho nhánh của chúng ta (`C2`, `C3`, `C4`, `C6`, `C7`)
* Xác định cái nào không phải là cam kết hợp nhất (`C2`, `C3`, `C4`)
* Xác định cái nào chưa được viết lại vào nhánh mục tiêu (chỉ `C2` và `C3`, vì `C4` giống với `C4'`)
* Áp dụng các cam kết đó vào đầu `teamone/master`

Vì vậy, thay vì kết quả chúng ta thấy trong <<_merge_rebase_work>>, chúng ta sẽ nhận được một cái gì đó giống như <<_rebase_rebase_work>>.

[[_rebase_rebase_work]]
.Rebase lên trên công việc bị buộc đẩy (force-pushed)
image::images/perils-of-rebasing-5.png[Rebase lên trên công việc bị buộc đẩy (force-pushed)]

Điều này chỉ hoạt động nếu `C4` và `C4'` mà đối tác của bạn đã thực hiện gần như giống hệt nhau về bản vá.
Nếu không, rebase sẽ không thể biết rằng nó là một bản sao và sẽ thêm một cam kết giống `C4` khác (có thể sẽ thất bại khi áp dụng sạch sẽ, vì các thay đổi ít nhất đã có ở đó).

Bạn cũng có thể đơn giản hóa điều này bằng cách chạy `git pull --rebase` thay vì `git pull` bình thường.
Hoặc bạn có thể làm điều đó thủ công với `git fetch` theo sau là `git rebase teamone/master` trong trường hợp này.

Nếu bạn đang sử dụng `git pull` và muốn đặt `--rebase` làm mặc định, bạn có thể đặt giá trị cấu hình `pull.rebase` bằng một cái gì đó như `git config --global pull.rebase true`.

Nếu bạn chỉ bao giờ rebase các cam kết chưa bao giờ rời khỏi máy tính của riêng bạn, bạn sẽ ổn.
Nếu bạn rebase các cam kết đã được đẩy, nhưng không ai khác đã dựa trên các cam kết đó, bạn cũng sẽ ổn.
Nếu bạn rebase các cam kết đã được đẩy công khai, và mọi người có thể đã dựa trên công việc của họ, thì bạn có thể gặp rắc rối bực bội, và sự khinh miệt của đồng đội.

Nếu bạn hoặc đối tác của bạn thấy cần thiết tại một thời điểm nào đó, hãy đảm bảo mọi người chạy `git pull --rebase` để cố gắng làm cho nỗi đau bớt đi một chút.

==== Rebase so với Merge

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Bây giờ bạn đã thấy rebasing và merging hoạt động, bạn có thể tự hỏi cái nào tốt hơn.
Trước khi chúng ta có thể trả lời điều này, hãy lùi lại một chút và nói về lịch sử có ý nghĩa gì.

Một quan điểm cho rằng lịch sử kho lưu trữ của bạn là *ghi chép về những gì đã thực sự xảy ra.*
Đó là một tài liệu lịch sử, có giá trị theo đúng nghĩa của nó, và không nên bị giả mạo.
Theo quan điểm này, thay đổi lịch sử cam kết là báng bổ; bạn đang _nói dối_ về những gì đã thực sự xảy ra.
Vì vậy, nếu có một loạt các cam kết hợp nhất lộn xộn?
Đó là những gì đã xảy ra, và kho lưu trữ nên bảo tồn điều đó cho hậu thế.

Quan điểm ngược lại là lịch sử cam kết là *câu chuyện về cách dự án của bạn được tạo ra.*
Bạn sẽ không xuất bản bản nháp đầu tiên của một cuốn sách, vì vậy tại sao lại hiển thị công việc lộn xộn của bạn?
Khi bạn đang làm việc trên một dự án, bạn có thể cần một bản ghi về tất cả các bước sai lầm và con đường cụt của mình, nhưng khi đến lúc hiển thị công việc của bạn cho thế giới, bạn có thể muốn kể một câu chuyện mạch lạc hơn về cách đi từ A đến B.
Những người trong phe này sử dụng các công cụ như `rebase` và `filter-branch` để viết lại các cam kết của họ trước khi chúng được hợp nhất vào nhánh chính.
Họ sử dụng các công cụ như `rebase` và `filter-branch`, để kể câu chuyện theo cách tốt nhất cho những người đọc trong tương lai.

Bây giờ, với câu hỏi liệu sáp nhập hay rebase tốt hơn: hy vọng bạn sẽ thấy rằng nó không đơn giản như vậy.
Git là một công cụ mạnh mẽ và cho phép bạn làm nhiều việc với lịch sử của mình, nhưng mọi nhóm và mọi dự án đều khác nhau.
Bây giờ bạn đã biết cả hai điều này hoạt động như thế nào, tùy thuộc vào bạn để quyết định cái nào là tốt nhất cho tình huống cụ thể của bạn.

Bạn có thể có được điều tốt nhất của cả hai thế giới: rebase các thay đổi cục bộ trước khi đẩy để làm sạch công việc của bạn, nhưng không bao giờ rebase bất cứ thứ gì bạn đã đẩy đi đâu đó.
