[[_git_branches_overview]]
=== Các Nhánh trong Git

Để thực sự hiểu cách Git thực hiện phân nhánh, chúng ta cần lùi lại một bước và kiểm tra cách Git lưu trữ dữ liệu của nó.

Như bạn có thể nhớ lại từ <<ch01-introduction#ch01-introduction>>, Git không lưu trữ dữ liệu dưới dạng một loạt các thay đổi hoặc khác biệt, mà thay vào đó là một loạt các ảnh chụp nhanh (snapshots).

Khi bạn thực hiện một cam kết, Git lưu trữ một đối tượng cam kết chứa một con trỏ đến ảnh chụp nhanh của nội dung bạn đã tổ chức.
Đối tượng này cũng chứa tên và email của tác giả, thông điệp bạn đã nhập và các con trỏ đến cam kết hoặc các cam kết trực tiếp trước cam kết này (cha của nó): không có cha cho cam kết ban đầu, một cha cho một cam kết bình thường và nhiều cha cho một cam kết là kết quả của việc hợp nhất hai hoặc nhiều nhánh.

Để hình dung điều này, hãy giả sử rằng bạn có một thư mục chứa ba tệp và bạn tổ chức tất cả chúng và cam kết.
Việc tổ chức các tệp sẽ tính toán tổng kiểm tra cho mỗi tệp (băm SHA-1 mà chúng ta đã đề cập trong <<ch01-introduction#ch01-introduction>>), lưu trữ phiên bản tệp đó trong kho lưu trữ Git (Git gọi chúng là _blobs_) và thêm tổng kiểm tra đó vào khu vực tổ chức:

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'Initial commit'
----

Khi bạn tạo cam kết bằng cách chạy `git commit`, Git tính tổng kiểm tra từng thư mục con (trong trường hợp này, chỉ thư mục dự án gốc) và lưu trữ chúng dưới dạng một đối tượng cây trong kho lưu trữ Git.
Sau đó, Git tạo một đối tượng cam kết có siêu dữ liệu và một con trỏ đến cây dự án gốc để nó có thể tạo lại ảnh chụp nhanh đó khi cần.

Kho lưu trữ Git của bạn hiện chứa năm đối tượng: ba _blobs_ (mỗi tệp một blob), một _tree_ liệt kê nội dung của thư mục và chỉ định tên tệp nào được lưu trữ dưới dạng blob nào, và một _commit_ với con trỏ đến cây gốc đó và tất cả siêu dữ liệu cam kết.

.Một cam kết và cây của nó
image::images/commit-and-tree.png[Một cam kết và cây của nó]

Nếu bạn thực hiện một số thay đổi và cam kết lại, cam kết tiếp theo sẽ lưu trữ một con trỏ đến cam kết đến ngay trước nó.

.Các cam kết và cha của chúng
image::images/commits-and-parents.png[Các cam kết và cha của chúng]

Một nhánh trong Git chỉ đơn giản là một con trỏ di động nhẹ đến một trong những cam kết này.
Tên nhánh mặc định trong Git là `master`.
Khi bạn bắt đầu thực hiện các cam kết, bạn được cung cấp một nhánh `master` trỏ đến cam kết cuối cùng bạn đã thực hiện.
Mỗi lần bạn cam kết, con trỏ nhánh `master` sẽ tự động di chuyển về phía trước.

[NOTE]
====
Nhánh "`master`" trong Git không phải là một nhánh đặc biệt.(((master)))
Nó hoàn toàn giống như bất kỳ nhánh nào khác.
Lý do duy nhất khiến gần như mọi kho lưu trữ đều có một nhánh là lệnh `git init` tạo ra nó theo mặc định và hầu hết mọi người không bận tâm thay đổi nó.
====

.Một nhánh và lịch sử cam kết của nó
image::images/branch-and-history.png[Một nhánh và lịch sử cam kết của nó]

==== Tạo một Nhánh Mới

(((branches, creating)))
Điều gì xảy ra khi bạn tạo một nhánh mới?
Làm như vậy sẽ tạo ra một con trỏ mới để bạn di chuyển xung quanh.
Giả sử bạn muốn tạo một nhánh mới có tên là `testing`.
Bạn làm điều này với lệnh `git branch`:(((git commands, branch)))

[source,console]
----
$ git branch testing
----

Điều này tạo ra một con trỏ mới đến cùng một cam kết mà bạn đang ở hiện tại.

.Hai nhánh trỏ đến cùng một chuỗi
image::images/two-branches.png[Hai nhánh trỏ đến cùng một chuỗi]

Làm thế nào để Git biết bạn đang ở nhánh nào?
Nó giữ một con trỏ đặc biệt gọi là `HEAD`.
Lưu ý rằng điều này khác rất nhiều so với khái niệm `HEAD` trong các VCS khác mà bạn có thể đã quen thuộc, chẳng hạn như Subversion hoặc CVS.
Trong Git, đây là một con trỏ đến nhánh cục bộ mà bạn đang ở hiện tại.
Trong trường hợp này, bạn vẫn đang ở trên `master`.
Lệnh `git branch` chỉ _tạo_ một nhánh mới -- nó không chuyển sang nhánh đó.

.HEAD trỏ đến một nhánh
image::images/head-to-master.png[HEAD trỏ đến một nhánh]

Bạn có thể dễ dàng thấy điều này bằng cách chạy một lệnh `git log` đơn giản hiển thị cho bạn nơi các con trỏ nhánh đang trỏ đến.
Tùy chọn này được gọi là `--decorate`.

[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) Add feature #32 - ability to add new formats to the central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions
98ca9 Initial commit of my project
----

Bạn có thể thấy các nhánh `master` và `testing` nằm ngay cạnh cam kết `f30ab`.

==== Chuyển Nhánh

(((branches, switching)))
Để chuyển sang một nhánh hiện có, bạn chạy lệnh `git checkout`.(((git commands, checkout)))
Hãy chuyển sang nhánh `testing` mới:

[source,console]
----
$ git checkout testing
----

Điều này di chuyển `HEAD` để trỏ đến nhánh `testing`.

.HEAD trỏ đến nhánh hiện tại
image::images/head-to-testing.png[HEAD trỏ đến nhánh hiện tại]

Ý nghĩa của việc đó là gì?
Vâng, hãy thực hiện một cam kết khác:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made a change'
----

.Nhánh HEAD di chuyển về phía trước khi một cam kết được thực hiện
image::images/advance-testing.png[Nhánh HEAD di chuyển về phía trước khi một cam kết được thực hiện]

Điều này thật thú vị, bởi vì nhánh `testing` của bạn đã di chuyển về phía trước, nhưng nhánh `master` của bạn vẫn trỏ đến cam kết bạn đã ở khi bạn chạy `git checkout` để chuyển đổi các nhánh.
Hãy chuyển trở lại nhánh `master`:

[source,console]
----
$ git checkout master
----

[NOTE]
.`git log` không hiển thị _tất cả_ các nhánh _mọi_ lúc
====
Nếu bạn chạy `git log` ngay bây giờ, bạn có thể tự hỏi nhánh "testing" bạn vừa tạo đã đi đâu, vì nó sẽ không xuất hiện trong đầu ra.

Nhánh đó không biến mất; Git chỉ không biết rằng bạn quan tâm đến nhánh đó.
Những gì `git log` hiển thị cho bạn, theo mặc định, là lịch sử cam kết cho nhánh bạn đã kiểm xuất (trong trường hợp này là `master`).
Để xem lịch sử cam kết cho nhánh bạn muốn xem, bạn phải nói rõ ràng `git log testing`.
Để hiển thị lịch sử cho tất cả các nhánh, bạn có thể thêm `--all` vào lệnh `git log` của mình.
====

Lệnh đó đã làm hai việc.
Nó di chuyển con trỏ HEAD trở lại trỏ vào nhánh `master`, và nó hoàn nguyên các tệp trong thư mục làm việc của bạn trở lại ảnh chụp nhanh mà `master` trỏ đến.
Điều này cũng có nghĩa là những thay đổi bạn thực hiện từ thời điểm này trở đi sẽ tách ra khỏi phiên bản cũ hơn của dự án.
Về cơ bản, nó tua lại công việc bạn đã làm trong nhánh `testing` của mình để bạn có thể đi theo một hướng khác.

[NOTE]
====
Điều quan trọng cần lưu ý là khi bạn chuyển đổi các nhánh trong Git, các tệp trong thư mục làm việc của bạn sẽ thay đổi.
Nếu bạn chuyển sang một nhánh cũ hơn, thư mục làm việc của bạn sẽ được hoàn nguyên để trông giống như lần cuối cùng bạn cam kết trên nhánh đó.
Nếu Git không thể làm điều đó một cách sạch sẽ, nó sẽ không cho phép bạn chuyển đổi chút nào.
====

Hãy thực hiện một vài thay đổi và cam kết lại:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'Make other changes'
----

Bây giờ lịch sử dự án của bạn đã phân kỳ (xem <<div_history>>).
Bạn đã tạo và chuyển sang một nhánh, thực hiện một số công việc trên đó, và sau đó chuyển trở lại nhánh chính của mình và thực hiện công việc khác.
Cả hai thay đổi đó đều được tách biệt trong các nhánh riêng biệt: bạn có thể chuyển đổi qua lại giữa hai nhánh và hợp nhất chúng lại với nhau khi bạn sẵn sàng.
Và bạn đã làm tất cả những điều đó với các lệnh `branch`, `checkout` và `commit` đơn giản.

[[div_history]]
.Lịch sử phân kỳ
image::images/advance-master.png[Lịch sử phân kỳ]

Bạn cũng có thể thấy điều này dễ dàng với lệnh `git log`.
Nếu bạn chạy `git log --oneline --decorate --graph --all`, nó sẽ in ra lịch sử cam kết của bạn, hiển thị vị trí các con trỏ nhánh của bạn và lịch sử đã phân kỳ như thế nào.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD -> master) Make other changes
| * 87ab2 (testing) made a change
|/
* f30ab Add feature #32 - ability to add new formats to the central interface
* 34ac2 Fix bug #1328 - stack overflow under certain conditions
* 98ca9 Initial commit of my project
----

Bởi vì một nhánh trong Git thực sự là một tệp đơn giản chứa tổng kiểm tra SHA-1 gồm 40 ký tự của cam kết mà nó trỏ đến, các nhánh rất rẻ để tạo và hủy.
Tạo một nhánh mới nhanh chóng và đơn giản như viết 41 byte vào một tệp (40 ký tự và một dòng mới).

Điều này hoàn toàn trái ngược với cách hầu hết các công cụ VCS cũ hơn phân nhánh, liên quan đến việc sao chép tất cả các tệp của dự án vào thư mục thứ hai.
Điều này có thể mất vài giây hoặc thậm chí vài phút, tùy thuộc vào kích thước của dự án, trong khi trong Git, quá trình này luôn diễn ra ngay lập tức.
Ngoài ra, vì chúng ta đang ghi lại các cha mẹ khi chúng ta cam kết, việc tìm cơ sở hợp nhất tốt nhất để hợp nhất được thực hiện tự động cho chúng ta và nói chung là rất dễ thực hiện.
Các tính năng này giúp khuyến khích các nhà phát triển tạo và sử dụng các nhánh thường xuyên.

Hãy xem tại sao bạn nên làm như vậy.

[NOTE]
.git switch
====
Từ phiên bản Git 2.23 trở đi, bạn có thể sử dụng `git switch` thay vì `git checkout` để:

- Chuyển sang một nhánh hiện có: `git switch testing-branch`.
- Tạo một nhánh mới và chuyển sang nó: `git switch -c new-branch`.
  Cờ `-c` là viết tắt của create (tạo), bạn cũng có thể sử dụng cờ đầy đủ: `--create`.
- Quay lại nhánh đã kiểm xuất trước đó của bạn: `git switch -`.
====
