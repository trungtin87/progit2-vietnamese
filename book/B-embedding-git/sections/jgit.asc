=== JGit

(((jgit)))(((Java)))
Nếu bạn muốn sử dụng Git từ trong một chương trình Java, có một thư viện Git đầy đủ tính năng gọi là JGit.
JGit là một triển khai tương đối đầy đủ tính năng của Git được viết bản địa bằng Java, và được sử dụng rộng rãi trong cộng đồng Java.
Dự án JGit nằm dưới ô Eclipse, và trang chủ của nó có thể được tìm thấy tại https://www.eclipse.org/jgit/[^].

==== Thiết lập

Có một số cách để kết nối dự án của bạn với JGit và bắt đầu viết mã chống lại nó.
Có lẽ cách dễ nhất là sử dụng Maven – tích hợp được hoàn thành bằng cách thêm đoạn mã sau vào thẻ `<dependencies>` trong tập tin `pom.xml` của bạn:

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jgit</groupId>
    <artifactId>org.eclipse.jgit</artifactId>
    <version>3.5.0.201409260305-r</version>
</dependency>
----

`version` rất có thể đã tiến bộ vào thời điểm bạn đọc điều này; kiểm tra https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit[^] để biết thông tin kho chứa cập nhật.
Khi bước này hoàn tất, Maven sẽ tự động lấy và sử dụng các thư viện JGit mà bạn cần.

Nếu bạn muốn tự quản lý các phụ thuộc nhị phân, các tập tin nhị phân JGit được xây dựng sẵn có sẵn từ https://www.eclipse.org/jgit/download[^].
Bạn có thể xây dựng chúng vào dự án của mình bằng cách chạy một lệnh như thế này:

[source,console]
----
javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
----

==== Plumbing

JGit có hai cấp độ API cơ bản: plumbing và porcelain.
Thuật ngữ cho những thứ này đến từ chính Git, và JGit được chia thành khoảng cùng loại khu vực: các API porcelain là một giao diện thân thiện cho các hành động cấp người dùng phổ biến (các loại thứ mà một người dùng bình thường sẽ sử dụng công cụ dòng lệnh Git cho), trong khi các API plumbing dành cho tương tác với các đối tượng kho chứa cấp thấp trực tiếp.

Điểm khởi đầu cho hầu hết các phiên JGit là lớp `Repository`, và điều đầu tiên bạn sẽ muốn làm là tạo một instance của nó.
Đối với một kho chứa dựa trên hệ thống tập tin (có, JGit cho phép các mô hình lưu trữ khác), điều này được thực hiện bằng cách sử dụng `FileRepositoryBuilder`:

[source,java]
----
// Create a new repository
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();
----

Builder có một API trôi chảy để cung cấp tất cả những thứ nó cần để tìm một kho chứa Git, cho dù chương trình của bạn có biết chính xác nó nằm ở đâu hay không.
Nó có thể sử dụng các biến môi trường (`.readEnvironment()`), bắt đầu từ một nơi trong thư mục làm việc và tìm kiếm (`.setWorkTree(…).findGitDir()`), hoặc chỉ mở một thư mục `.git` đã biết như trên.

Khi bạn có một instance `Repository`, bạn có thể làm tất cả các loại thứ với nó.
Đây là một mẫu nhanh:

[source,java]
----
// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
----

Có khá nhiều thứ đang diễn ra ở đây, vì vậy hãy đi qua từng phần một.

Dòng đầu tiên lấy một con trỏ đến tham chiếu `master`.
JGit tự động lấy tham chiếu `master` _thực tế_, sống tại `refs/heads/master`, và trả về một đối tượng cho phép bạn lấy thông tin về tham chiếu.
Bạn có thể lấy tên (`.getName()`), và hoặc đối tượng đích của một tham chiếu trực tiếp (`.getObjectId()`) hoặc tham chiếu được trỏ đến bởi một ref tượng trưng (`.getTarget()`).
Các đối tượng Ref cũng được sử dụng để đại diện cho các ref và đối tượng tag, vì vậy bạn có thể hỏi nếu tag là "`peeled`", có nghĩa là nó trỏ đến mục tiêu cuối cùng của một chuỗi (có khả năng dài) các đối tượng tag.

Dòng thứ hai lấy mục tiêu của tham chiếu `master`, được trả về dưới dạng một instance ObjectId.
ObjectId đại diện cho hash SHA-1 của một đối tượng, có thể hoặc có thể không tồn tại trong cơ sở dữ liệu đối tượng của Git.
Dòng thứ ba tương tự, nhưng cho thấy JGit xử lý cú pháp rev-parse như thế nào (để biết thêm về điều này, xem <<ch07-git-tools#_branch_references>>); bạn có thể truyền bất kỳ bộ chỉ định đối tượng nào mà Git hiểu, và JGit sẽ trả về hoặc một ObjectId hợp lệ cho đối tượng đó, hoặc `null`.

Hai dòng tiếp theo cho thấy cách tải nội dung thô của một đối tượng.
Trong ví dụ này, chúng ta gọi `ObjectLoader.copyTo()` để truyền nội dung của đối tượng trực tiếp đến stdout, nhưng ObjectLoader cũng có các phương thức để đọc loại và kích thước của một đối tượng, cũng như trả về nó dưới dạng một mảng byte.
Đối với các đối tượng lớn (trong đó `.isLarge()` trả về `true`), bạn có thể gọi `.openStream()` để lấy một đối tượng giống InputStream có thể đọc dữ liệu đối tượng thô mà không kéo tất cả vào bộ nhớ cùng một lúc.

Vài dòng tiếp theo cho thấy những gì cần để tạo một nhánh mới.
Chúng ta tạo một instance RefUpdate, cấu hình một số tham số, và gọi `.update()` để kích hoạt thay đổi.
Ngay sau đó là mã để xóa cùng nhánh đó.
Lưu ý rằng `.setForceUpdate(true)` là bắt buộc để điều này hoạt động; nếu không cuộc gọi `.delete()` sẽ trả về `REJECTED`, và không có gì sẽ xảy ra.

Ví dụ cuối cùng cho thấy cách lấy giá trị `user.name` từ các tập tin cấu hình Git.
Instance Config này sử dụng kho chứa chúng ta đã mở trước đó cho cấu hình cục bộ, nhưng sẽ tự động phát hiện các tập tin cấu hình toàn cục và hệ thống và đọc các giá trị từ chúng.

Đây chỉ là một mẫu nhỏ của API plumbing đầy đủ; có nhiều phương thức và lớp hơn nữa có sẵn.
Cũng không được hiển thị ở đây là cách JGit xử lý lỗi, đó là thông qua việc sử dụng các ngoại lệ.
Các API JGit đôi khi ném các ngoại lệ Java tiêu chuẩn (chẳng hạn như `IOException`), nhưng có một loạt các loại ngoại lệ cụ thể của JGit cũng được cung cấp (chẳng hạn như `NoRemoteRepositoryException`, `CorruptObjectException`, và `NoMergeBaseException`).

==== Porcelain

Các API plumbing khá hoàn chỉnh, nhưng có thể cồng kềnh để xâu chuỗi chúng lại với nhau để đạt được các mục tiêu chung, như thêm một tập tin vào index, hoặc tạo một commit mới.
JGit cung cấp một bộ API cấp cao hơn để giúp đỡ với điều này, và điểm vào cho các API này là lớp `Git`:

[source,java]
----
Repository repo;
// construct repo...
Git git = new Git(repo);
----

Lớp Git có một bộ các phương thức kiểu _builder_ cấp cao tốt đẹp có thể được sử dụng để xây dựng một số hành vi khá phức tạp.
Hãy xem một ví dụ -- làm một cái gì đó như `git ls-remote`:

[source,java]
----
CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection<Ref> remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -> " + ref.getObjectId().name());
}
----

Đây là một mẫu phổ biến với lớp Git; các phương thức trả về một đối tượng lệnh cho phép bạn xâu chuỗi các cuộc gọi phương thức để đặt các tham số, được thực thi khi bạn gọi `.call()`.
Trong trường hợp này, chúng ta đang yêu cầu remote `origin` cho các tag, nhưng không phải head.
Cũng lưu ý việc sử dụng một đối tượng `CredentialsProvider` để xác thực.

Nhiều lệnh khác có sẵn thông qua lớp Git, bao gồm nhưng không giới hạn ở `add`, `blame`, `commit`, `clean`, `push`, `rebase`, `revert`, và `reset`.

==== Đọc thêm

Đây chỉ là một mẫu nhỏ của khả năng đầy đủ của JGit.
Nếu bạn quan tâm và muốn tìm hiểu thêm, đây là nơi để tìm kiếm thông tin và cảm hứng:

* Tài liệu API JGit chính thức có thể được tìm thấy tại https://www.eclipse.org/jgit/documentation[^].
  Đây là Javadoc tiêu chuẩn, vì vậy JVM IDE yêu thích của bạn sẽ có thể cài đặt chúng cục bộ.
* JGit Cookbook tại https://github.com/centic9/jgit-cookbook[^] có nhiều ví dụ về cách thực hiện các nhiệm vụ cụ thể với JGit.
