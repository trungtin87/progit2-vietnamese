=== Libgit2

(((libgit2)))(((C)))
Một tùy chọn khác có sẵn cho bạn là sử dụng Libgit2.
Libgit2 là một triển khai Git không phụ thuộc, tập trung vào việc có một API tốt đẹp để sử dụng trong các chương trình khác.
Bạn có thể tìm thấy nó tại https://libgit2.org[^].

Đầu tiên, hãy xem API C trông như thế nào.
Đây là một tour nhanh:

[source,c]
----
// Open a repository
git_repository *repo;
int error = git_repository_open(&repo, "/path/to/repository");

// Dereference HEAD to a commit
git_object *head_commit;
error = git_revparse_single(&head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;

// Print some of the commit's properties
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s <%s>\\n", author->name, author->email);
const git_oid *tree_id = git_commit_tree_id(commit);

// Cleanup
git_commit_free(commit);
git_repository_free(repo);
----

Vài dòng đầu tiên mở một kho chứa Git.
Loại `git_repository` đại diện cho một handle đến một kho chứa với một bộ nhớ cache trong bộ nhớ.
Đây là phương pháp đơn giản nhất, khi bạn biết đường dẫn chính xác đến thư mục làm việc hoặc thư mục `.git` của kho chứa.
Cũng có `git_repository_open_ext` bao gồm các tùy chọn để tìm kiếm, `git_clone` và các hàm bạn để tạo một bản sao cục bộ của một kho chứa từ xa, và `git_repository_init` để tạo một kho chứa hoàn toàn mới.

Khối mã thứ hai sử dụng cú pháp rev-parse (xem <<ch07-git-tools#_branch_references>> để biết thêm về điều này) để lấy commit mà HEAD cuối cùng trỏ đến.
Loại được trả về là một con trỏ `git_object`, đại diện cho một cái gì đó tồn tại trong cơ sở dữ liệu đối tượng Git cho một kho chứa.
`git_object` thực sự là một loại "`cha`" cho một số loại đối tượng khác nhau; bố cục bộ nhớ cho mỗi loại "`con`" giống như cho `git_object`, vì vậy bạn có thể ép kiểu an toàn sang loại đúng.
Trong trường hợp này, `git_object_type(commit)` sẽ trả về `GIT_OBJ_COMMIT`, vì vậy an toàn để ép kiểu sang một con trỏ `git_commit`.

Khối tiếp theo cho thấy cách truy cập các thuộc tính của commit.
Dòng cuối cùng ở đây sử dụng một loại `git_oid`; đây là biểu diễn của Libgit2 cho một hash SHA-1.

Từ mẫu này, một vài mẫu đã bắt đầu xuất hiện:

* Nếu bạn khai báo một con trỏ và truyền một tham chiếu đến nó vào một cuộc gọi Libgit2, cuộc gọi đó có thể sẽ trả về một mã lỗi số nguyên.
  Giá trị `0` chỉ ra thành công; bất cứ thứ gì nhỏ hơn là một lỗi.
* Nếu Libgit2 điền một con trỏ cho bạn, bạn chịu trách nhiệm giải phóng nó.
* Nếu Libgit2 trả về một con trỏ `const` từ một cuộc gọi, bạn không phải giải phóng nó, nhưng nó sẽ trở nên không hợp lệ khi đối tượng mà nó thuộc về được giải phóng.
* Viết C hơi đau đớn.

(((Ruby)))
Cái cuối cùng đó có nghĩa là không có khả năng bạn sẽ viết C khi sử dụng Libgit2.
May mắn thay, có một số binding ngôn ngữ cụ thể có sẵn giúp khá dễ dàng làm việc với các kho chứa Git từ ngôn ngữ và môi trường cụ thể của bạn.
Hãy xem ví dụ trên được viết bằng cách sử dụng các binding Ruby cho Libgit2, được đặt tên là Rugged, và có thể được tìm thấy tại https://github.com/libgit2/rugged[^].

[source,ruby]
----
repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} <#{commit.author[:email]}>"
tree = commit.tree
----

Như bạn có thể thấy, mã ít lộn xộn hơn nhiều.
Thứ nhất, Rugged sử dụng các ngoại lệ; nó có thể ném những thứ như `ConfigError` hoặc `ObjectError` để báo hiệu các điều kiện lỗi.
Thứ hai, không có giải phóng tài nguyên rõ ràng, vì Ruby được thu gom rác.
Hãy xem một ví dụ phức tạp hơn một chút: tạo một commit từ đầu

[source,ruby]
----
blob_id = repo.write("Blob contents", :blob) # <1>

index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path => 'newfile.txt', :oid => blob_id) # <2>

sig = {
    :email => "bob@example.com",
    :name => "Bob User",
    :time => Time.now,
}

commit_id = Rugged::Commit.create(repo,
    :tree => index.write_tree(repo), # <3>
    :author => sig,
    :committer => sig, # <4>
    :message => "Add newfile.txt", # <5>
    :parents => repo.empty? ? [] : [ repo.head.target ].compact, # <6>
    :update_ref => 'HEAD', # <7>
)
commit = repo.lookup(commit_id) # <8>
----

<1> Tạo một blob mới, chứa nội dung của một tập tin mới.
<2> Điền index với tree của commit head, và thêm tập tin mới tại đường dẫn `newfile.txt`.
<3> Điều này tạo một tree mới trong ODB, và sử dụng nó cho commit mới.
<4> Chúng ta sử dụng cùng một chữ ký cho cả trường author và committer.
<5> Thông điệp commit.
<6> Khi tạo một commit, bạn phải chỉ định các cha mẹ của commit mới.
    Điều này sử dụng đỉnh của HEAD cho cha mẹ duy nhất.
<7> Rugged (và Libgit2) có thể tùy chọn cập nhật một tham chiếu khi tạo một commit.
<8> Giá trị trả về là hash SHA-1 của một đối tượng commit mới, sau đó bạn có thể sử dụng để lấy một đối tượng `Commit`.

Mã Ruby tốt đẹp và sạch sẽ, nhưng vì Libgit2 đang làm công việc nặng nhọc, mã này cũng sẽ chạy khá nhanh.
Nếu bạn không phải là một rubyist, chúng tôi đề cập đến một số binding khác trong <<_libgit2_bindings>>.

==== Chức năng Nâng cao

Libgit2 có một vài khả năng nằm ngoài phạm vi của Git cốt lõi.
Một ví dụ là khả năng cắm: Libgit2 cho phép bạn cung cấp các "`backend`" tùy chỉnh cho một số loại thao tác, vì vậy bạn có thể lưu trữ mọi thứ theo cách khác với Git cổ điển.
Libgit2 cho phép các backend tùy chỉnh cho cấu hình, lưu trữ ref, và cơ sở dữ liệu đối tượng, trong số những thứ khác.

Hãy xem cách này hoạt động.
Mã dưới đây được mượn từ bộ ví dụ backend được cung cấp bởi nhóm Libgit2 (có thể được tìm thấy tại https://github.com/libgit2/libgit2-backends[^]).
Đây là cách một backend tùy chỉnh cho cơ sở dữ liệu đối tượng được thiết lập:

[source,c]
----
git_odb *odb;
int error = git_odb_new(&odb); // <1>

git_odb_backend *my_backend;
error = git_odb_backend_mine(&my_backend, /*…*/); // <2>

error = git_odb_add_backend(odb, my_backend, 1); // <3>

git_repository *repo;
error = git_repository_open(&repo, "some-path");
error = git_repository_set_odb(repo, odb); // <4>
----

_Lưu ý rằng các lỗi được bắt, nhưng không được xử lý. Chúng tôi hy vọng mã của bạn tốt hơn của chúng tôi._

<1> Khởi tạo một "`frontend`" cơ sở dữ liệu đối tượng (ODB) trống, sẽ hoạt động như một container cho các "`backend`" là những cái thực hiện công việc thực sự.
<2> Khởi tạo một backend ODB tùy chỉnh.
<3> Thêm backend vào frontend.
<4> Mở một kho chứa, và đặt nó sử dụng ODB của chúng ta để tra cứu các đối tượng.

Nhưng `git_odb_backend_mine` này là cái gì?
Chà, đó là constructor cho triển khai ODB của riêng bạn, và bạn có thể làm bất cứ điều gì bạn muốn ở đó, miễn là bạn điền cấu trúc `git_odb_backend` đúng cách.
Đây là những gì nó _có thể_ trông như thế nào:

[source,c]
----
typedef struct {
    git_odb_backend parent;

    // Some other stuff
    void *custom_context;
} my_backend_struct;

int git_odb_backend_mine(git_odb_backend **backend_out, /*…*/)
{
    my_backend_struct *backend;

    backend = calloc(1, sizeof (my_backend_struct));

    backend->custom_context = …;

    backend->parent.read = &my_backend__read;
    backend->parent.read_prefix = &my_backend__read_prefix;
    backend->parent.read_header = &my_backend__read_header;
    // …

    *backend_out = (git_odb_backend *) backend;

    return GIT_SUCCESS;
}
----

Ràng buộc tinh tế nhất ở đây là thành viên đầu tiên của ``my_backend_struct`` phải là một cấu trúc ``git_odb_backend``; điều này đảm bảo rằng bố cục bộ nhớ là những gì mã Libgit2 mong đợi.
Phần còn lại là tùy ý; cấu trúc này có thể lớn hoặc nhỏ như bạn cần.

Hàm khởi tạo phân bổ một số bộ nhớ cho cấu trúc, thiết lập ngữ cảnh tùy chỉnh, và sau đó điền các thành viên của cấu trúc `parent` mà nó hỗ trợ.
Hãy xem tập tin `include/git2/sys/odb_backend.h` trong mã nguồn Libgit2 để biết một bộ chữ ký cuộc gọi đầy đủ; trường hợp sử dụng cụ thể của bạn sẽ giúp xác định cái nào trong số này bạn sẽ muốn hỗ trợ.

[[_libgit2_bindings]]
==== Các Binding Khác

Libgit2 có binding cho nhiều ngôn ngữ.
Ở đây chúng tôi hiển thị một ví dụ nhỏ sử dụng một vài gói binding hoàn chỉnh hơn tính đến thời điểm viết này; các thư viện tồn tại cho nhiều ngôn ngữ khác, bao gồm C++, Go, Node.js, Erlang, và JVM, tất cả ở các giai đoạn trưởng thành khác nhau.
Bộ sưu tập chính thức của các binding có thể được tìm thấy bằng cách duyệt các kho chứa tại https://github.com/libgit2[^].
Mã chúng tôi sẽ viết sẽ trả về thông điệp commit từ commit cuối cùng được trỏ đến bởi HEAD (giống như `git log -1`).

===== LibGit2Sharp

(((.NET)))(((C#)))(((Mono)))
Nếu bạn đang viết một ứng dụng .NET hoặc Mono, LibGit2Sharp (https://github.com/libgit2/libgit2sharp[^]) là những gì bạn đang tìm kiếm.
Các binding được viết bằng C#, và sự chăm sóc lớn đã được thực hiện để bọc các cuộc gọi Libgit2 thô với các API CLR cảm giác tự nhiên.
Đây là những gì chương trình ví dụ của chúng tôi trông như thế nào:

[source,csharp]
----
new Repository(@"C:\\path\\to\\repo").Head.Tip.Message;
----

Đối với các ứng dụng Windows desktop, thậm chí còn có một gói NuGet sẽ giúp bạn bắt đầu nhanh chóng.

===== objective-git

(((Apple)))(((Objective-C)))(((Cocoa)))
Nếu ứng dụng của bạn đang chạy trên một nền tảng Apple, bạn có thể đang sử dụng Objective-C làm ngôn ngữ triển khai của mình.
Objective-Git (https://github.com/libgit2/objective-git[^]) là tên của các binding Libgit2 cho môi trường đó.
Chương trình ví dụ trông như thế này:

[source,objc]
----
GTRepository *repo =
    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];
----

Objective-git hoàn toàn tương tác với Swift, vì vậy đừng sợ nếu bạn đã rời bỏ Objective-C.

===== pygit2

(((Python)))
Các binding cho Libgit2 trong Python được gọi là Pygit2, và có thể được tìm thấy tại https://www.pygit2.org[^].
Chương trình ví dụ của chúng tôi:

[source,python]
----
pygit2.Repository("/path/to/repo") # open repository
    .head                          # get the current branch
    .peel(pygit2.Commit)           # walk down to the commit
    .message                       # read the message
----

==== Đọc thêm

Tất nhiên, một xử lý đầy đủ về khả năng của Libgit2 nằm ngoài phạm vi của cuốn sách này.
Nếu bạn muốn thêm thông tin về chính Libgit2, có tài liệu API tại https://libgit2.github.com/libgit2[^], và một bộ hướng dẫn tại https://libgit2.github.com/docs[^].
Đối với các binding khác, hãy kiểm tra README và các bài kiểm tra đi kèm; thường có các hướng dẫn nhỏ và con trỏ đến việc đọc thêm ở đó.
