=== Bảo trì và Phục hồi Dữ liệu

Thỉnh thoảng, bạn có thể phải thực hiện một số dọn dẹp – làm cho một kho chứa nhỏ gọn hơn, dọn dẹp một kho chứa đã nhập, hoặc phục hồi công việc bị mất.
Phần này sẽ đề cập đến một số kịch bản này.

[[_git_gc]]
==== Bảo trì

Thỉnh thoảng, Git tự động chạy một lệnh gọi là "`auto gc`".
Hầu hết thời gian, lệnh này không làm gì cả.
Tuy nhiên, nếu có quá nhiều đối tượng loose (các đối tượng không có trong packfile) hoặc quá nhiều packfile, Git khởi chạy một lệnh `git gc` đầy đủ.
"`gc`" là viết tắt của garbage collect (thu gom rác), và lệnh này thực hiện một số việc: nó thu thập tất cả các đối tượng loose và đặt chúng vào packfile, nó hợp nhất các packfile thành một packfile lớn duy nhất, và nó xóa các đối tượng không thể truy cập được từ bất kỳ commit nào và đã vài tháng tuổi.

Bạn có thể chạy `auto gc` thủ công như sau:

[source,console]
----
$ git gc --auto
----

Một lần nữa, điều này thường không làm gì cả.
Bạn phải có khoảng 7.000 đối tượng loose hoặc hơn 50 packfile để Git khởi động một lệnh `gc` thực sự.
Bạn có thể sửa đổi các giới hạn này với các thiết lập cấu hình `gc.auto` và `gc.autopacklimit`, tương ứng.

Điều khác mà `gc` sẽ làm là đóng gói các tham chiếu của bạn vào một tập tin duy nhất.
Giả sử kho chứa của bạn chứa các nhánh và tag sau:

[source,console]
----
$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1
----

Nếu bạn chạy `git gc`, bạn sẽ không còn các tập tin này trong thư mục `refs` nữa.
Git sẽ di chuyển chúng vì lý do hiệu quả vào một tập tin có tên `.git/packed-refs` trông như thế này:

[source,console]
----
$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9
----

Nếu bạn cập nhật một tham chiếu, Git không chỉnh sửa tập tin này mà thay vào đó ghi một tập tin mới vào `refs/heads`.
Để lấy SHA-1 thích hợp cho một tham chiếu nhất định, Git kiểm tra tham chiếu đó trong thư mục `refs` và sau đó kiểm tra tập tin `packed-refs` như một dự phòng.
Vì vậy, nếu bạn không thể tìm thấy một tham chiếu trong thư mục `refs`, nó có thể ở trong tập tin `packed-refs` của bạn.

Lưu ý dòng cuối cùng của tập tin, bắt đầu bằng `^`.
Điều này có nghĩa là tag ngay phía trên là một tag annotated và dòng đó là commit mà tag annotated trỏ đến.

[[_data_recovery]]
==== Phục hồi Dữ liệu

Tại một số thời điểm trong hành trình Git của bạn, bạn có thể vô tình mất một commit.
Thường thì điều này xảy ra vì bạn force-delete một nhánh có công việc trên đó, và hóa ra bạn muốn nhánh đó sau cùng; hoặc bạn hard-reset một nhánh, do đó từ bỏ các commit mà bạn muốn một cái gì đó từ chúng.
Giả sử điều này xảy ra, làm thế nào bạn có thể lấy lại các commit của mình?

Đây là một ví dụ hard-reset nhánh `master` trong kho chứa thử nghiệm của bạn về một commit cũ hơn và sau đó phục hồi các commit bị mất.
Đầu tiên, hãy xem lại kho chứa của bạn ở thời điểm này:

[source,console]
----
$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b Modify repo.rb a bit
484a59275031909e19aadb7c92262719cfcdf19a Create repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
----

Bây giờ, di chuyển nhánh `master` trở lại commit giữa:

[source,console]
----
$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef Third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
----

Bạn đã mất hai commit hàng đầu một cách hiệu quả – bạn không có nhánh nào từ đó các commit đó có thể truy cập được.
Bạn cần tìm SHA-1 commit mới nhất và sau đó thêm một nhánh trỏ đến nó.
Thủ thuật là tìm SHA-1 commit mới nhất đó – không giống như bạn đã ghi nhớ nó, phải không?

Thường thì, cách nhanh nhất là sử dụng một công cụ gọi là `git reflog`.
Khi bạn đang làm việc, Git âm thầm ghi lại HEAD của bạn là gì mỗi khi bạn thay đổi nó.
Mỗi khi bạn commit hoặc thay đổi nhánh, reflog được cập nhật.
Reflog cũng được cập nhật bởi lệnh `git update-ref`, đó là một lý do khác để sử dụng nó thay vì chỉ ghi giá trị SHA-1 vào các tập tin ref của bạn, như chúng tôi đã đề cập trong <<ch10-git-internals#_git_refs>>.
Bạn có thể thấy bạn đã ở đâu bất cứ lúc nào bằng cách chạy `git reflog`:

[source,console]
----
$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: Modify repo.rb a bit
484a592 HEAD@{2}: commit: Create repo.rb
----

Ở đây chúng ta có thể thấy hai commit mà chúng ta đã check out, tuy nhiên không có nhiều thông tin ở đây.
Để xem cùng thông tin theo cách hữu ích hơn nhiều, chúng ta có thể chạy `git log -g`, sẽ cung cấp cho bạn một đầu ra nhật ký bình thường cho reflog của bạn.

[source,console]
----
$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:22:37 2009 -0700

		Third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

       Modify repo.rb a bit
----

Có vẻ như commit dưới cùng là commit bạn đã mất, vì vậy bạn có thể phục hồi nó bằng cách tạo một nhánh mới tại commit đó.
Ví dụ, bạn có thể bắt đầu một nhánh có tên `recover-branch` tại commit đó (ab1afef):

[source,console]
----
$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b Modify repo.rb a bit
484a59275031909e19aadb7c92262719cfcdf19a Create repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
----

Tuyệt – bây giờ bạn có một nhánh có tên `recover-branch` ở nơi nhánh `master` của bạn từng ở, làm cho hai commit đầu tiên có thể truy cập được lại.
Tiếp theo, giả sử mất mát của bạn vì một lý do nào đó không có trong reflog – bạn có thể mô phỏng điều đó bằng cách xóa `recover-branch` và xóa reflog.
Bây giờ hai commit đầu tiên không thể truy cập được bởi bất cứ thứ gì:

[source,console]
----
$ git branch -D recover-branch
$ rm -Rf .git/logs/
----

Vì dữ liệu reflog được giữ trong thư mục `.git/logs/`, bạn thực sự không có reflog.
Làm thế nào bạn có thể phục hồi commit đó tại thời điểm này?
Một cách là sử dụng tiện ích `git fsck`, kiểm tra tính toàn vẹn của cơ sở dữ liệu của bạn.
Nếu bạn chạy nó với tùy chọn `--full`, nó hiển thị cho bạn tất cả các đối tượng không được trỏ đến bởi một đối tượng khác:

[source,console]
----
$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293
----

Trong trường hợp này, bạn có thể thấy commit bị thiếu của mình sau chuỗi "`dangling commit`".
Bạn có thể phục hồi nó theo cách tương tự, bằng cách thêm một nhánh trỏ đến SHA-1 đó.

[[_removing_objects]]
==== Xóa Đối tượng

Có rất nhiều điều tuyệt vời về Git, nhưng một tính năng có thể gây ra vấn đề là thực tế rằng `git clone` tải xuống toàn bộ lịch sử của dự án, bao gồm mọi phiên bản của mọi tập tin.
Điều này tốt nếu toàn bộ là mã nguồn, vì Git được tối ưu hóa cao để nén dữ liệu đó một cách hiệu quả.
Tuy nhiên, nếu ai đó tại bất kỳ thời điểm nào trong lịch sử dự án của bạn đã thêm một tập tin lớn duy nhất, mọi bản sao cho mọi thời gian sẽ bị buộc phải tải xuống tập tin lớn đó, ngay cả khi nó đã bị xóa khỏi dự án trong commit ngay sau đó.
Vì nó có thể truy cập được từ lịch sử, nó sẽ luôn ở đó.

Điều này có thể là một vấn đề lớn khi bạn đang chuyển đổi các kho chứa Subversion hoặc Perforce sang Git.
Vì bạn không tải xuống toàn bộ lịch sử trong các hệ thống đó, loại bổ sung này mang lại ít hậu quả.
Nếu bạn đã thực hiện nhập từ một hệ thống khác hoặc nếu không thì thấy rằng kho chứa của bạn lớn hơn nhiều so với nó nên, đây là cách bạn có thể tìm và xóa các đối tượng lớn.

*Hãy cảnh báo: kỹ thuật này mang tính phá hủy đối với lịch sử commit của bạn.*
Nó viết lại mọi đối tượng commit kể từ tree sớm nhất bạn phải sửa đổi để xóa một tham chiếu tập tin lớn.
Nếu bạn làm điều này ngay sau khi nhập, trước khi bất kỳ ai bắt đầu dựa công việc trên commit, bạn ổn – nếu không, bạn phải thông báo cho tất cả những người đóng góp rằng họ phải rebase công việc của họ lên các commit mới của bạn.

Để minh họa, bạn sẽ thêm một tập tin lớn vào kho chứa thử nghiệm của mình, xóa nó trong commit tiếp theo, tìm nó, và xóa nó vĩnh viễn khỏi kho chứa.
Đầu tiên, thêm một đối tượng lớn vào lịch sử của bạn:

[source,console]
----
$ curl -L https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz > git.tgz
$ git add git.tgz
$ git commit -m 'Add git tarball'
[master 7b30847] Add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz
----

Ối – bạn không muốn thêm một tarball lớn vào dự án của mình.
Tốt hơn là loại bỏ nó:

[source,console]
----
$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'Oops - remove large tarball'
[master dadf725] Oops - remove large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz
----

Bây giờ, `gc` cơ sở dữ liệu của bạn và xem bạn đang sử dụng bao nhiêu không gian:

[source,console]
----
$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)
----

Bạn có thể chạy lệnh `count-objects` để nhanh chóng xem bạn đang sử dụng bao nhiêu không gian:

[source,console]
----
$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0
----

Mục `size-pack` là kích thước của các packfile của bạn tính bằng kilobyte, vì vậy bạn đang sử dụng gần 5MB.
Trước commit cuối cùng, bạn đã sử dụng gần 2K – rõ ràng, việc xóa tập tin khỏi commit trước đó không xóa nó khỏi lịch sử của bạn.
Mỗi khi ai đó sao chép kho chứa này, họ sẽ phải sao chép tất cả 5MB chỉ để có được dự án nhỏ này, vì bạn vô tình đã thêm một tập tin lớn.
Hãy loại bỏ nó.

Đầu tiên bạn phải tìm nó.
Trong trường hợp này, bạn đã biết tập tin nào.
Nhưng giả sử bạn không biết; bạn sẽ xác định tập tin hoặc các tập tin nào đang chiếm quá nhiều không gian như thế nào?
Nếu bạn chạy `git gc`, tất cả các đối tượng đều ở trong một packfile; bạn có thể xác định các đối tượng lớn bằng cách chạy một lệnh plumbing khác gọi là `git verify-pack` và sắp xếp trên trường thứ ba trong đầu ra, đó là kích thước tập tin.
Bạn cũng có thể chuyển nó qua lệnh `tail` vì bạn chỉ quan tâm đến một vài tập tin lớn nhất cuối cùng:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438
----

Đối tượng lớn ở dưới cùng: 5MB.
Để tìm ra tập tin nào, bạn sẽ sử dụng lệnh `rev-list`, mà bạn đã sử dụng ngắn gọn trong <<ch08-customizing-git#_enforcing_commit_message_format>>.
Nếu bạn truyền `--objects` cho `rev-list`, nó liệt kê tất cả các SHA-1 commit và cũng các SHA-1 blob với các đường dẫn tập tin liên quan đến chúng.
Bạn có thể sử dụng điều này để tìm tên blob của mình:

[source,console]
----
$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz
----

Bây giờ, bạn cần xóa tập tin này khỏi tất cả các tree trong quá khứ của bạn.
Bạn có thể dễ dàng thấy các commit nào đã sửa đổi tập tin này:

[source,console]
----
$ git log --oneline --branches -- git.tgz
dadf725 Oops - remove large tarball
7b30847 Add git tarball
----

Bạn phải viết lại tất cả các commit xuôi dòng từ `7b30847` để xóa hoàn toàn tập tin này khỏi lịch sử Git của bạn.
Để làm như vậy, bạn sử dụng `filter-branch`, mà bạn đã sử dụng trong <<ch07-git-tools#_rewriting_history>>:

[source,console]
----
$ git filter-branch --index-filter \
  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten
----

Tùy chọn `--index-filter` tương tự như tùy chọn `--tree-filter` được sử dụng trong <<ch07-git-tools#_rewriting_history>>, ngoại trừ thay vì truyền một lệnh sửa đổi các tập tin được check out trên đĩa, bạn đang sửa đổi khu vực tổ chức hoặc index của mình mỗi lần.

Thay vì xóa một tập tin cụ thể bằng một cái gì đó như `rm file`, bạn phải xóa nó bằng `git rm --cached` – bạn phải xóa nó khỏi index, không phải khỏi đĩa.
Lý do để làm theo cách này là tốc độ – vì Git không phải check out mỗi bản sửa đổi ra đĩa trước khi chạy bộ lọc của bạn, quá trình có thể nhanh hơn nhiều, nhiều lắm.
Bạn có thể hoàn thành cùng một nhiệm vụ với `--tree-filter` nếu bạn muốn.
Tùy chọn `--ignore-unmatch` cho `git rm` bảo nó không lỗi ra nếu mẫu bạn đang cố gắng xóa không ở đó.
Cuối cùng, bạn yêu cầu `filter-branch` viết lại lịch sử của bạn chỉ từ commit `7b30847` trở lên, vì bạn biết đó là nơi vấn đề này bắt đầu.
Nếu không, nó sẽ bắt đầu từ đầu và sẽ mất thời gian không cần thiết.

Lịch sử của bạn không còn chứa một tham chiếu đến tập tin đó nữa.
Tuy nhiên, reflog của bạn và một bộ tham chiếu mới mà Git đã thêm khi bạn thực hiện `filter-branch` dưới `.git/refs/original` vẫn còn, vì vậy bạn phải xóa chúng và sau đó đóng gói lại cơ sở dữ liệu.
Bạn cần loại bỏ bất cứ thứ gì có con trỏ đến các commit cũ đó trước khi bạn đóng gói lại:

[source,console]
----
$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)
----

Hãy xem bạn đã tiết kiệm được bao nhiêu không gian.

[source,console]
----
$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----

Kích thước kho chứa được đóng gói giảm xuống còn 8K, tốt hơn nhiều so với 5MB.
Bạn có thể thấy từ giá trị size rằng đối tượng lớn vẫn còn trong các đối tượng loose của bạn, vì vậy nó không biến mất; nhưng nó sẽ không được truyền trên một lần đẩy hoặc bản sao tiếp theo, đó là điều quan trọng.
Nếu bạn thực sự muốn, bạn có thể xóa đối tượng hoàn toàn bằng cách chạy `git prune` với tùy chọn `--expire`:

[source,console]
----
$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----
