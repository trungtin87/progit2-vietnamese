===  Giao thức Truyền tải

Git có thể truyền dữ liệu giữa hai kho chứa theo hai cách chính: giao thức "`dumb`" (ngu) và giao thức "`smart`" (thông minh).
Phần này sẽ nhanh chóng đề cập đến cách hai giao thức chính này hoạt động.

==== Giao thức Dumb

Nếu bạn đang thiết lập một kho chứa để được phục vụ chỉ đọc qua HTTP, giao thức dumb có thể sẽ được sử dụng.
Giao thức này được gọi là "`dumb`" vì nó không yêu cầu mã cụ thể cho Git ở phía máy chủ trong quá trình truyền tải; quá trình lấy là một loạt các yêu cầu HTTP `GET`, trong đó máy khách có thể giả định bố cục của kho chứa Git trên máy chủ.

[NOTE]
====
Giao thức dumb hiếm khi được sử dụng ngày nay.
Rất khó để bảo mật hoặc làm riêng tư, vì vậy hầu hết các máy chủ Git (cả dựa trên đám mây và tại chỗ) sẽ từ chối sử dụng nó.
Thường được khuyến nghị sử dụng giao thức smart, mà chúng ta mô tả thêm một chút sau.
====

Hãy theo dõi quá trình `http-fetch` cho thư viện simplegit:

[source,console]
----
$ git clone http://server/simplegit-progit.git
----

Điều đầu tiên lệnh này làm là kéo xuống tập tin `info/refs`.
Tập tin này được viết bởi lệnh `update-server-info`, đó là lý do tại sao bạn cần bật nó như một móc `post-receive` để truyền tải HTTP hoạt động đúng cách:

[source]
----
=> GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master
----

Bây giờ bạn có một danh sách các tham chiếu từ xa và SHA-1.
Tiếp theo, bạn tìm kiếm tham chiếu HEAD là gì để bạn biết cần check out cái gì khi hoàn thành:

[source]
----
=> GET HEAD
ref: refs/heads/master
----

Bạn cần check out nhánh `master` khi hoàn thành quá trình.
Tại thời điểm này, bạn đã sẵn sàng để bắt đầu quá trình đi bộ (walking).
Vì điểm bắt đầu của bạn là đối tượng commit `ca82a6` mà bạn đã thấy trong tập tin `info/refs`, bạn bắt đầu bằng cách lấy nó:

[source]
----
=> GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)
----

Bạn nhận lại một đối tượng – đối tượng đó ở định dạng loose trên máy chủ, và bạn đã lấy nó qua một yêu cầu HTTP GET tĩnh.
Bạn có thể giải nén zlib, loại bỏ tiêu đề, và xem nội dung commit:

[source,console]
----
$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

Change version number
----

Tiếp theo, bạn có thêm hai đối tượng để truy xuất – `cfda3b`, là tree nội dung mà commit chúng ta vừa truy xuất trỏ đến; và `085bb3`, là commit cha mẹ:

[source]
----
=> GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)
----

Điều đó cung cấp cho bạn đối tượng commit tiếp theo của bạn.
Lấy đối tượng tree:

[source]
----
=> GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)
----

Ối – có vẻ như đối tượng tree đó không ở định dạng loose trên máy chủ, vì vậy bạn nhận lại phản hồi 404.
Có một vài lý do cho điều này – đối tượng có thể ở trong một kho chứa thay thế, hoặc nó có thể ở trong một packfile trong kho chứa này.
Git kiểm tra bất kỳ thay thế nào được liệt kê trước:

[source]
----
=> GET objects/info/http-alternates
(empty file)
----

Nếu điều này trả về với một danh sách các URL thay thế, Git kiểm tra các tập tin loose và packfile ở đó – đây là một cơ chế tốt đẹp cho các dự án là fork của nhau để chia sẻ các đối tượng trên đĩa.
Tuy nhiên, vì không có thay thế nào được liệt kê trong trường hợp này, đối tượng của bạn phải ở trong một packfile.
Để xem packfile nào có sẵn trên máy chủ này, bạn cần lấy tập tin `objects/info/packs`, chứa danh sách chúng (cũng được tạo bởi `update-server-info`):

[source]
----
=> GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
----

Chỉ có một packfile trên máy chủ, vì vậy đối tượng của bạn rõ ràng là ở đó, nhưng bạn sẽ kiểm tra tập tin index để chắc chắn.
Điều này cũng hữu ích nếu bạn có nhiều packfile trên máy chủ, vì vậy bạn có thể thấy packfile nào chứa đối tượng bạn cần:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)
----

Bây giờ bạn đã có index packfile, bạn có thể thấy đối tượng của mình có trong đó không – vì index liệt kê các SHA-1 của các đối tượng chứa trong packfile và các offset đến các đối tượng đó.
Đối tượng của bạn ở đó, vì vậy hãy tiếp tục và lấy toàn bộ packfile:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)
----

Bạn có đối tượng tree của mình, vì vậy bạn tiếp tục đi bộ các commit của mình.
Tất cả chúng cũng nằm trong packfile bạn vừa tải xuống, vì vậy bạn không phải thực hiện thêm bất kỳ yêu cầu nào đến máy chủ của mình.
Git check out một bản sao làm việc của nhánh `master` được trỏ đến bởi tham chiếu HEAD mà bạn đã tải xuống lúc đầu.

==== Giao thức Smart

Giao thức dumb đơn giản nhưng hơi kém hiệu quả, và nó không thể xử lý việc ghi dữ liệu từ máy khách đến máy chủ.
Giao thức smart là một phương pháp phổ biến hơn để truyền dữ liệu, nhưng nó yêu cầu một quá trình ở đầu từ xa thông minh về Git – nó có thể đọc dữ liệu cục bộ, tìm ra những gì máy khách có và cần, và tạo một packfile tùy chỉnh cho nó.
Có hai bộ quá trình để truyền dữ liệu: một cặp để tải lên dữ liệu và một cặp để tải xuống dữ liệu.

===== Tải lên Dữ liệu

(((git commands, send-pack)))(((git commands, receive-pack)))
Để tải lên dữ liệu đến một quá trình từ xa, Git sử dụng các quá trình `send-pack` và `receive-pack`.
Quá trình `send-pack` chạy trên máy khách và kết nối đến một quá trình `receive-pack` ở phía từ xa.

====== SSH

Ví dụ, giả sử bạn chạy `git push origin master` trong dự án của mình, và `origin` được định nghĩa là một URL sử dụng giao thức SSH.
Git khởi động quá trình `send-pack`, khởi tạo một kết nối qua SSH đến máy chủ của bạn.
Nó cố gắng chạy một lệnh trên máy chủ từ xa thông qua một cuộc gọi SSH trông giống như thế này:

[source,console]
----
$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
0000
----

Lệnh `git-receive-pack` ngay lập tức phản hồi với một dòng cho mỗi tham chiếu mà nó hiện có – trong trường hợp này, chỉ là nhánh `master` và SHA-1 của nó.
Dòng đầu tiên cũng có một danh sách các khả năng của máy chủ (ở đây, `report-status`, `delete-refs`, và một số khác, bao gồm định danh máy khách).

Dữ liệu được truyền theo từng khối (chunk).
Mỗi khối bắt đầu bằng một giá trị hex 4 ký tự chỉ định độ dài của khối (bao gồm 4 byte của chính độ dài).
Các khối thường chứa một dòng dữ liệu duy nhất và một linefeed cuối.
Khối đầu tiên của bạn bắt đầu bằng 00a5, là hệ thập lục phân cho 165, có nghĩa là khối dài 165 byte.
Khối tiếp theo là 0000, có nghĩa là máy chủ đã hoàn thành danh sách tham chiếu của nó.

Bây giờ nó biết trạng thái của máy chủ, quá trình `send-pack` của bạn xác định các commit nào nó có mà máy chủ không có.
Đối với mỗi tham chiếu mà lần đẩy này sẽ cập nhật, quá trình `send-pack` bảo quá trình `receive-pack` thông tin đó.
Ví dụ, nếu bạn đang cập nhật nhánh `master` và thêm một nhánh `experiment`, phản hồi `send-pack` có thể trông giống như thế này:

[source]
----
0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000
----

Git gửi một dòng cho mỗi tham chiếu bạn đang cập nhật với độ dài của dòng, SHA-1 cũ, SHA-1 mới, và tham chiếu đang được cập nhật.
Dòng đầu tiên cũng có các khả năng của máy khách.
Giá trị SHA-1 của tất cả '0' có nghĩa là không có gì ở đó trước đó – vì bạn đang thêm tham chiếu `experiment`.
Nếu bạn đang xóa một tham chiếu, bạn sẽ thấy ngược lại: tất cả '0' ở phía bên phải.

Tiếp theo, máy khách gửi một packfile của tất cả các đối tượng mà máy chủ chưa có.
Cuối cùng, máy chủ phản hồi với một chỉ báo thành công (hoặc thất bại):

[source]
----
000eunpack ok
----

====== HTTP(S)

Quá trình này hầu như giống nhau qua HTTP, mặc dù bắt tay hơi khác một chút.
Kết nối được khởi tạo với yêu cầu này:

[source]
----
=> GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000
----

Đó là kết thúc của trao đổi máy khách-máy chủ đầu tiên.
Sau đó máy khách thực hiện một yêu cầu khác, lần này là một `POST`, với dữ liệu mà `send-pack` cung cấp.

[source]
----
=> POST http://server/simplegit-progit.git/git-receive-pack
----

Yêu cầu `POST` bao gồm đầu ra `send-pack` và packfile làm payload của nó.
Sau đó máy chủ chỉ ra thành công hoặc thất bại với phản hồi HTTP của nó.

Hãy nhớ rằng giao thức HTTP có thể bọc dữ liệu này thêm bên trong một mã hóa truyền tải chunked.

===== Tải xuống Dữ liệu

(((git commands, fetch-pack)))(((git commands, upload-pack)))
Khi bạn tải xuống dữ liệu, các quá trình `fetch-pack` và `upload-pack` có liên quan.
Máy khách khởi tạo một quá trình `fetch-pack` kết nối đến một quá trình `upload-pack` ở phía từ xa để thương lượng dữ liệu nào sẽ được truyền xuống.

====== SSH

Nếu bạn đang thực hiện lấy qua SSH, `fetch-pack` chạy một cái gì đó như thế này:

[source,console]
----
$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"
----

Sau khi `fetch-pack` kết nối, `upload-pack` gửi lại một cái gì đó như thế này:

[source]
----
00dfca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master
0000
----

Điều này rất giống với những gì `receive-pack` phản hồi, nhưng các khả năng khác nhau.
Ngoài ra, nó gửi lại những gì HEAD trỏ đến (`symref=HEAD:refs/heads/master`) để máy khách biết cần check out cái gì nếu đây là một bản sao.

Tại thời điểm này, quá trình `fetch-pack` nhìn vào các đối tượng nào nó có và phản hồi với các đối tượng mà nó cần bằng cách gửi "`want`" và sau đó là SHA-1 mà nó muốn.
Nó gửi tất cả các đối tượng mà nó đã có với "`have`" và sau đó là SHA-1.
Ở cuối danh sách này, nó viết "`done`" để khởi tạo quá trình `upload-pack` bắt đầu gửi packfile của dữ liệu mà nó cần:

[source]
----
003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000
----

====== HTTP(S)

Bắt tay cho một thao tác lấy mất hai yêu cầu HTTP.
Đầu tiên là một `GET` đến cùng một endpoint được sử dụng trong giao thức dumb:

[source]
----
=> GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000
----

Điều này rất giống với việc gọi `git-upload-pack` qua một kết nối SSH, nhưng trao đổi thứ hai được thực hiện như một yêu cầu riêng biệt:

[source]
----
=> POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000
----

Một lần nữa, đây là cùng một định dạng như trên.
Phản hồi cho yêu cầu này chỉ ra thành công hoặc thất bại, và bao gồm packfile.

==== Tóm tắt Giao thức

Phần này chứa một tổng quan rất cơ bản về các giao thức truyền tải.
Giao thức bao gồm nhiều tính năng khác, chẳng hạn như khả năng `multi_ack` hoặc `side-band`, nhưng việc đề cập đến chúng nằm ngoài phạm vi của cuốn sách này.
Chúng tôi đã cố gắng cung cấp cho bạn cảm giác về sự trao đổi qua lại chung giữa máy khách và máy chủ; nếu bạn cần nhiều kiến thức hơn thế này, bạn có thể sẽ muốn xem mã nguồn Git.
