[[_git_refs]]
=== Tham chiếu Git

Nếu bạn quan tâm đến việc xem lịch sử của kho chứa có thể truy cập được từ commit, chẳng hạn, `1a410e`, bạn có thể chạy một cái gì đó như `git log 1a410e` để hiển thị lịch sử đó, nhưng bạn vẫn phải nhớ rằng `1a410e` là commit bạn muốn sử dụng làm điểm bắt đầu cho lịch sử đó.
Thay vào đó, sẽ dễ dàng hơn nếu bạn có một tập tin trong đó bạn có thể lưu trữ giá trị SHA-1 đó dưới một tên đơn giản để bạn có thể sử dụng tên đơn giản đó thay vì giá trị SHA-1 thô.

Trong Git, những tên đơn giản này được gọi là "`references`" (tham chiếu) hoặc "`refs`"; bạn có thể tìm thấy các tập tin chứa những giá trị SHA-1 đó trong thư mục `.git/refs`.
Trong dự án hiện tại, thư mục này không chứa tập tin nào, nhưng nó chứa một cấu trúc đơn giản:

[source,console]
----
$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
----

Để tạo một tham chiếu mới sẽ giúp bạn nhớ commit mới nhất của mình ở đâu, về mặt kỹ thuật bạn có thể làm một cái gì đó đơn giản như thế này:

[source,console]
----
$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 > .git/refs/heads/master
----

Bây giờ, bạn có thể sử dụng tham chiếu head bạn vừa tạo thay vì giá trị SHA-1 trong các lệnh Git của mình:

[source,console]
----
$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
----

Bạn không được khuyến khích chỉnh sửa trực tiếp các tập tin tham chiếu; thay vào đó, Git cung cấp lệnh an toàn hơn `git update-ref` để làm điều này nếu bạn muốn cập nhật một tham chiếu:

[source,console]
----
$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
----

Đó về cơ bản là một nhánh trong Git: một con trỏ đơn giản hoặc tham chiếu đến đầu của một dòng công việc.
Để tạo một nhánh trở lại commit thứ hai, bạn có thể làm điều này:

[source,console]
----
$ git update-ref refs/heads/test cac0ca
----

Nhánh của bạn sẽ chỉ chứa công việc từ commit đó trở xuống:

[source,console]
----
$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
----

Bây giờ, cơ sở dữ liệu Git của bạn về mặt khái niệm trông giống như thế này:

.Các đối tượng thư mục Git với các tham chiếu đầu nhánh được bao gồm
image::images/data-model-4.png[Các đối tượng thư mục Git với các tham chiếu đầu nhánh được bao gồm]

Khi bạn chạy các lệnh như `git branch <branch>`, Git về cơ bản chạy lệnh `update-ref` đó để thêm SHA-1 của commit cuối cùng của nhánh bạn đang ở vào bất kỳ tham chiếu mới nào bạn muốn tạo.

[[ref_the_ref]]
==== HEAD

Câu hỏi bây giờ là, khi bạn chạy `git branch <branch>`, Git biết SHA-1 của commit cuối cùng như thế nào?
Câu trả lời là tập tin HEAD.

Thường thì tập tin HEAD là một tham chiếu tượng trưng (symbolic reference) đến nhánh bạn hiện đang ở.
Bằng tham chiếu tượng trưng, chúng tôi có nghĩa là không giống như một tham chiếu bình thường, nó chứa một con trỏ đến một tham chiếu khác.

Tuy nhiên trong một số trường hợp hiếm, tập tin HEAD có thể chứa giá trị SHA-1 của một đối tượng Git.
Điều này xảy ra khi bạn checkout một tag, commit, hoặc nhánh từ xa, điều này đặt kho chứa của bạn vào trạng thái https://git-scm.com/docs/git-checkout#_detached_head["detached HEAD"^].

Nếu bạn nhìn vào tập tin, bạn thường sẽ thấy một cái gì đó như thế này:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/master
----

Nếu bạn chạy `git checkout test`, Git cập nhật tập tin để trông như thế này:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/test
----

Khi bạn chạy `git commit`, nó tạo đối tượng commit, chỉ định cha mẹ của đối tượng commit đó là bất kỳ giá trị SHA-1 nào mà tham chiếu trong HEAD trỏ đến.

Bạn cũng có thể chỉnh sửa thủ công tập tin này, nhưng một lần nữa một lệnh an toàn hơn tồn tại để làm như vậy: `git symbolic-ref`.
Bạn có thể đọc giá trị của HEAD của mình thông qua lệnh này:

[source,console]
----
$ git symbolic-ref HEAD
refs/heads/master
----

Bạn cũng có thể đặt giá trị của HEAD bằng cách sử dụng cùng một lệnh:

[source,console]
----
$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test
----

Bạn không thể đặt một tham chiếu tượng trưng bên ngoài kiểu refs:

[source,console]
----
$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/
----

==== Tags

Chúng ta vừa hoàn thành việc thảo luận về ba loại đối tượng chính của Git (_blobs_, _trees_ và _commits_), nhưng có một loại thứ tư.
Đối tượng _tag_ rất giống như một đối tượng commit -- nó chứa một người gắn tag, một ngày, một thông điệp, và một con trỏ.
Sự khác biệt chính là một đối tượng tag thường trỏ đến một commit thay vì một tree.
Nó giống như một tham chiếu nhánh, nhưng nó không bao giờ di chuyển -- nó luôn trỏ đến cùng một commit nhưng đặt cho nó một tên thân thiện hơn.

Như đã thảo luận trong <<ch02-git-basics-chapter#ch02-git-basics-chapter>>, có hai loại tag: annotated và lightweight.
Bạn có thể tạo một tag lightweight bằng cách chạy một cái gì đó như thế này:

[source,console]
----
$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
----

Đó là tất cả những gì một tag lightweight là -- một tham chiếu không bao giờ di chuyển.
Tuy nhiên, một tag annotated phức tạp hơn.
Nếu bạn tạo một tag annotated, Git tạo một đối tượng tag và sau đó ghi một tham chiếu để trỏ đến nó thay vì trực tiếp đến commit.
Bạn có thể thấy điều này bằng cách tạo một tag annotated (sử dụng tùy chọn `-a`):

[source,console]
----
$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'Test tag'
----

Đây là giá trị SHA-1 của đối tượng mà nó đã tạo:

[source,console]
----
$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2
----

Bây giờ, chạy `git cat-file -p` trên giá trị SHA-1 đó:

[source,console]
----
$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700

Test tag
----

Lưu ý rằng mục object trỏ đến giá trị SHA-1 của commit mà bạn đã gắn tag.
Cũng lưu ý rằng nó không cần phải trỏ đến một commit; bạn có thể gắn tag bất kỳ đối tượng Git nào.
Trong mã nguồn Git, ví dụ, người bảo trì đã thêm khóa công khai GPG của họ dưới dạng một đối tượng blob và sau đó gắn tag nó.
Bạn có thể xem khóa công khai bằng cách chạy lệnh này trong một bản sao của kho chứa Git:

[source,console]
----
$ git cat-file blob junio-gpg-pub
----

Kho chứa kernel Linux cũng có một đối tượng tag không trỏ đến commit -- tag đầu tiên được tạo trỏ đến tree ban đầu của việc nhập mã nguồn.

==== Remotes

Loại tham chiếu thứ ba mà bạn sẽ thấy là một tham chiếu từ xa (remote reference).
Nếu bạn thêm một remote và đẩy lên nó, Git lưu trữ giá trị bạn đã đẩy lên remote đó lần cuối cho mỗi nhánh trong thư mục `refs/remotes`.
Ví dụ, bạn có thể thêm một remote có tên `origin` và đẩy nhánh `master` của bạn lên nó:

[source,console]
----
$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -> master
----

Sau đó, bạn có thể thấy nhánh `master` trên remote `origin` là gì lần cuối cùng bạn giao tiếp với máy chủ, bằng cách kiểm tra tập tin `refs/remotes/origin/master`:

[source,console]
----
$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949
----

Các tham chiếu từ xa khác với các nhánh (tham chiếu `refs/heads`) chủ yếu ở chỗ chúng được coi là chỉ đọc.
Bạn có thể `git checkout` đến một cái, nhưng Git sẽ không tham chiếu tượng trưng HEAD đến một cái, vì vậy bạn sẽ không bao giờ cập nhật nó bằng lệnh `commit`.
Git quản lý chúng như các dấu trang đến trạng thái đã biết cuối cùng của nơi các nhánh đó ở trên các máy chủ đó.
