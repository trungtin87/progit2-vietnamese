===  Packfiles

Nếu bạn đã làm theo tất cả các hướng dẫn trong ví dụ từ phần trước, bây giờ bạn nên có một kho chứa Git thử nghiệm với 11 đối tượng -- bốn blob, ba tree, ba commit, và một tag:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Git nén nội dung của các tập tin này bằng zlib, và bạn không lưu trữ nhiều, vì vậy tất cả các tập tin này cộng lại chỉ chiếm 925 byte.
Bây giờ bạn sẽ thêm một số nội dung có kích thước lớn hơn vào kho chứa để minh họa một tính năng thú vị của Git.
Để minh họa, chúng ta sẽ thêm tập tin `repo.rb` từ thư viện Grit -- đây là một tập tin mã nguồn khoảng 22K:

[source,console]
----
$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb > repo.rb
$ git checkout master
$ git add repo.rb
$ git commit -m 'Create repo.rb'
[master 484a592] Create repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)
----

Nếu bạn nhìn vào tree kết quả, bạn có thể thấy giá trị SHA-1 đã được tính toán cho đối tượng blob `repo.rb` mới của bạn:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Sau đó bạn có thể sử dụng `git cat-file` để xem đối tượng đó lớn như thế nào:

[source,console]
----
$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044
----

Tại thời điểm này, sửa đổi tập tin đó một chút, và xem điều gì xảy ra:

[source,console]
----
$ echo '# testing' >> repo.rb
$ git commit -am 'Modify repo.rb a bit'
[master 2431da6] Modify repo.rb a bit
 1 file changed, 1 insertion(+)
----

Kiểm tra tree được tạo bởi commit cuối cùng đó, và bạn thấy một cái gì đó thú vị:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Blob bây giờ là một blob khác, có nghĩa là mặc dù bạn chỉ thêm một dòng duy nhất vào cuối một tập tin 400 dòng, Git đã lưu trữ nội dung mới đó như một đối tượng hoàn toàn mới:

[source,console]
----
$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054
----

Bạn có hai đối tượng gần như giống hệt nhau 22K trên đĩa của mình (mỗi cái được nén xuống khoảng 7K).
Sẽ không tốt nếu Git có thể lưu trữ một trong số chúng đầy đủ nhưng sau đó đối tượng thứ hai chỉ là delta giữa nó và cái đầu tiên?

Hóa ra là nó có thể.
Định dạng ban đầu mà Git lưu các đối tượng trên đĩa được gọi là định dạng đối tượng "`loose`" (lỏng lẻo).
Tuy nhiên, thỉnh thoảng Git đóng gói một số đối tượng này vào một tập tin nhị phân duy nhất gọi là "`packfile`" để tiết kiệm không gian và hiệu quả hơn.
Git làm điều này nếu bạn có quá nhiều đối tượng loose xung quanh, nếu bạn chạy lệnh `git gc` thủ công, hoặc nếu bạn đẩy lên một máy chủ từ xa.
Để xem điều gì xảy ra, bạn có thể yêu cầu Git đóng gói các đối tượng một cách thủ công bằng cách gọi lệnh `git gc`:

[source,console]
----
$ git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)
----

Nếu bạn nhìn vào thư mục `objects` của mình, bạn sẽ thấy rằng hầu hết các đối tượng của bạn đã biến mất, và một cặp tập tin mới đã xuất hiện:

[source,console]
----
$ find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack
----

Các đối tượng còn lại là các blob không được trỏ đến bởi bất kỳ commit nào -- trong trường hợp này, các blob ví dụ "`what is up, doc?`" và "`test content`" mà bạn đã tạo trước đó.
Vì bạn chưa bao giờ thêm chúng vào bất kỳ commit nào, chúng được coi là dangling (lơ lửng) và không được đóng gói trong packfile mới của bạn.

Các tập tin khác là packfile mới của bạn và một index.
Packfile là một tập tin duy nhất chứa nội dung của tất cả các đối tượng đã bị xóa khỏi hệ thống tập tin của bạn.
Index là một tập tin chứa các offset vào packfile đó để bạn có thể nhanh chóng tìm kiếm đến một đối tượng cụ thể.
Điều thú vị là mặc dù các đối tượng trên đĩa trước khi bạn chạy lệnh `gc` có kích thước tổng cộng khoảng 15K, packfile mới chỉ có 7K.
Bạn đã cắt giảm việc sử dụng đĩa của mình xuống một nửa bằng cách đóng gói các đối tượng của bạn.

Git làm điều này như thế nào?
Khi Git đóng gói các đối tượng, nó tìm kiếm các tập tin được đặt tên và có kích thước tương tự, và chỉ lưu trữ các delta từ một phiên bản của tập tin sang phiên bản tiếp theo.
Bạn có thể nhìn vào packfile và xem Git đã làm gì để tiết kiệm không gian.
Lệnh plumbing `git verify-pack` cho phép bạn xem những gì đã được đóng gói:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok
----

Ở đây, blob `033b4`, nếu bạn nhớ là phiên bản đầu tiên của tập tin `repo.rb` của bạn, đang tham chiếu đến blob `b042a`, là phiên bản thứ hai của tập tin.
Cột thứ ba trong đầu ra là kích thước của đối tượng trong pack, vì vậy bạn có thể thấy rằng `b042a` chiếm 22K của tập tin, nhưng `033b4` chỉ chiếm 9 byte.
Điều cũng thú vị là phiên bản thứ hai của tập tin là phiên bản được lưu trữ nguyên vẹn, trong khi phiên bản gốc được lưu trữ dưới dạng delta -- điều này là vì bạn rất có thể cần truy cập nhanh hơn vào phiên bản gần đây nhất của tập tin.

Điều thực sự tốt đẹp về điều này là nó có thể được đóng gói lại bất cứ lúc nào.
Git thỉnh thoảng sẽ tự động đóng gói lại cơ sở dữ liệu của bạn, luôn cố gắng tiết kiệm nhiều không gian hơn, nhưng bạn cũng có thể đóng gói lại thủ công bất cứ lúc nào bằng cách chạy `git gc` bằng tay.
