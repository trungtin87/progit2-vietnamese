[[_objects]]
=== Đối tượng Git

Git là một hệ thống tập tin có thể định địa chỉ nội dung (content-addressable filesystem).
Tuyệt vời.
Điều đó có nghĩa là gì?
Nó có nghĩa là ở cốt lõi của Git là một kho lưu trữ dữ liệu khóa-giá trị đơn giản.
Điều này có nghĩa là bạn có thể chèn bất kỳ loại nội dung nào vào một kho chứa Git, mà Git sẽ trả lại cho bạn một khóa duy nhất mà bạn có thể sử dụng sau này để truy xuất nội dung đó.

Để minh họa, hãy xem lệnh plumbing `git hash-object`, lệnh này nhận một số dữ liệu, lưu trữ nó trong thư mục `.git/objects` của bạn (_cơ sở dữ liệu đối tượng_), và trả lại cho bạn khóa duy nhất hiện đang tham chiếu đến đối tượng dữ liệu đó.

Đầu tiên, bạn khởi tạo một kho chứa Git mới và xác minh rằng (có thể dự đoán được) không có gì trong thư mục `objects`:

[source,console]
----
$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
----

Git đã khởi tạo thư mục `objects` và tạo các thư mục con `pack` và `info` trong đó, nhưng không có tập tin thông thường nào.
Bây giờ, hãy sử dụng `git hash-object` để tạo một đối tượng dữ liệu mới và lưu trữ thủ công nó trong cơ sở dữ liệu Git mới của bạn:

[source,console]
----
$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
----

Ở dạng đơn giản nhất, `git hash-object` sẽ lấy nội dung bạn đưa cho nó và chỉ trả về khóa duy nhất _sẽ_ được sử dụng để lưu trữ nó trong cơ sở dữ liệu Git của bạn.
Tùy chọn `-w` sau đó bảo lệnh không chỉ đơn giản trả về khóa, mà còn ghi đối tượng đó vào cơ sở dữ liệu.
Cuối cùng, tùy chọn `--stdin` bảo `git hash-object` lấy nội dung cần xử lý từ stdin; nếu không, lệnh sẽ mong đợi một đối số tên tập tin ở cuối lệnh chứa nội dung sẽ được sử dụng.

Đầu ra từ lệnh trên là một hàm băm tổng kiểm tra 40 ký tự.
Đây là hàm băm SHA-1 -- một tổng kiểm tra của nội dung bạn đang lưu trữ cộng với một tiêu đề, mà bạn sẽ tìm hiểu trong một chút.
Bây giờ bạn có thể thấy Git đã lưu trữ dữ liệu của bạn như thế nào:

[source,console]
----
$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Nếu bạn lại kiểm tra thư mục `objects` của mình, bạn có thể thấy rằng bây giờ nó chứa một tập tin cho nội dung mới đó.
Đây là cách Git lưu trữ nội dung ban đầu -- như một tập tin duy nhất cho mỗi phần nội dung, được đặt tên bằng tổng kiểm tra SHA-1 của nội dung và tiêu đề của nó.
Thư mục con được đặt tên bằng 2 ký tự đầu tiên của SHA-1, và tên tập tin là 38 ký tự còn lại.

Khi bạn đã có nội dung trong cơ sở dữ liệu đối tượng của mình, bạn có thể kiểm tra nội dung đó bằng lệnh `git cat-file`.
Lệnh này giống như một con dao đa năng Thụy Sĩ để kiểm tra các đối tượng Git.
Truyền `-p` cho `cat-file` hướng dẫn lệnh trước tiên tìm ra loại nội dung, sau đó hiển thị nó một cách thích hợp:

[source,console]
----
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
----

Bây giờ, bạn có thể thêm nội dung vào Git và kéo nó ra lại.
Bạn cũng có thể làm điều này với nội dung trong các tập tin.
Ví dụ, bạn có thể thực hiện một số kiểm soát phiên bản đơn giản trên một tập tin.
Đầu tiên, tạo một tập tin mới và lưu nội dung của nó trong cơ sở dữ liệu của bạn:

[source,console]
----
$ echo 'version 1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
----

Sau đó, ghi một số nội dung mới vào tập tin, và lưu nó lại:

[source,console]
----
$ echo 'version 2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
----

Cơ sở dữ liệu đối tượng của bạn bây giờ chứa cả hai phiên bản của tập tin mới này (cũng như nội dung đầu tiên bạn đã lưu trữ ở đó):

[source,console]
----
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Tại thời điểm này, bạn có thể xóa bản sao cục bộ của tập tin `test.txt` đó, sau đó sử dụng Git để truy xuất, từ cơ sở dữ liệu đối tượng, phiên bản đầu tiên bạn đã lưu:

[source,console]
----
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
----

hoặc phiên bản thứ hai:

[source,console]
----
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
----

Nhưng việc nhớ khóa SHA-1 cho mỗi phiên bản của tập tin của bạn không thực tế; cộng thêm, bạn không lưu trữ tên tập tin trong hệ thống của mình -- chỉ là nội dung.
Loại đối tượng này được gọi là _blob_.
Bạn có thể yêu cầu Git cho bạn biết loại đối tượng của bất kỳ đối tượng nào trong Git, với khóa SHA-1 của nó, bằng `git cat-file -t`:

[source,console]
----
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
----

[[_tree_objects]]
==== Đối tượng Tree

Loại đối tượng Git tiếp theo chúng ta sẽ kiểm tra là _tree_, giải quyết vấn đề lưu trữ tên tập tin và cũng cho phép bạn lưu trữ một nhóm tập tin cùng nhau.
Git lưu trữ nội dung theo cách tương tự như một hệ thống tập tin UNIX, nhưng đơn giản hóa một chút.
Tất cả nội dung được lưu trữ dưới dạng các đối tượng tree và blob, với các tree tương ứng với các mục thư mục UNIX và các blob tương ứng ít nhiều với các inode hoặc nội dung tập tin.
Một đối tượng tree duy nhất chứa một hoặc nhiều mục, mỗi mục là hàm băm SHA-1 của một blob hoặc subtree với chế độ, loại và tên tập tin liên quan của nó.
Ví dụ, giả sử bạn có một dự án trong đó tree gần đây nhất trông giống như:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
----

Cú pháp `master^{tree}` chỉ định đối tượng tree được trỏ đến bởi commit cuối cùng trên nhánh `master` của bạn.
Lưu ý rằng thư mục con `lib` không phải là một blob mà là một con trỏ đến một tree khác:

[source,console]
----
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
----

[NOTE]
====
Tùy thuộc vào shell bạn sử dụng, bạn có thể gặp lỗi khi sử dụng cú pháp `master^{tree}`.

Trong CMD trên Windows, ký tự `^` được sử dụng để thoát, vì vậy bạn phải nhân đôi nó để tránh điều này: `git cat-file -p master^^{tree}`.
Khi sử dụng PowerShell, các tham số sử dụng ký tự `{}` phải được đặt trong dấu ngoặc kép để tránh tham số bị phân tích cú pháp không chính xác: `git cat-file -p 'master^{tree}'`.

Nếu bạn đang sử dụng ZSH, ký tự `^` được sử dụng cho globbing, vì vậy bạn phải đặt toàn bộ biểu thức trong dấu ngoặc kép: `git cat-file -p "master^{tree}"`.
====

Về mặt khái niệm, dữ liệu mà Git đang lưu trữ trông giống như thế này:

.Phiên bản đơn giản của mô hình dữ liệu Git
image::images/data-model-1.png[Phiên bản đơn giản của mô hình dữ liệu Git]

Bạn có thể khá dễ dàng tạo tree của riêng mình.
Git thường tạo một tree bằng cách lấy trạng thái của khu vực tổ chức hoặc index của bạn và ghi một loạt các đối tượng tree từ đó.
Vì vậy, để tạo một đối tượng tree, trước tiên bạn phải thiết lập một index bằng cách tổ chức một số tập tin.
Để tạo một index với một mục duy nhất -- phiên bản đầu tiên của tập tin `test.txt` của bạn -- bạn có thể sử dụng lệnh plumbing `git update-index`.
Bạn sử dụng lệnh này để thêm một cách giả tạo phiên bản trước đó của tập tin `test.txt` vào một khu vực tổ chức mới.
Bạn phải truyền cho nó tùy chọn `--add` vì tập tin chưa tồn tại trong khu vực tổ chức của bạn (bạn thậm chí chưa có một khu vực tổ chức được thiết lập) và `--cacheinfo` vì tập tin bạn đang thêm không có trong thư mục của bạn mà có trong cơ sở dữ liệu của bạn.
Sau đó, bạn chỉ định chế độ, SHA-1, và tên tập tin:

[source,console]
----
$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
----

Trong trường hợp này, bạn đang chỉ định chế độ `100644`, có nghĩa là đó là một tập tin bình thường.
Các tùy chọn khác là `100755`, có nghĩa là đó là một tập tin thực thi; và `120000`, chỉ định một liên kết tượng trưng.
Chế độ được lấy từ các chế độ UNIX bình thường nhưng linh hoạt hơn nhiều -- ba chế độ này là những chế độ duy nhất hợp lệ cho các tập tin (blob) trong Git (mặc dù các chế độ khác được sử dụng cho các thư mục và submodule).

Bây giờ, bạn có thể sử dụng `git write-tree` để ghi khu vực tổ chức ra một đối tượng tree.
Không cần tùy chọn `-w` -- gọi lệnh này tự động tạo một đối tượng tree từ trạng thái của index nếu tree đó chưa tồn tại:

[source,console]
----
$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
----

Bạn cũng có thể xác minh rằng đây là một đối tượng tree bằng cách sử dụng cùng lệnh `git cat-file` mà bạn đã thấy trước đó:

[source,console]
----
$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
----

Bây giờ bạn sẽ tạo một tree mới với phiên bản thứ hai của `test.txt` và một tập tin mới:

[source,console]
----
$ echo 'new file' > new.txt
$ git update-index --cacheinfo 100644 \
  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
$ git update-index --add new.txt
----

Khu vực tổ chức của bạn bây giờ có phiên bản mới của `test.txt` cũng như tập tin mới `new.txt`.
Ghi ra tree đó (ghi lại trạng thái của khu vực tổ chức hoặc index vào một đối tượng tree) và xem nó trông như thế nào:

[source,console]
----
$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Lưu ý rằng tree này có cả hai mục tập tin và cũng rằng SHA-1 của `test.txt` là SHA-1 "`version 2`" từ trước đó (`1f7a7a`).
Chỉ để cho vui, bạn sẽ thêm tree đầu tiên như một thư mục con vào tree này.
Bạn có thể đọc các tree vào khu vực tổ chức của mình bằng cách gọi `git read-tree`.
Trong trường hợp này, bạn có thể đọc một tree hiện có vào khu vực tổ chức của mình như một subtree bằng cách sử dụng tùy chọn `--prefix` với lệnh này:

[source,console]
----
$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Nếu bạn tạo một thư mục làm việc từ tree mới mà bạn vừa viết, bạn sẽ nhận được hai tập tin ở cấp cao nhất của thư mục làm việc và một thư mục con có tên `bak` chứa phiên bản đầu tiên của tập tin `test.txt`.
Bạn có thể nghĩ về dữ liệu mà Git chứa cho các cấu trúc này như thế này:

.Cấu trúc nội dung của dữ liệu Git hiện tại của bạn
image::images/data-model-2.png[Cấu trúc nội dung của dữ liệu Git hiện tại của bạn]

[[_git_commit_objects]]
==== Đối tượng Commit

Nếu bạn đã làm tất cả những điều trên, bây giờ bạn có ba tree đại diện cho các ảnh chụp nhanh khác nhau của dự án mà bạn muốn theo dõi, nhưng vấn đề trước đó vẫn còn: bạn phải nhớ cả ba giá trị SHA-1 để thu hồi các ảnh chụp nhanh.
Bạn cũng không có bất kỳ thông tin nào về ai đã lưu các ảnh chụp nhanh, khi nào chúng được lưu, hoặc tại sao chúng được lưu.
Đây là thông tin cơ bản mà đối tượng commit lưu trữ cho bạn.

Để tạo một đối tượng commit, bạn gọi `commit-tree` và chỉ định một SHA-1 tree duy nhất và các đối tượng commit nào, nếu có, trực tiếp đứng trước nó.
Bắt đầu với tree đầu tiên bạn đã viết:

[source,console]
----
$ echo 'First commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
----

[NOTE]
====
Bạn sẽ nhận được một giá trị băm khác nhau vì thời gian tạo và dữ liệu tác giả khác nhau.
Hơn nữa, mặc dù về nguyên tắc bất kỳ đối tượng commit nào cũng có thể được tái tạo chính xác với dữ liệu đó, các chi tiết lịch sử về cấu trúc của cuốn sách này có nghĩa là các hàm băm commit được in có thể không tương ứng với các commit đã cho.
Thay thế các hàm băm commit và tag bằng tổng kiểm tra của riêng bạn trong chương này.
====

Bây giờ bạn có thể xem đối tượng commit mới của mình bằng `git cat-file`:

[source,console]
----
$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

First commit
----

Định dạng cho một đối tượng commit rất đơn giản: nó chỉ định tree cấp cao nhất cho ảnh chụp nhanh của dự án tại thời điểm đó; các commit cha mẹ nếu có (đối tượng commit được mô tả ở trên không có bất kỳ cha mẹ nào); thông tin tác giả/người commit (sử dụng các thiết lập cấu hình `user.name` và `user.email` của bạn và một dấu thời gian); một dòng trống, và sau đó là thông điệp commit.

Tiếp theo, bạn sẽ viết hai đối tượng commit khác, mỗi cái tham chiếu đến commit đến trực tiếp trước nó:

[source,console]
----
$ echo 'Second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'Third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
----

Mỗi trong ba đối tượng commit trỏ đến một trong ba tree ảnh chụp nhanh mà bạn đã tạo.
Kỳ lạ thay, bây giờ bạn có một lịch sử Git thực sự mà bạn có thể xem bằng lệnh `git log`, nếu bạn chạy nó trên SHA-1 commit cuối cùng:

[source,console]
----
$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

	Third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:14:29 2009 -0700

	Second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:09:34 2009 -0700

    First commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
----

Tuyệt vời.
Bạn vừa thực hiện các thao tác cấp thấp để xây dựng một lịch sử Git mà không sử dụng bất kỳ lệnh giao diện người dùng nào.
Đây về cơ bản là những gì Git làm khi bạn chạy các lệnh `git add` và `git commit` -- nó lưu trữ các blob cho các tập tin đã thay đổi, cập nhật index, ghi ra các tree, và ghi các đối tượng commit tham chiếu đến các tree cấp cao nhất và các commit đến ngay trước chúng.
Ba đối tượng Git chính này -- blob, tree, và commit -- ban đầu được lưu trữ dưới dạng các tập tin riêng biệt trong thư mục `.git/objects` của bạn.
Đây là tất cả các đối tượng trong thư mục ví dụ bây giờ, được chú thích với những gì chúng lưu trữ:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Nếu bạn theo dõi tất cả các con trỏ nội bộ, bạn sẽ có một đồ thị đối tượng giống như thế này:

.Tất cả các đối tượng có thể truy cập được trong thư mục Git của bạn
image::images/data-model-3.png[Tất cả các đối tượng có thể truy cập được trong thư mục Git của bạn]

==== Lưu trữ Đối tượng

Chúng tôi đã đề cập trước đó rằng có một tiêu đề được lưu trữ với mỗi đối tượng bạn commit vào cơ sở dữ liệu đối tượng Git của mình.
Hãy dành một phút để xem Git lưu trữ các đối tượng của nó như thế nào.
Bạn sẽ thấy cách lưu trữ một đối tượng blob -- trong trường hợp này, chuỗi "`what is up, doc?`" -- một cách tương tác trong ngôn ngữ kịch bản Ruby.

Bạn có thể khởi động chế độ Ruby tương tác bằng lệnh `irb`:

[source,console]
----
$ irb
>> content = "what is up, doc?"
=> "what is up, doc?"
----

Git đầu tiên xây dựng một tiêu đề bắt đầu bằng việc xác định loại đối tượng -- trong trường hợp này, là một blob.
Đối với phần đầu tiên của tiêu đề, Git thêm một khoảng trắng theo sau là kích thước tính bằng byte của nội dung, và thêm một byte null cuối cùng:

[source,console]
----
>> header = "blob #{content.bytesize}\0"
=> "blob 16\u0000"
----

Git nối tiêu đề và nội dung gốc và sau đó tính toán tổng kiểm tra SHA-1 của nội dung mới đó.
Bạn có thể tính toán giá trị SHA-1 của một chuỗi trong Ruby bằng cách bao gồm thư viện digest SHA1 với lệnh `require` và sau đó gọi `Digest::SHA1.hexdigest()` với chuỗi:

[source,console]
----
>> store = header + content
=> "blob 16\u0000what is up, doc?"
>> require 'digest/sha1'
=> true
>> sha1 = Digest::SHA1.hexdigest(store)
=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
----

Hãy so sánh điều đó với đầu ra của `git hash-object`.
Ở đây chúng ta sử dụng `echo -n` để ngăn thêm một dòng mới vào đầu vào.

[source,console]
----
$ echo -n "what is up, doc?" | git hash-object --stdin
bd9dbf5aae1a3862dd1526723246b20206e5fc37
----

Git nén nội dung mới với zlib, mà bạn có thể làm trong Ruby với thư viện zlib.
Đầu tiên, bạn cần require thư viện và sau đó chạy `Zlib::Deflate.deflate()` trên nội dung:

[source,console]
----
>> require 'zlib'
=> true
>> zlib_content = Zlib::Deflate.deflate(store)
=> "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
----

Cuối cùng, bạn sẽ ghi nội dung đã được nén zlib của mình vào một đối tượng trên đĩa.
Bạn sẽ xác định đường dẫn của đối tượng bạn muốn ghi ra (hai ký tự đầu tiên của giá trị SHA-1 là tên thư mục con, và 38 ký tự cuối cùng là tên tập tin trong thư mục đó).
Trong Ruby, bạn có thể sử dụng hàm `FileUtils.mkdir_p()` để tạo thư mục con nếu nó không tồn tại.
Sau đó, mở tập tin bằng `File.open()` và ghi nội dung đã được nén zlib trước đó vào tập tin bằng một lệnh gọi `write()` trên handle tập tin kết quả:

[source,console]
----
>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
>> require 'fileutils'
=> true
>> FileUtils.mkdir_p(File.dirname(path))
=> ".git/objects/bd"
>> File.open(path, 'w') { |f| f.write zlib_content }
=> 32
----

Hãy kiểm tra nội dung của đối tượng bằng cách sử dụng `git cat-file`:

[source,console]
---
$ git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37
what is up, doc?
---

Vậy là xong – bạn đã tạo một đối tượng blob Git hợp lệ.

Tất cả các đối tượng Git được lưu trữ theo cùng một cách, chỉ với các loại khác nhau – thay vì chuỗi blob, tiêu đề sẽ bắt đầu bằng commit hoặc tree.
Ngoài ra, mặc dù nội dung blob có thể là gần như bất cứ thứ gì, nội dung commit và tree được định dạng rất cụ thể.
