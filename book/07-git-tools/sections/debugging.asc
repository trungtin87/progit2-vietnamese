=== Gỡ lỗi với Git

Ngoài việc chủ yếu dùng để kiểm soát phiên bản, Git còn cung cấp một vài lệnh để giúp bạn gỡ lỗi các dự án mã nguồn của mình.
Vì Git được thiết kế để xử lý hầu hết mọi loại nội dung, các công cụ này khá chung chung, nhưng chúng thường có thể giúp bạn tìm kiếm lỗi hoặc thủ phạm khi mọi thứ không ổn.

[[_file_annotation]]
==== Chú thích Tệp

Nếu bạn tìm thấy một lỗi trong mã của mình và muốn biết nó được giới thiệu khi nào và tại sao, chú thích tệp thường là công cụ tốt nhất của bạn.
Nó cho bạn biết cam kết nào là cam kết cuối cùng đã sửa đổi mỗi dòng của bất kỳ tệp nào.
Vì vậy, nếu bạn thấy một phương thức trong mã của mình bị lỗi, bạn có thể chú thích tệp bằng `git blame` để xác định cam kết nào chịu trách nhiệm cho việc giới thiệu dòng đó.

Ví dụ sau sử dụng `git blame` để xác định cam kết và người cam kết nào chịu trách nhiệm cho các dòng trong `Makefile` cấp cao nhất của nhân Linux và, xa hơn, sử dụng tùy chọn `-L` để hạn chế đầu ra của chú thích đến các dòng 69 đến 82 của tệp đó:

[source,console]
----
$ git blame -L 69,82 Makefile
b8b0618cf6fab (Cheng Renquan  2009-05-26 16:03:07 +0800 69) ifeq ("$(origin V)", "command line")
b8b0618cf6fab (Cheng Renquan  2009-05-26 16:03:07 +0800 70)   KBUILD_VERBOSE = $(V)
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 71) endif
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 72) ifndef KBUILD_VERBOSE
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 73)   KBUILD_VERBOSE = 0
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 74) endif
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 75)
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 76) ifeq ($(KBUILD_VERBOSE),1)
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 77)   quiet =
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 78)   Q =
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 79) else
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 80)   quiet=quiet_
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 81)   Q = @
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 82) endif
----

Lưu ý rằng trường đầu tiên là SHA-1 một phần của cam kết cuối cùng đã sửa đổi dòng đó.
Hai trường tiếp theo là các giá trị được trích xuất từ cam kết đó -- tên tác giả và ngày tạo của cam kết đó -- vì vậy bạn có thể dễ dàng thấy ai đã sửa đổi dòng đó và khi nào.
Sau đó là số dòng và nội dung của tệp.
Cũng lưu ý các dòng cam kết `^1da177e4c3f4`, trong đó tiền tố `^` chỉ định các dòng được giới thiệu trong cam kết ban đầu của kho lưu trữ và vẫn không thay đổi kể từ đó.
Điều này hơi khó hiểu, bởi vì bây giờ bạn đã thấy ít nhất ba cách khác nhau mà Git sử dụng `^` để sửa đổi SHA-1 cam kết, nhưng đó là ý nghĩa của nó ở đây.

Một điều thú vị khác về Git là nó không theo dõi rõ ràng việc đổi tên tệp.
Nó ghi lại các ảnh chụp nhanh và sau đó cố gắng tìm ra những gì đã được đổi tên một cách ngầm định, sau đó.
Một trong những tính năng thú vị của điều này là bạn có thể yêu cầu nó tìm ra tất cả các loại chuyển động mã.
Nếu bạn truyền `-C` cho `git blame`, Git phân tích tệp bạn đang chú thích và cố gắng tìm ra các đoạn mã trong đó ban đầu đến từ đâu nếu chúng được sao chép từ nơi khác.
Ví dụ, giả sử bạn đang tái cấu trúc một tệp có tên `GITServerHandler.m` thành nhiều tệp, một trong số đó là `GITPackUpload.m`.
Bằng cách blame `GITPackUpload.m` với tùy chọn `-C`, bạn có thể thấy các phần của mã ban đầu đến từ đâu:

[source,console]
----
$ git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)
----

Điều này thực sự hữu ích.
Thông thường, bạn sẽ nhận được cam kết ban đầu là cam kết nơi bạn sao chép mã, bởi vì đó là lần đầu tiên bạn chạm vào các dòng đó trong tệp này.
Git cho bạn biết cam kết ban đầu nơi bạn đã viết các dòng đó, ngay cả khi nó nằm trong một tệp khác.

[[_binary_search]]
==== Tìm kiếm Nhị phân

Chú thích tệp hữu ích nếu bạn biết vấn đề ở đâu ngay từ đầu.
Nếu bạn không biết điều gì đang gây ra lỗi, và đã có hàng chục hoặc hàng trăm cam kết kể từ trạng thái cuối cùng mà bạn biết mã hoạt động, bạn có thể sẽ tìm đến `git bisect` để được trợ giúp.
Lệnh `bisect` thực hiện tìm kiếm nhị phân trong lịch sử cam kết của bạn để giúp bạn xác định càng nhanh càng tốt cam kết nào đã giới thiệu một vấn đề.

Giả sử bạn vừa đẩy một bản phát hành mã của mình lên môi trường sản xuất, bạn đang nhận được báo cáo lỗi về điều gì đó không xảy ra trong môi trường phát triển của bạn, và bạn không thể tưởng tượng tại sao mã lại làm điều đó.
Bạn quay lại mã của mình, và hóa ra bạn có thể tái hiện vấn đề, nhưng bạn không thể tìm ra điều gì đang xảy ra.
Bạn có thể _chia đôi_ mã để tìm hiểu.
Đầu tiên bạn chạy `git bisect start` để bắt đầu, và sau đó bạn sử dụng `git bisect bad` để thông báo cho hệ thống rằng cam kết hiện tại bạn đang ở bị lỗi.
Sau đó, bạn phải cho bisect biết trạng thái tốt cuối cùng được biết là khi nào, sử dụng `git bisect good <good_commit>`:

[source,console]
----
$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] Error handling on repo
----

Git đã tìm ra rằng khoảng 12 cam kết nằm giữa cam kết bạn đã đánh dấu là cam kết tốt cuối cùng (v1.0) và phiên bản lỗi hiện tại, và nó đã kiểm tra cam kết ở giữa cho bạn.
Tại thời điểm này, bạn có thể chạy thử nghiệm của mình để xem liệu vấn đề có tồn tại tại cam kết này hay không.
Nếu có, thì nó đã được giới thiệu vào một thời điểm nào đó trước cam kết ở giữa này; nếu không, thì vấn đề đã được giới thiệu vào một thời điểm nào đó sau cam kết ở giữa này.
Hóa ra không có vấn đề gì ở đây, và bạn thông báo cho Git điều đó bằng cách gõ `git bisect good` và tiếp tục hành trình của bạn:

[source,console]
----
$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] Secure this thing
----

Bây giờ bạn đang ở trên một cam kết khác, nằm giữa cam kết bạn vừa kiểm tra và cam kết lỗi của bạn.
Bạn chạy thử nghiệm của mình một lần nữa và thấy rằng cam kết này bị lỗi, vì vậy bạn thông báo cho Git điều đó bằng `git bisect bad`:

[source,console]
----
$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] Drop exceptions table
----

Cam kết này tốt, và bây giờ Git có tất cả thông tin cần thiết để xác định vấn đề đã được giới thiệu ở đâu.
Nó cho bạn biết SHA-1 của cam kết lỗi đầu tiên và hiển thị một số thông tin cam kết và những tệp nào đã được sửa đổi trong cam kết đó để bạn có thể tìm ra điều gì đã xảy ra có thể đã giới thiệu lỗi này:

[source,console]
----
$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett <pjhyett@example.com>
Date:   Tue Jan 27 14:48:32 2009 -0800

    Secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config
----

Khi bạn hoàn tất, bạn nên chạy `git bisect reset` để đặt lại HEAD của bạn về nơi bạn đã ở trước khi bạn bắt đầu, nếu không bạn sẽ ở trạng thái kỳ lạ:

[source,console]
----
$ git bisect reset
----

Đây là một công cụ mạnh mẽ có thể giúp bạn kiểm tra hàng trăm cam kết để tìm một lỗi được giới thiệu trong vài phút.
Trên thực tế, nếu bạn có một tập lệnh sẽ thoát 0 nếu dự án tốt hoặc khác 0 nếu dự án xấu, bạn có thể tự động hóa hoàn toàn `git bisect`.
Đầu tiên, bạn lại cho nó biết phạm vi của bisect bằng cách cung cấp các cam kết xấu và tốt đã biết.
Bạn có thể làm điều này bằng cách liệt kê chúng với lệnh `bisect start` nếu bạn muốn, liệt kê cam kết xấu đã biết trước và cam kết tốt đã biết thứ hai:

[source,console]
----
$ git bisect start HEAD v1.0
$ git bisect run test-error.sh
----

Làm như vậy tự động chạy `test-error.sh` trên mỗi cam kết đã kiểm tra cho đến khi Git tìm thấy cam kết bị lỗi đầu tiên.
Bạn cũng có thể chạy một cái gì đó như `make` hoặc `make tests` hoặc bất cứ thứ gì bạn có để chạy các bài kiểm tra tự động cho bạn.