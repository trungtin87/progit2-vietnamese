[[_revision_selection]]
=== Chọn Phiên bản (Revision Selection)

Git cho phép bạn tham chiếu đến một commit đơn lẻ, một tập hợp các commit, hoặc một khoảng các commit theo nhiều cách.
Chúng không nhất thiết phải rõ ràng nhưng rất hữu ích để biết.

==== Các Phiên bản Đơn lẻ

Bạn rõ ràng có thể tham chiếu đến bất kỳ commit đơn lẻ nào bằng mã băm SHA-1 đầy đủ, 40 ký tự của nó, nhưng cũng có những cách thân thiện với con người hơn để tham chiếu đến các commit.
Phần này phác thảo các cách khác nhau mà bạn có thể tham chiếu đến bất kỳ commit nào.

==== SHA-1 Ngắn

Git đủ thông minh để tìm ra commit nào bạn đang tham chiếu đến nếu bạn cung cấp một vài ký tự đầu tiên của mã băm SHA-1, miễn là mã băm một phần đó dài ít nhất bốn ký tự và không mơ hồ; nghĩa là, không có đối tượng nào khác trong cơ sở dữ liệu đối tượng có mã băm bắt đầu bằng cùng một tiền tố.

Ví dụ, để kiểm tra một commit cụ thể mà bạn biết bạn đã thêm chức năng nhất định, bạn có thể chạy lệnh `git log` trước để xác định vị trí commit:

[source,console]
----
$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    Fix refs handling, add gc auto, update tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    Add some blame and merge stuff
----

Trong trường hợp này, giả sử bạn quan tâm đến commit có mã băm bắt đầu bằng `1c002dd...`.
Bạn có thể kiểm tra commit đó với bất kỳ biến thể nào sau đây của `git show` (giả sử các phiên bản ngắn hơn là không mơ hồ):

[source,console]
----
$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
----

Git có thể tìm ra một từ viết tắt ngắn, duy nhất cho các giá trị SHA-1 của bạn.
Nếu bạn truyền `--abbrev-commit` cho lệnh `git log`, đầu ra sẽ sử dụng các giá trị ngắn hơn nhưng giữ cho chúng là duy nhất; nó mặc định sử dụng bảy ký tự nhưng làm cho chúng dài hơn nếu cần thiết để giữ cho SHA-1 không bị mơ hồ:

[source,console]
----
$ git log --abbrev-commit --pretty=oneline
ca82a6d Change the version number
085bb3b Remove unnecessary test code
a11bef0 Initial commit
----

Nói chung, tám đến mười ký tự là quá đủ để trở nên duy nhất trong một dự án.
Ví dụ, tính đến tháng 2 năm 2019, hạt nhân Linux (là một dự án khá lớn) có hơn 875.000 commit và gần bảy triệu đối tượng trong cơ sở dữ liệu đối tượng của nó, mà không có hai đối tượng nào có SHA-1 giống hệt nhau trong 12 ký tự đầu tiên.

[NOTE]
.MỘT LƯU Ý NGẮN VỀ SHA-1
====

Nhiều người trở nên lo lắng tại một thời điểm nào đó rằng họ sẽ, do ngẫu nhiên, có hai đối tượng riêng biệt trong kho lưu trữ của họ có cùng giá trị băm SHA-1.
Vậy thì sao?

Nếu bạn thực sự commit một đối tượng có cùng giá trị băm SHA-1 với một đối tượng _khác_ trước đó trong kho lưu trữ của bạn, Git sẽ thấy đối tượng trước đó đã có trong cơ sở dữ liệu Git của bạn, cho rằng nó đã được ghi và đơn giản là sử dụng lại nó.
Nếu bạn cố gắng checkout đối tượng đó một lần nữa tại một thời điểm nào đó, bạn sẽ luôn nhận được dữ liệu của đối tượng đầu tiên.

Tuy nhiên, bạn nên biết kịch bản này khó xảy ra đến mức nực cười như thế nào.
Bản tóm tắt SHA-1 dài 20 byte hoặc 160 bit.
Số lượng đối tượng được băm ngẫu nhiên cần thiết để đảm bảo xác suất 50% của một va chạm đơn lẻ là khoảng 2^80^ (công thức để xác định xác suất va chạm là `p = (n(n-1)/2) * (1/2^160)`).
2^80^ là 1,2 x 10^24^ hoặc 1 triệu tỷ tỷ.
Đó là gấp 1.200 lần số lượng hạt cát trên trái đất.

Đây là một ví dụ để cung cấp cho bạn một ý tưởng về những gì cần thiết để có được một va chạm SHA-1.
Nếu tất cả 6,5 tỷ người trên Trái đất đều đang lập trình, và mỗi giây, mỗi người đều tạo ra mã tương đương với toàn bộ lịch sử hạt nhân Linux (6,5 triệu đối tượng Git) và đẩy nó vào một kho lưu trữ Git khổng lồ, sẽ mất khoảng 2 năm cho đến khi kho lưu trữ đó chứa đủ các đối tượng để có xác suất 50% của một va chạm đối tượng SHA-1 đơn lẻ.
Do đó, một va chạm SHA-1 hữu cơ ít có khả năng xảy ra hơn việc mọi thành viên trong nhóm lập trình của bạn bị tấn công và giết bởi những con sói trong các sự cố không liên quan vào cùng một đêm.

Nếu bạn dành vài nghìn đô la sức mạnh tính toán cho nó, có thể tổng hợp hai tệp có cùng mã băm, như đã được chứng minh trên https://shattered.io/[^] vào tháng 2 năm 2017.
Git đang chuyển sang sử dụng SHA256 làm thuật toán băm mặc định, thuật toán này có khả năng chống lại các cuộc tấn công va chạm tốt hơn nhiều, và có mã tại chỗ để giúp giảm thiểu cuộc tấn công này (mặc dù nó không thể loại bỏ hoàn toàn nó).
====

[[_branch_references]]
==== Tham chiếu Nhánh

Một cách đơn giản để tham chiếu đến một commit cụ thể là nếu nó là commit ở đầu của một nhánh; trong trường hợp đó, bạn có thể đơn giản sử dụng tên nhánh trong bất kỳ lệnh Git nào mong đợi một tham chiếu đến một commit.
Ví dụ, nếu bạn muốn kiểm tra đối tượng commit cuối cùng trên một nhánh, các lệnh sau là tương đương, giả sử rằng nhánh `topic1` trỏ đến commit `ca82a6d...`:

[source,console]
----
$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
----

Nếu bạn muốn xem SHA-1 cụ thể nào mà một nhánh trỏ đến, hoặc nếu bạn muốn xem bất kỳ ví dụ nào trong số này rút gọn lại thành gì về mặt SHA-1, bạn có thể sử dụng một công cụ cấp thấp (plumbing tool) của Git gọi là `rev-parse`.
Bạn có thể xem <<ch10-git-internals#ch10-git-internals>> để biết thêm thông tin về các công cụ cấp thấp; về cơ bản, `rev-parse` tồn tại cho các hoạt động cấp thấp hơn và không được thiết kế để sử dụng trong các hoạt động hàng ngày.
Tuy nhiên, đôi khi nó có thể hữu ích khi bạn cần xem những gì thực sự đang diễn ra.
Ở đây bạn có thể chạy `rev-parse` trên nhánh của mình.

[source,console]
----
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
----

[[_git_reflog]]
==== Tên ngắn RefLog

Một trong những điều Git làm trong nền trong khi bạn đang làm việc là giữ một "`reflog`" -- một nhật ký về nơi các tham chiếu HEAD và nhánh của bạn đã ở trong vài tháng qua.

Bạn có thể xem reflog của mình bằng cách sử dụng `git reflog`:

[source,console]
----
$ git reflog
734713b HEAD@{0}: commit: Fix refs handling, add gc auto, update tests
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.
1c002dd HEAD@{2}: commit: Add some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
----

Mỗi khi đầu nhánh của bạn được cập nhật vì bất kỳ lý do gì, Git lưu trữ thông tin đó cho bạn trong lịch sử tạm thời này.
Bạn cũng có thể sử dụng dữ liệu reflog của mình để tham chiếu đến các commit cũ hơn.
Ví dụ, nếu bạn muốn xem giá trị thứ năm trước đó của HEAD của kho lưu trữ của bạn, bạn có thể sử dụng tham chiếu `@{5}` mà bạn thấy trong đầu ra reflog:

[source,console]
----
$ git show HEAD@{5}
----

Bạn cũng có thể sử dụng cú pháp này để xem một nhánh đã ở đâu một khoảng thời gian cụ thể trước đây.
Ví dụ, để xem nhánh `master` của bạn đã ở đâu ngày hôm qua, bạn có thể gõ:

[source,console]
----
$ git show master@{yesterday}
----

Điều đó sẽ cho bạn thấy đầu của nhánh `master` của bạn đã ở đâu ngày hôm qua.
Kỹ thuật này chỉ hoạt động đối với dữ liệu vẫn còn trong reflog của bạn, vì vậy bạn không thể sử dụng nó để tìm các commit cũ hơn vài tháng.

Để xem thông tin reflog được định dạng giống như đầu ra `git log`, bạn có thể chạy `git log -g`:

[source,console]
----
$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: Fix refs handling, add gc auto, update tests
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    Fix refs handling, add gc auto, update tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

Điều quan trọng cần lưu ý là thông tin reflog hoàn toàn là cục bộ -- nó là một nhật ký chỉ về những gì _bạn_ đã làm trong kho lưu trữ _của bạn_.
Các tham chiếu sẽ không giống nhau trên bản sao kho lưu trữ của người khác; ngoài ra, ngay sau khi bạn sao chép (clone) một kho lưu trữ ban đầu, bạn sẽ có một reflog trống, vì chưa có hoạt động nào xảy ra trong kho lưu trữ của bạn.
Chạy `git show HEAD@{2.months.ago}` sẽ chỉ hiển thị cho bạn commit phù hợp nếu bạn đã sao chép dự án ít nhất hai tháng trước -- nếu bạn sao chép nó gần đây hơn thế, bạn sẽ chỉ thấy commit cục bộ đầu tiên của mình.

[TIP]
.Hãy nghĩ về reflog như phiên bản lịch sử shell của Git
====
Nếu bạn có nền tảng UNIX hoặc Linux, bạn có thể nghĩ về reflog như phiên bản lịch sử shell của Git, điều này nhấn mạnh rằng những gì ở đó rõ ràng chỉ liên quan đến bạn và "`phiên làm việc`" của bạn, và không liên quan gì đến bất kỳ ai khác có thể đang làm việc trên cùng một máy.
====

[NOTE]
.Thoát các dấu ngoặc nhọn trong PowerShell
====

Khi sử dụng PowerShell, các dấu ngoặc nhọn như `{` và `}` là các ký tự đặc biệt và phải được thoát (escape).
Bạn có thể thoát chúng bằng một dấu huyền (backtick) ` hoặc đặt tham chiếu commit trong dấu ngoặc kép:

[source,console]
----
$ git show HEAD@{0}     # sẽ KHÔNG hoạt động
$ git show HEAD@`{0`}   # OK
$ git show "HEAD@{0}"   # OK
----

====

==== Tham chiếu Tổ tiên

Cách chính khác để chỉ định một commit là thông qua tổ tiên của nó.
Nếu bạn đặt một dấu mũ `^` (caret) ở cuối một tham chiếu, Git giải quyết nó có nghĩa là cha mẹ của commit đó.
Giả sử bạn xem lịch sử của dự án của mình:

[source,console]
----
$ git log --pretty=format:'%h %s' --graph
* 734713b Fix refs handling, add gc auto, update tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd Add some blame and merge stuff
|/
* 1c36188 Ignore *.gem
* 9b29157 Add open3_detach to gemspec file list
----

Sau đó, bạn có thể xem commit trước đó bằng cách chỉ định `HEAD^`, có nghĩa là "`cha mẹ của HEAD`":

[source,console]
----
$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

[NOTE]
.Thoát dấu mũ trên Windows
====

Trên Windows trong `cmd.exe`, `^` là một ký tự đặc biệt và cần được xử lý khác.
Bạn có thể nhân đôi nó hoặc đặt tham chiếu commit trong dấu ngoặc kép:

[source,console]
----
$ git show HEAD^     # sẽ KHÔNG hoạt động trên Windows
$ git show HEAD^^    # OK
$ git show "HEAD^"   # OK
----

====

Bạn cũng có thể chỉ định một số sau `^` để xác định cha mẹ _nào_ bạn muốn; ví dụ, `d921970^2` có nghĩa là "`cha mẹ thứ hai của d921970.`"
Cú pháp này chỉ hữu ích cho các commit hợp nhất (merge commit), có nhiều hơn một cha mẹ -- cha mẹ _đầu tiên_ của một commit hợp nhất là từ nhánh bạn đang ở khi bạn hợp nhất (thường là `master`), trong khi cha mẹ _thứ hai_ của một commit hợp nhất là từ nhánh đã được hợp nhất (ví dụ, `topic`):

[source,console]
----
$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    Add some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
----

Đặc tả tổ tiên chính khác là dấu ngã `~` (tilde).
Điều này cũng tham chiếu đến cha mẹ đầu tiên, vì vậy `HEAD~` và `HEAD^` là tương đương.
Sự khác biệt trở nên rõ ràng khi bạn chỉ định một số.
`HEAD~2` có nghĩa là "`cha mẹ đầu tiên của cha mẹ đầu tiên,`" hoặc "`ông bà`" -- nó duyệt qua các cha mẹ đầu tiên số lần bạn chỉ định.
Ví dụ, trong lịch sử được liệt kê trước đó, `HEAD~3` sẽ là:

[source,console]
----
$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    Ignore *.gem
----

Điều này cũng có thể được viết là `HEAD\~~~`, một lần nữa là cha mẹ đầu tiên của cha mẹ đầu tiên của cha mẹ đầu tiên:

[source,console]
----
$ git show HEAD~~~
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    Ignore *.gem
----

Bạn cũng có thể kết hợp các cú pháp này -- bạn có thể lấy cha mẹ thứ hai của tham chiếu trước đó (giả sử đó là một commit hợp nhất) bằng cách sử dụng `HEAD~3^2`, v.v.

[[_commit_ranges]]
==== Khoảng Commit

Bây giờ bạn có thể chỉ định các commit riêng lẻ, hãy xem cách chỉ định các khoảng commit.
Điều này đặc biệt hữu ích để quản lý các nhánh của bạn -- nếu bạn có nhiều nhánh, bạn có thể sử dụng các đặc tả khoảng để trả lời các câu hỏi như, "`Công việc nào đang ở trên nhánh này mà tôi chưa hợp nhất vào nhánh chính của mình?`"

===== Hai Chấm (Double Dot)

Đặc tả khoảng phổ biến nhất là cú pháp hai chấm.
Điều này về cơ bản yêu cầu Git giải quyết một khoảng các commit có thể truy cập được từ một commit nhưng không thể truy cập được từ một commit khác.
Ví dụ, giả sử bạn có một lịch sử commit trông giống như <<double_dot>>.

[[double_dot]]
.Lịch sử ví dụ cho việc chọn khoảng
image::images/double-dot.png[Lịch sử ví dụ cho việc chọn khoảng]

Giả sử bạn muốn xem những gì có trong nhánh `experiment` của mình mà chưa được hợp nhất vào nhánh `master` của bạn.
Bạn có thể yêu cầu Git hiển thị cho bạn một nhật ký chỉ các commit đó với `master..experiment` -- điều đó có nghĩa là "`tất cả các commit có thể truy cập được từ `experiment` mà không thể truy cập được từ `master`.`"
Vì mục đích ngắn gọn và rõ ràng trong các ví dụ này, các chữ cái của các đối tượng commit từ sơ đồ được sử dụng thay cho đầu ra nhật ký thực tế theo thứ tự mà chúng sẽ hiển thị:

[source,console]
----
$ git log master..experiment
D
C
----

Mặt khác, nếu bạn muốn xem điều ngược lại -- tất cả các commit trong `master` mà không có trong `experiment` -- bạn có thể đảo ngược tên các nhánh.
`experiment..master` hiển thị cho bạn mọi thứ trong `master` không thể truy cập được từ `experiment`:

[source,console]
----
$ git log experiment..master
F
E
----

Điều này hữu ích nếu bạn muốn giữ cho nhánh `experiment` được cập nhật và xem trước những gì bạn sắp hợp nhất.
Một cách sử dụng thường xuyên khác của cú pháp này là để xem những gì bạn sắp đẩy lên một điều khiển từ xa (remote):

[source,console]
----
$ git log origin/master..HEAD
----

Lệnh này hiển thị cho bạn bất kỳ commit nào trong nhánh hiện tại của bạn mà không có trong nhánh `master` trên điều khiển từ xa `origin` của bạn.
Nếu bạn chạy `git push` và nhánh hiện tại của bạn đang theo dõi `origin/master`, các commit được liệt kê bởi `git log origin/master..HEAD` là các commit sẽ được chuyển đến máy chủ.
Bạn cũng có thể bỏ qua một bên của cú pháp để Git giả định là `HEAD`.
Ví dụ, bạn có thể nhận được kết quả tương tự như trong ví dụ trước bằng cách gõ `git log origin/master..` -- Git thay thế `HEAD` nếu thiếu một bên.

===== Nhiều Điểm

Cú pháp hai chấm rất hữu ích như một cách viết tắt, nhưng có lẽ bạn muốn chỉ định nhiều hơn hai nhánh để chỉ định phiên bản của mình, chẳng hạn như xem những commit nào có trong bất kỳ nhánh nào trong số nhiều nhánh mà không có trong nhánh bạn đang ở.
Git cho phép bạn làm điều này bằng cách sử dụng ký tự `^` hoặc `--not` trước bất kỳ tham chiếu nào mà từ đó bạn không muốn xem các commit có thể truy cập được.
Do đó, ba lệnh sau là tương đương:

[source,console]
----
$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
----

Điều này rất hay vì với cú pháp này, bạn có thể chỉ định nhiều hơn hai tham chiếu trong truy vấn của mình, điều mà bạn không thể làm với cú pháp hai chấm.
Ví dụ, nếu bạn muốn xem tất cả các commit có thể truy cập được từ `refA` hoặc `refB` nhưng không phải từ `refC`, bạn có thể sử dụng một trong hai lệnh sau:

[source,console]
----
$ git log refA refB ^refC
$ git log refA refB --not refC
----

Điều này tạo nên một hệ thống truy vấn phiên bản rất mạnh mẽ sẽ giúp bạn tìm ra những gì có trong các nhánh của mình.

[[_triple_dot]]
===== Ba Chấm (Triple Dot)

Cú pháp chọn khoảng chính cuối cùng là cú pháp ba chấm, chỉ định tất cả các commit có thể truy cập được bởi _một trong hai_ tham chiếu nhưng không phải bởi cả hai.
Nhìn lại lịch sử commit ví dụ trong <<double_dot>>.
Nếu bạn muốn xem những gì có trong `master` hoặc `experiment` nhưng không phải bất kỳ tham chiếu chung nào, bạn có thể chạy:

[source,console]
----
$ git log master...experiment
F
E
D
C
----

Một lần nữa, điều này cung cấp cho bạn đầu ra `log` bình thường nhưng chỉ hiển thị cho bạn thông tin commit cho bốn commit đó, xuất hiện theo thứ tự ngày commit truyền thống.

Một chuyển đổi phổ biến để sử dụng với lệnh `log` trong trường hợp này là `--left-right`, hiển thị cho bạn mỗi commit nằm ở phía nào của khoảng.
Điều này giúp làm cho đầu ra hữu ích hơn:

[source,console]
----
$ git log --left-right master...experiment
< F
< E
> D
> C
----

Với các công cụ này, bạn có thể dễ dàng hơn nhiều để cho Git biết commit hoặc các commit nào bạn muốn kiểm tra.
