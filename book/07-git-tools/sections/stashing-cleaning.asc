[[_git_stashing]]
=== Cất giấu và Làm sạch (Stashing and Cleaning)

Thường thì, khi bạn đang làm việc trên một phần của dự án, mọi thứ đang ở trong trạng thái lộn xộn và bạn muốn chuyển sang các nhánh khác một chút để làm việc khác.
Vấn đề là, bạn không muốn thực hiện một commit cho công việc còn dang dở chỉ để bạn có thể quay lại điểm này sau.
Câu trả lời cho vấn đề này là lệnh `git stash`.

Cất giấu (Stashing) lấy trạng thái bẩn của thư mục làm việc của bạn -- nghĩa là, các tệp được theo dõi đã sửa đổi và các thay đổi đã tổ chức của bạn -- và lưu nó vào một ngăn xếp các thay đổi chưa hoàn thành mà bạn có thể áp dụng lại bất cứ lúc nào (ngay cả trên một nhánh khác).

[NOTE]
.Di chuyển sang `git stash push`
====
Kể từ cuối tháng 10 năm 2017, đã có cuộc thảo luận rộng rãi trên danh sách gửi thư Git, trong đó lệnh `git stash save` đang bị phản đối để ủng hộ giải pháp thay thế hiện có `git stash push`.
Lý do chính cho điều này là `git stash push` giới thiệu tùy chọn cất giấu các _đặc tả đường dẫn_ (pathspecs) đã chọn, điều mà `git stash save` không hỗ trợ.

`git stash save` sẽ không biến mất sớm, vì vậy đừng lo lắng về việc nó đột ngột biến mất.
Nhưng bạn có thể muốn bắt đầu chuyển sang giải pháp thay thế `push` cho chức năng mới.
====

==== Cất giấu Công việc của Bạn

Để minh họa việc cất giấu, bạn sẽ vào dự án của mình và bắt đầu làm việc trên một vài tệp và có thể tổ chức một trong những thay đổi.
Nếu bạn chạy `git status`, bạn có thể thấy trạng thái bẩn của mình:

[source,console]
----
$ git status
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

Bây giờ bạn muốn chuyển nhánh, nhưng bạn chưa muốn commit những gì bạn đang làm việc, vì vậy bạn sẽ cất giấu các thay đổi.
Để đẩy một stash mới vào ngăn xếp của bạn, hãy chạy `git stash` hoặc `git stash push`:

[source,console]
----
$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 Create index file"
HEAD is now at 049d078 Create index file
(To restore them type "git stash apply")
----

Bây giờ bạn có thể thấy rằng thư mục làm việc của bạn đã sạch:

[source,console]
----
$ git status
# On branch master
nothing to commit, working directory clean
----

Tại thời điểm này, bạn có thể chuyển nhánh và làm việc ở nơi khác; các thay đổi của bạn được lưu trữ trên ngăn xếp của bạn.
Để xem những stash nào bạn đã lưu trữ, bạn có thể sử dụng `git stash list`:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 Create index file
stash@{1}: WIP on master: c264051 Revert "Add file_size"
stash@{2}: WIP on master: 21d80a5 Add number to log
----

Trong trường hợp này, hai stash đã được lưu trước đó, vì vậy bạn có quyền truy cập vào ba công việc được cất giấu khác nhau.
Bạn có thể áp dụng lại cái bạn vừa cất giấu bằng cách sử dụng lệnh được hiển thị trong đầu ra trợ giúp của lệnh stash ban đầu: `git stash apply`.
Nếu bạn muốn áp dụng một trong những stash cũ hơn, bạn có thể chỉ định nó bằng cách đặt tên cho nó, như thế này: `git stash apply stash@{2}`.
Nếu bạn không chỉ định một stash, Git giả định stash gần đây nhất và cố gắng áp dụng nó:

[source,console]
----
$ git stash apply
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   index.html
	modified:   lib/simplegit.rb

no changes added to commit (use "git add" and/or "git commit -a")
----

Bạn có thể thấy rằng Git sửa đổi lại các tệp bạn đã hoàn nguyên khi bạn lưu stash.
Trong trường hợp này, bạn đã có một thư mục làm việc sạch khi bạn cố gắng áp dụng stash, và bạn đã cố gắng áp dụng nó trên cùng một nhánh bạn đã lưu nó.
Việc có một thư mục làm việc sạch và áp dụng nó trên cùng một nhánh là không cần thiết để áp dụng thành công một stash.
Bạn có thể lưu một stash trên một nhánh, chuyển sang một nhánh khác sau đó, và cố gắng áp dụng lại các thay đổi.
Bạn cũng có thể có các tệp đã sửa đổi và chưa commit trong thư mục làm việc của mình khi bạn áp dụng một stash -- Git cung cấp cho bạn các xung đột hợp nhất nếu bất cứ điều gì không còn áp dụng sạch sẽ nữa.

Các thay đổi đối với các tệp của bạn đã được áp dụng lại, nhưng tệp bạn đã tổ chức trước đó không được tổ chức lại.
Để làm điều đó, bạn phải chạy lệnh `git stash apply` với tùy chọn `--index` để bảo lệnh cố gắng áp dụng lại các thay đổi đã tổ chức.
Nếu bạn đã chạy lệnh đó thay thế, bạn sẽ quay lại vị trí ban đầu của mình:

[source,console]
----
$ git stash apply --index
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

Tùy chọn `apply` chỉ cố gắng áp dụng công việc đã cất giấu -- bạn vẫn giữ nó trên ngăn xếp của mình.
Để xóa nó, bạn có thể chạy `git stash drop` với tên của stash cần xóa:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 Create index file
stash@{1}: WIP on master: c264051 Revert "Add file_size"
stash@{2}: WIP on master: 21d80a5 Add number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
----

Bạn cũng có thể chạy `git stash pop` để áp dụng stash và sau đó ngay lập tức xóa nó khỏi ngăn xếp của bạn.

==== Cất giấu Sáng tạo

Có một vài biến thể stash cũng có thể hữu ích.
Tùy chọn đầu tiên khá phổ biến là tùy chọn `--keep-index` cho lệnh `git stash`.
Điều này bảo Git không chỉ bao gồm tất cả nội dung đã tổ chức trong stash đang được tạo, mà đồng thời để lại nó trong chỉ mục (index).

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html
----

Một điều phổ biến khác bạn có thể muốn làm với stash là cất giấu các tệp không được theo dõi cũng như các tệp được theo dõi.
Theo mặc định, `git stash` sẽ chỉ cất giấu các tệp _được theo dõi_ đã sửa đổi và đã tổ chức.
Nếu bạn chỉ định `--include-untracked` hoặc `-u`, Git sẽ bao gồm các tệp không được theo dõi trong stash đang được tạo.
Tuy nhiên, việc bao gồm các tệp không được theo dõi trong stash vẫn sẽ không bao gồm các tệp bị _bỏ qua_ một cách rõ ràng; để bao gồm thêm các tệp bị bỏ qua, hãy sử dụng `--all` (hoặc chỉ `-a`).

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$
----

Cuối cùng, nếu bạn chỉ định cờ `--patch`, Git sẽ không cất giấu mọi thứ bị sửa đổi mà thay vào đó sẽ nhắc bạn một cách tương tác xem thay đổi nào bạn muốn cất giấu và thay đổi nào bạn muốn giữ trong thư mục làm việc của mình.

[source,console]
----
$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file
----

==== Tạo một Nhánh từ một Stash

Nếu bạn cất giấu một số công việc, để nó ở đó một thời gian, và tiếp tục trên nhánh mà bạn đã cất giấu công việc, bạn có thể gặp vấn đề khi áp dụng lại công việc.
Nếu việc áp dụng cố gắng sửa đổi một tệp mà bạn đã sửa đổi kể từ đó, bạn sẽ nhận được xung đột hợp nhất và sẽ phải cố gắng giải quyết nó.
Nếu bạn muốn một cách dễ dàng hơn để kiểm tra lại các thay đổi đã cất giấu, bạn có thể chạy `git stash branch <tên nhánh mới>`, lệnh này tạo một nhánh mới cho bạn với tên nhánh bạn đã chọn, checkout commit bạn đang ở khi bạn cất giấu công việc của mình, áp dụng lại công việc của bạn ở đó, và sau đó xóa stash nếu nó áp dụng thành công:

[source,console]
----
$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)
----

Đây là một phím tắt hay để khôi phục công việc đã cất giấu một cách dễ dàng và làm việc trên nó trong một nhánh mới.

[[_git_clean]]
==== Làm sạch Thư mục Làm việc của bạn

Cuối cùng, bạn có thể không muốn cất giấu một số công việc hoặc tệp trong thư mục làm việc của mình, mà chỉ đơn giản là loại bỏ chúng; đó là mục đích của lệnh `git clean`.

Một số lý do phổ biến để làm sạch thư mục làm việc của bạn có thể là để loại bỏ rác đã được tạo ra bởi các lần hợp nhất hoặc các công cụ bên ngoài hoặc để loại bỏ các tạo phẩm xây dựng (build artifacts) để chạy một bản build sạch.

Bạn sẽ muốn khá cẩn thận với lệnh này, vì nó được thiết kế để xóa các tệp khỏi thư mục làm việc của bạn mà không được theo dõi.
Nếu bạn thay đổi ý định, thường không có cách nào lấy lại nội dung của các tệp đó.
Một tùy chọn an toàn hơn là chạy `git stash --all` để xóa mọi thứ nhưng lưu nó trong một stash.

Giả sử bạn thực sự muốn xóa các tệp rác hoặc làm sạch thư mục làm việc của mình, bạn có thể làm như vậy với `git clean`.
Để xóa tất cả các tệp không được theo dõi trong thư mục làm việc của bạn, bạn có thể chạy `git clean -f -d`, lệnh này xóa bất kỳ tệp nào và cũng xóa bất kỳ thư mục con nào trở nên trống rỗng do kết quả đó.
`-f` có nghĩa là 'force' (buộc) hoặc "`thực sự làm điều này,`" và là bắt buộc nếu biến cấu hình Git `clean.requireForce` không được đặt rõ ràng là false.

Nếu bạn muốn xem nó sẽ làm gì, bạn có thể chạy lệnh với tùy chọn `--dry-run` (hoặc `-n`), có nghĩa là "`chạy thử và cho tôi biết bạn _sẽ_ xóa những gì`".

[source,console]
----
$ git clean -d -n
Would remove test.o
Would remove tmp/
----

Theo mặc định, lệnh `git clean` sẽ chỉ xóa các tệp không được theo dõi mà không bị bỏ qua.
Bất kỳ tệp nào khớp với một mẫu trong `.gitignore` hoặc các tệp bỏ qua khác của bạn sẽ không bị xóa.
Nếu bạn muốn xóa cả những tệp đó, chẳng hạn như để xóa tất cả các tệp `.o` được tạo ra từ một bản build để bạn có thể thực hiện một bản build hoàn toàn sạch, bạn có thể thêm `-x` vào lệnh `clean`.

[source,console]
----
$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/
----

Nếu bạn không biết lệnh `git clean` sẽ làm gì, hãy luôn chạy nó với `-n` trước để kiểm tra kỹ trước khi thay đổi `-n` thành `-f` và thực hiện nó thực sự.
Cách khác bạn có thể cẩn thận về quy trình là chạy nó với cờ `-i` hoặc "`interactive`" (tương tác).

Điều này sẽ chạy lệnh `clean` trong chế độ tương tác.

[source,console]
----
$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>
----

Bằng cách này, bạn có thể bước qua từng tệp riêng lẻ hoặc chỉ định các mẫu để xóa một cách tương tác.

[NOTE]
====
Có một tình huống kỳ quặc mà bạn có thể cần phải cực kỳ mạnh mẽ trong việc yêu cầu Git làm sạch thư mục làm việc của bạn.
Nếu bạn tình cờ ở trong một thư mục làm việc mà dưới đó bạn đã sao chép hoặc clone các kho lưu trữ Git khác (có lẽ là dưới dạng các mô-đun con), ngay cả `git clean -fd` cũng sẽ từ chối xóa các thư mục đó.
Trong những trường hợp như vậy, bạn cần thêm tùy chọn `-f` thứ hai để nhấn mạnh.
====
