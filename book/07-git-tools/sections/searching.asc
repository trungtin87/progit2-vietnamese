[[_searching]]
=== Tìm kiếm (Searching)

Với bất kỳ cơ sở mã nào có kích thước bất kỳ, bạn sẽ thường cần tìm nơi một hàm được gọi hoặc định nghĩa, hoặc hiển thị lịch sử của một phương thức.
Git cung cấp một vài công cụ hữu ích để tìm kiếm qua mã và các commit được lưu trữ trong cơ sở dữ liệu của nó một cách nhanh chóng và dễ dàng.
Chúng ta sẽ đi qua một vài trong số chúng.

[[_git_grep]]
==== Git Grep

Git đi kèm với một lệnh gọi là `grep` cho phép bạn dễ dàng tìm kiếm qua bất kỳ cây (tree) đã commit nào, thư mục làm việc, hoặc thậm chí là chỉ mục (index) cho một chuỗi hoặc biểu thức chính quy.
Đối với các ví dụ sau, chúng ta sẽ tìm kiếm qua mã nguồn của chính Git.

Theo mặc định, `git grep` sẽ tìm qua các tệp trong thư mục làm việc của bạn.
Là một biến thể đầu tiên, bạn có thể sử dụng một trong các tùy chọn `-n` hoặc `--line-number` để in ra các số dòng nơi Git đã tìm thấy các kết quả khớp:

[source,console]
----
$ git grep -n gmtime_r
compat/gmtime.c:3:#undef gmtime_r
compat/gmtime.c:8:      return git_gmtime_r(timep, &result);
compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)
compat/gmtime.c:16:     ret = gmtime_r(timep, result);
compat/mingw.c:826:struct tm *gmtime_r(const time_t *timep, struct tm *result)
compat/mingw.h:206:struct tm *gmtime_r(const time_t *timep, struct tm *result);
date.c:482:             if (gmtime_r(&now, &now_tm))
date.c:545:             if (gmtime_r(&time, tm)) {
date.c:758:             /* gmtime_r() in match_digit() may have clobbered it */
git-compat-util.h:1138:struct tm *git_gmtime_r(const time_t *, struct tm *);
git-compat-util.h:1140:#define gmtime_r git_gmtime_r
----

Ngoài tìm kiếm cơ bản được hiển thị ở trên, `git grep` hỗ trợ vô số tùy chọn thú vị khác.

Ví dụ, thay vì in tất cả các kết quả khớp, bạn có thể yêu cầu `git grep` tóm tắt đầu ra bằng cách chỉ hiển thị cho bạn những tệp nào chứa chuỗi tìm kiếm và có bao nhiêu kết quả khớp trong mỗi tệp với tùy chọn `-c` hoặc `--count`:

[source,console]
----
$ git grep --count gmtime_r
compat/gmtime.c:4
compat/mingw.c:1
compat/mingw.h:1
date.c:3
git-compat-util.h:2
----

Nếu bạn quan tâm đến _ngữ cảnh_ của một chuỗi tìm kiếm, bạn có thể hiển thị phương thức hoặc hàm bao quanh cho mỗi chuỗi khớp với một trong các tùy chọn `-p` hoặc `--show-function`:

[source,console]
----
$ git grep -p gmtime_r *.c
date.c=static int match_multi_number(timestamp_t num, char c, const char *date,
date.c:         if (gmtime_r(&now, &now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)
date.c:         if (gmtime_r(&time, tm)) {
date.c=int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)
date.c:         /* gmtime_r() in match_digit() may have clobbered it */
----

Như bạn có thể thấy, thủ tục `gmtime_r` được gọi từ cả hai hàm `match_multi_number` và `match_digit` trong tệp `date.c` (kết quả khớp thứ ba được hiển thị đại diện cho chỉ chuỗi xuất hiện trong một bình luận).

Bạn cũng có thể tìm kiếm các kết hợp phức tạp của các chuỗi với cờ `--and`, đảm bảo rằng nhiều kết quả khớp phải xảy ra trong cùng một dòng văn bản.
Ví dụ, hãy tìm bất kỳ dòng nào định nghĩa một hằng số có tên chứa _một trong hai_ chuỗi con "`LINK`" hoặc "`BUF_MAX`", cụ thể trong một phiên bản cũ hơn của cơ sở mã Git được đại diện bởi thẻ `v1.8.0` (chúng ta sẽ thêm các tùy chọn `--break` và `--heading` giúp chia nhỏ đầu ra thành định dạng dễ đọc hơn):

[source,console]
----
$ git grep --break --heading \
    -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
v1.8.0:builtin/index-pack.c
62:#define FLAG_LINK (1u<<20)

v1.8.0:cache.h
73:#define S_IFGITLINK  0160000
74:#define S_ISGITLINK(m)       (((m) & S_IFMT) == S_IFGITLINK)

v1.8.0:environment.c
54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS

v1.8.0:strbuf.c
326:#define STRBUF_MAXLINK (2*PATH_MAX)

v1.8.0:symlinks.c
53:#define FL_SYMLINK  (1 << 2)

v1.8.0:zlib.c
30:/* #define ZLIB_BUF_MAX ((uInt)-1) */
31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */
----

Lệnh `git grep` có một vài lợi thế so với các lệnh tìm kiếm thông thường như `grep` và `ack`.
Đầu tiên là nó thực sự nhanh, thứ hai là bạn có thể tìm kiếm qua bất kỳ cây nào trong Git, không chỉ thư mục làm việc.
Như chúng ta đã thấy trong ví dụ trên, chúng ta đã tìm kiếm các thuật ngữ trong một phiên bản cũ hơn của mã nguồn Git, không phải phiên bản hiện đang được checkout.

==== Tìm kiếm Nhật ký Git (Git Log Searching)

Có lẽ bạn không tìm kiếm _nơi_ một thuật ngữ tồn tại, mà là _khi nào_ nó tồn tại hoặc được giới thiệu.
Lệnh `git log` có một số công cụ mạnh mẽ để tìm các commit cụ thể bằng nội dung thông điệp của chúng hoặc thậm chí nội dung của diff mà chúng giới thiệu.

Ví dụ, nếu chúng ta muốn tìm ra khi nào hằng số `ZLIB_BUF_MAX` được giới thiệu ban đầu, chúng ta có thể sử dụng tùy chọn `-S` (thường được gọi là tùy chọn Git "`pickaxe`" (cái cuốc)) để bảo Git chỉ hiển thị cho chúng ta những commit đã thay đổi số lần xuất hiện của chuỗi đó.

[source,console]
----
$ git log -S ZLIB_BUF_MAX --oneline
e01503b zlib: allow feeding more than 4GB in one go
ef49a7a zlib: zlib can only process 4GB at a time
----

Nếu chúng ta nhìn vào diff của các commit đó, chúng ta có thể thấy rằng trong `ef49a7a` hằng số đã được giới thiệu và trong `e01503b` nó đã được sửa đổi.

Nếu bạn cần cụ thể hơn, bạn có thể cung cấp một biểu thức chính quy để tìm kiếm với tùy chọn `-G`.

===== Tìm kiếm Nhật ký Dòng (Line Log Search)

Một tìm kiếm nhật ký khá nâng cao khác cực kỳ hữu ích là tìm kiếm lịch sử dòng.
Chỉ cần chạy `git log` với tùy chọn `-L`, và nó sẽ hiển thị cho bạn lịch sử của một hàm hoặc dòng mã trong cơ sở mã của bạn.

Ví dụ, nếu chúng ta muốn xem mọi thay đổi được thực hiện đối với hàm `git_deflate_bound` trong tệp `zlib.c`, chúng ta có thể chạy `git log -L :git_deflate_bound:zlib.c`.
Điều này sẽ cố gắng tìm ra giới hạn của hàm đó là gì và sau đó nhìn qua lịch sử và hiển thị cho chúng ta mọi thay đổi đã được thực hiện đối với hàm như một loạt các bản vá quay trở lại khi hàm được tạo lần đầu tiên.

[source,console]
----
$ git log -L :git_deflate_bound:zlib.c
commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca
Author: Junio C Hamano <gitster@pobox.com>
Date:   Fri Jun 10 11:52:15 2011 -0700

    zlib: zlib can only process 4GB at a time

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -85,5 +130,5 @@
-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)
 {
-       return deflateBound(strm, size);
+       return deflateBound(&strm->z, size);
 }


commit 225a6f1068f71723a910e8565db4e252b3ca21fa
Author: Junio C Hamano <gitster@pobox.com>
Date:   Fri Jun 10 11:18:17 2011 -0700

    zlib: wrap deflateBound() too

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -81,0 +85,5 @@
+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+{
+       return deflateBound(strm, size);
+}
+
----

Nếu Git không thể tìm ra cách khớp một hàm hoặc phương thức trong ngôn ngữ lập trình của bạn, bạn cũng có thể cung cấp cho nó một biểu thức chính quy (hoặc _regex_).
Ví dụ, điều này sẽ thực hiện điều tương tự như ví dụ trên: `git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c`.
Bạn cũng có thể cung cấp cho nó một phạm vi các dòng hoặc một số dòng đơn lẻ và bạn sẽ nhận được cùng một loại đầu ra.
