[[_git_reset]]
=== Giải mã Reset (Reset Demystified)

Trước khi chuyển sang các công cụ chuyên dụng hơn, hãy nói về các lệnh Git `reset` và `checkout`.
Các lệnh này là hai trong số những phần khó hiểu nhất của Git khi bạn lần đầu tiên gặp chúng.
Chúng làm rất nhiều việc đến nỗi dường như vô vọng để thực sự hiểu chúng và sử dụng chúng đúng cách.
Đối với điều này, chúng tôi khuyên bạn nên dùng một phép ẩn dụ đơn giản.

==== Ba Cây (The Three Trees)

Một cách dễ dàng hơn để suy nghĩ về `reset` và `checkout` là thông qua khung tư duy rằng Git là một trình quản lý nội dung của ba cây khác nhau.
Bởi "`cây`" ở đây, chúng tôi thực sự có nghĩa là "`tập hợp các tệp`", không cụ thể là cấu trúc dữ liệu.
Có một vài trường hợp chỉ mục không hoạt động chính xác như một cây, nhưng đối với mục đích của chúng ta, dễ dàng hơn để suy nghĩ về nó theo cách này ngay bây giờ.

Git như một hệ thống quản lý và thao tác ba cây trong hoạt động bình thường của nó:

[cols="1,2",options="header"]
|================================
| Cây (Tree) | Vai trò
| HEAD              | Ảnh chụp nhanh commit cuối cùng, cha mẹ tiếp theo
| Index (Chỉ mục)   | Ảnh chụp nhanh commit tiếp theo được đề xuất
| Working Directory (Thư mục Làm việc) | Hộp cát (Sandbox)
|================================

===== HEAD

HEAD là con trỏ đến tham chiếu nhánh hiện tại, đến lượt nó là một con trỏ đến commit cuối cùng được thực hiện trên nhánh đó.
Điều đó có nghĩa là HEAD sẽ là cha mẹ của commit tiếp theo được tạo ra.
Nói chung là đơn giản nhất để nghĩ về HEAD như là ảnh chụp nhanh của *commit cuối cùng của bạn trên nhánh đó*.

Trên thực tế, khá dễ dàng để xem ảnh chụp nhanh đó trông như thế nào.
Dưới đây là một ví dụ về việc lấy danh sách thư mục thực tế và tổng kiểm tra SHA-1 cho mỗi tệp trong ảnh chụp nhanh HEAD:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Các lệnh Git `cat-file` và `ls-tree` là các lệnh "`cấp thấp`" (plumbing) được sử dụng cho những việc ở cấp độ thấp hơn và không thực sự được sử dụng trong công việc hàng ngày, nhưng chúng giúp chúng ta thấy những gì đang diễn ra ở đây.

[[_the_index]]
===== Chỉ mục (The Index)

_Chỉ mục_ là *commit tiếp theo được đề xuất* của bạn.
Chúng ta cũng đã đề cập đến khái niệm này là "`Khu vực Tổ chức`" (Staging Area) của Git vì đây là những gì Git nhìn vào khi bạn chạy `git commit`.

Git điền vào chỉ mục này một danh sách tất cả các nội dung tệp đã được checkout lần cuối vào thư mục làm việc của bạn và chúng trông như thế nào khi chúng được checkout ban đầu.
Sau đó, bạn thay thế một số tệp đó bằng các phiên bản mới của chúng, và `git commit` chuyển đổi nó thành cây cho một commit mới.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Một lần nữa, ở đây chúng ta đang sử dụng `git ls-files`, đây là một lệnh hậu trường hiển thị cho bạn chỉ mục của bạn hiện trông như thế nào.

Chỉ mục không phải là một cấu trúc cây về mặt kỹ thuật -- nó thực sự được triển khai như một bản kê khai phẳng -- nhưng đối với mục đích của chúng ta, nó đủ gần.

===== Thư mục Làm việc (The Working Directory)

Cuối cùng, bạn có _thư mục làm việc_ của mình (cũng thường được gọi là "`cây làm việc`").
Hai cây kia lưu trữ nội dung của chúng theo một cách hiệu quả nhưng bất tiện, bên trong thư mục `.git`.
Thư mục làm việc giải nén chúng thành các tệp thực tế, giúp bạn chỉnh sửa chúng dễ dàng hơn nhiều.
Hãy nghĩ về thư mục làm việc như một *hộp cát*, nơi bạn có thể thử các thay đổi trước khi commit chúng vào khu vực tổ chức (chỉ mục) và sau đó vào lịch sử.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== Quy trình làm việc (The Workflow)

Quy trình làm việc điển hình của Git là ghi lại các ảnh chụp nhanh của dự án của bạn ở các trạng thái tốt hơn liên tiếp, bằng cách thao tác ba cây này.

.Quy trình làm việc điển hình của Git
image::images/reset-workflow.png[Quy trình làm việc điển hình của Git]

Hãy hình dung quá trình này: giả sử bạn đi vào một thư mục mới với một tệp duy nhất trong đó.
Chúng ta sẽ gọi đây là *v1* của tệp, và chúng ta sẽ chỉ ra nó bằng màu xanh lam.
Bây giờ chúng ta chạy `git init`, sẽ tạo ra một kho lưu trữ Git với một tham chiếu HEAD trỏ đến nhánh `master` chưa sinh (unborn).

.Kho lưu trữ Git mới được khởi tạo với tệp chưa được tổ chức trong thư mục làm việc
image::images/reset-ex1.png[Kho lưu trữ Git mới được khởi tạo với tệp chưa được tổ chức trong thư mục làm việc]

Tại thời điểm này, chỉ có cây thư mục làm việc có bất kỳ nội dung nào.

Bây giờ chúng ta muốn commit tệp này, vì vậy chúng ta sử dụng `git add` để lấy nội dung trong thư mục làm việc và sao chép nó vào chỉ mục.

.Tệp được sao chép vào chỉ mục khi `git add`
image::images/reset-ex2.png[Tệp được sao chép vào chỉ mục khi `git add`]

Sau đó, chúng ta chạy `git commit`, lấy nội dung của chỉ mục và lưu nó dưới dạng ảnh chụp nhanh vĩnh viễn, tạo một đối tượng commit trỏ đến ảnh chụp nhanh đó, và cập nhật `master` để trỏ đến commit đó.

.Bước `git commit`
image::images/reset-ex3.png[Bước `git commit`]

Nếu chúng ta chạy `git status`, chúng ta sẽ không thấy thay đổi nào, bởi vì cả ba cây đều giống nhau.

Bây giờ chúng ta muốn thực hiện một thay đổi cho tệp đó và commit nó.
Chúng ta sẽ trải qua cùng một quy trình; đầu tiên, chúng ta thay đổi tệp trong thư mục làm việc của mình.
Hãy gọi đây là *v2* của tệp, và chỉ ra nó bằng màu đỏ.

.Kho lưu trữ Git với tệp đã thay đổi trong thư mục làm việc
image::images/reset-ex4.png[Kho lưu trữ Git với tệp đã thay đổi trong thư mục làm việc]

Nếu chúng ta chạy `git status` ngay bây giờ, chúng ta sẽ thấy tệp màu đỏ là "`Changes not staged for commit`" (Các thay đổi chưa được tổ chức để commit), bởi vì mục nhập đó khác nhau giữa chỉ mục và thư mục làm việc.
Tiếp theo chúng ta chạy `git add` trên nó để tổ chức nó vào chỉ mục của chúng ta.

.Tổ chức thay đổi vào chỉ mục
image::images/reset-ex5.png[Tổ chức thay đổi vào chỉ mục]

Tại thời điểm này, nếu chúng ta chạy `git status`, chúng ta sẽ thấy tệp màu xanh lục dưới "`Changes to be committed`" (Các thay đổi sẽ được commit) bởi vì chỉ mục và HEAD khác nhau -- nghĩa là, commit tiếp theo được đề xuất của chúng ta bây giờ khác với commit cuối cùng của chúng ta.
Cuối cùng, chúng ta chạy `git commit` để hoàn tất commit.

.Bước `git commit` với tệp đã thay đổi
image::images/reset-ex6.png[Bước `git commit` với tệp đã thay đổi]

Bây giờ `git status` sẽ không cung cấp cho chúng ta đầu ra nào, bởi vì cả ba cây lại giống nhau.

Chuyển nhánh hoặc sao chép (cloning) cũng trải qua một quy trình tương tự.
Khi bạn checkout một nhánh, nó thay đổi *HEAD* để trỏ đến tham chiếu nhánh mới, điền vào *chỉ mục* của bạn với ảnh chụp nhanh của commit đó, sau đó sao chép nội dung của *chỉ mục* vào *thư mục làm việc* của bạn.

==== Vai trò của Reset

Lệnh `reset` có ý nghĩa hơn khi được xem trong bối cảnh này.

Đối với mục đích của các ví dụ này, giả sử rằng chúng ta đã sửa đổi `file.txt` một lần nữa và commit nó lần thứ ba.
Vì vậy, bây giờ lịch sử của chúng ta trông giống như thế này:

.Kho lưu trữ Git với ba commit
image::images/reset-start.png[Kho lưu trữ Git với ba commit]

Bây giờ hãy xem xét chính xác những gì `reset` làm khi bạn gọi nó.
Nó trực tiếp thao tác ba cây này theo một cách đơn giản và dễ đoán.
Nó thực hiện tối đa ba hoạt động cơ bản.

===== Bước 1: Di chuyển HEAD

Điều đầu tiên `reset` sẽ làm là di chuyển những gì HEAD trỏ đến.
Điều này không giống như thay đổi chính HEAD (đó là những gì `checkout` làm); `reset` di chuyển nhánh mà HEAD đang trỏ đến.
Điều này có nghĩa là nếu HEAD được đặt thành nhánh `master` (tức là bạn hiện đang ở trên nhánh `master`), chạy `git reset 9e5e6a4` sẽ bắt đầu bằng cách làm cho `master` trỏ đến `9e5e6a4`.

.Soft reset (Reset mềm)
image::images/reset-soft.png[Soft reset]

Bất kể bạn gọi `reset` với một commit dưới hình thức nào, đây là điều đầu tiên nó sẽ luôn cố gắng làm.
Với `reset --soft`, nó sẽ đơn giản dừng lại ở đó.

Bây giờ hãy dành một giây để nhìn vào sơ đồ đó và nhận ra những gì đã xảy ra: về cơ bản nó đã hoàn tác lệnh `git commit` cuối cùng.
Khi bạn chạy `git commit`, Git tạo ra một commit mới và di chuyển nhánh mà HEAD trỏ đến lên nó.
Khi bạn `reset` trở lại `HEAD~` (cha mẹ của HEAD), bạn đang di chuyển nhánh trở lại nơi nó đã ở, mà không thay đổi chỉ mục hoặc thư mục làm việc.
Bây giờ bạn có thể cập nhật chỉ mục và chạy `git commit` một lần nữa để hoàn thành những gì `git commit --amend` sẽ làm (xem <<_git_amend>>).

===== Bước 2: Cập nhật Chỉ mục (`--mixed`)

Lưu ý rằng nếu bạn chạy `git status` bây giờ, bạn sẽ thấy màu xanh lục sự khác biệt giữa chỉ mục và HEAD mới là gì.

Điều tiếp theo `reset` sẽ làm là cập nhật chỉ mục với nội dung của bất kỳ ảnh chụp nhanh nào mà HEAD hiện đang trỏ đến.

.Mixed reset (Reset hỗn hợp)
image::images/reset-mixed.png[Mixed reset]

Nếu bạn chỉ định tùy chọn `--mixed`, `reset` sẽ dừng lại tại điểm này.
Đây cũng là mặc định, vì vậy nếu bạn không chỉ định tùy chọn nào cả (chỉ `git reset HEAD~` trong trường hợp này), đây là nơi lệnh sẽ dừng lại.

Bây giờ hãy dành một giây nữa để nhìn vào sơ đồ đó và nhận ra những gì đã xảy ra: nó vẫn hoàn tác `commit` cuối cùng của bạn, nhưng cũng _hủy tổ chức_ mọi thứ.
Bạn đã quay trở lại trước khi bạn chạy tất cả các lệnh `git add` và `git commit` của mình.

===== Bước 3: Cập nhật Thư mục Làm việc (`--hard`)

Điều thứ ba mà `reset` sẽ làm là làm cho thư mục làm việc trông giống như chỉ mục.
Nếu bạn sử dụng tùy chọn `--hard`, nó sẽ tiếp tục đến giai đoạn này.

.Hard reset (Reset cứng)
image::images/reset-hard.png[Hard reset]

Vì vậy, hãy suy nghĩ về những gì vừa xảy ra.
Bạn đã hoàn tác commit cuối cùng của mình, các lệnh `git add` và `git commit`, *và* tất cả công việc bạn đã làm trong thư mục làm việc của mình.

Điều quan trọng cần lưu ý là cờ này (`--hard`) là cách duy nhất để làm cho lệnh `reset` trở nên nguy hiểm, và là một trong số rất ít trường hợp Git sẽ thực sự phá hủy dữ liệu.
Bất kỳ lời gọi nào khác của `reset` đều có thể được hoàn tác khá dễ dàng, nhưng tùy chọn `--hard` thì không thể, vì nó ghi đè lên các tệp trong thư mục làm việc một cách cưỡng bức.
Trong trường hợp cụ thể này, chúng ta vẫn có phiên bản *v3* của tệp của mình trong một commit trong cơ sở dữ liệu Git của chúng ta, và chúng ta có thể lấy lại nó bằng cách xem `reflog` của mình, nhưng nếu chúng ta chưa commit nó, Git vẫn sẽ ghi đè lên tệp và nó sẽ không thể khôi phục được.

===== Tóm tắt (Recap)

Lệnh `reset` ghi đè lên ba cây này theo một thứ tự cụ thể, dừng lại khi bạn bảo nó:

1. Di chuyển nhánh mà HEAD trỏ đến _(dừng ở đây nếu `--soft`)_.
2. Làm cho chỉ mục trông giống như HEAD _(dừng ở đây trừ khi `--hard`)_.
3. Làm cho thư mục làm việc trông giống như chỉ mục.

==== Reset Với một Đường dẫn

Điều đó bao gồm hành vi của `reset` ở dạng cơ bản của nó, nhưng bạn cũng có thể cung cấp cho nó một đường dẫn để hành động.
Nếu bạn chỉ định một đường dẫn, `reset` sẽ bỏ qua bước 1, và giới hạn phần còn lại của các hành động của nó đối với một tệp hoặc tập hợp các tệp cụ thể.
Điều này thực sự có ý nghĩa -- HEAD chỉ là một con trỏ, và bạn không thể trỏ đến một phần của một commit và một phần của một commit khác.
Nhưng chỉ mục và thư mục làm việc _có thể_ được cập nhật một phần, vì vậy reset tiến hành các bước 2 và 3.

Vì vậy, giả sử chúng ta chạy `git reset file.txt`.
Dạng này (vì bạn không chỉ định SHA-1 commit hoặc nhánh, và bạn không chỉ định `--soft` hoặc `--hard`) là viết tắt của `git reset --mixed HEAD file.txt`, sẽ:

1. Di chuyển nhánh mà HEAD trỏ đến _(bỏ qua)_.
2. Làm cho chỉ mục trông giống như HEAD _(dừng ở đây)_.

Vì vậy, về cơ bản nó chỉ sao chép `file.txt` từ HEAD vào chỉ mục.

.Mixed reset với một đường dẫn
image::images/reset-path1.png[Mixed reset với một đường dẫn]

Điều này có tác dụng thực tế là _hủy tổ chức_ tệp.
Nếu chúng ta nhìn vào sơ đồ cho lệnh đó và suy nghĩ về những gì `git add` làm, chúng là những mặt đối lập chính xác.

.Tổ chức tệp vào chỉ mục
image::images/reset-path2.png[Tổ chức tệp vào chỉ mục]

Đây là lý do tại sao đầu ra của lệnh `git status` gợi ý rằng bạn chạy lệnh này để hủy tổ chức một tệp (xem <<ch02-git-basics-chapter#_unstaging>> để biết thêm về điều này).

Chúng ta cũng có thể dễ dàng không để Git giả định chúng ta có nghĩa là "`kéo dữ liệu từ HEAD`" bằng cách chỉ định một commit cụ thể để kéo phiên bản tệp đó từ đó.
Chúng ta chỉ cần chạy một cái gì đó như `git reset eb43bf file.txt`.

.Soft reset với một đường dẫn đến một commit cụ thể
image::images/reset-path3.png[Soft reset với một đường dẫn đến một commit cụ thể]

Điều này thực hiện hiệu quả điều tương tự như thể chúng ta đã hoàn nguyên nội dung của tệp về *v1* trong thư mục làm việc, chạy `git add` trên nó, sau đó hoàn nguyên nó trở lại *v3* một lần nữa (mà không thực sự trải qua tất cả các bước đó).
Nếu chúng ta chạy `git commit` ngay bây giờ, nó sẽ ghi lại một thay đổi hoàn nguyên tệp đó trở lại *v1*, mặc dù chúng ta chưa bao giờ thực sự có nó trong thư mục làm việc của mình một lần nữa.

Cũng thú vị khi lưu ý rằng giống như `git add`, lệnh `reset` sẽ chấp nhận tùy chọn `--patch` để hủy tổ chức nội dung trên cơ sở từng đoạn một (hunk-by-hunk).
Vì vậy, bạn có thể hủy tổ chức hoặc hoàn nguyên nội dung một cách chọn lọc.

==== Gộp (Squashing)

Hãy xem cách làm điều gì đó thú vị với sức mạnh mới tìm thấy này -- gộp các commit.

Giả sử bạn có một loạt các commit với các thông điệp như "`oops.`", "`WIP`" và "`forgot this file`".
Bạn có thể sử dụng `reset` để gộp chúng nhanh chóng và dễ dàng thành một commit đơn lẻ khiến bạn trông thực sự thông minh.
<<_squashing>> chỉ ra một cách khác để làm điều này, nhưng trong ví dụ này, đơn giản hơn để sử dụng `reset`.

Giả sử bạn có một dự án trong đó commit đầu tiên có một tệp, commit thứ hai đã thêm một tệp mới và thay đổi tệp đầu tiên, và commit thứ ba đã thay đổi tệp đầu tiên một lần nữa.
Commit thứ hai là một công việc đang tiến hành và bạn muốn gộp nó xuống.

.Kho lưu trữ Git
image::images/reset-squash-r1.png[Kho lưu trữ Git]

Bạn có thể chạy `git reset --soft HEAD~2` để di chuyển nhánh HEAD trở lại một commit cũ hơn (commit gần đây nhất bạn muốn giữ):

.Di chuyển HEAD với soft reset
image::images/reset-squash-r2.png[Di chuyển HEAD với soft reset]

Và sau đó đơn giản chạy `git commit` một lần nữa:

.Kho lưu trữ Git với commit đã gộp
image::images/reset-squash-r3.png[Kho lưu trữ Git với commit đã gộp]

Bây giờ bạn có thể thấy rằng lịch sử có thể truy cập của bạn, lịch sử bạn sẽ đẩy, bây giờ trông giống như bạn có một commit với `file-a.txt` *v1*, sau đó là một commit thứ hai vừa sửa đổi `file-a.txt` thành *v3* và thêm `file-b.txt`.
Commit với phiên bản *v2* của tệp không còn trong lịch sử nữa.

==== Checkout (Check It Out)

Cuối cùng, bạn có thể tự hỏi sự khác biệt giữa `checkout` và `reset` là gì.
Giống như `reset`, `checkout` thao tác ba cây, và nó hơi khác một chút tùy thuộc vào việc bạn có cung cấp cho lệnh một đường dẫn tệp hay không.

===== Không có Đường dẫn

Chạy `git checkout [nhánh]` khá giống với chạy `git reset --hard [nhánh]` ở chỗ nó cập nhật cả ba cây cho bạn để trông giống như `[nhánh]`, nhưng có hai sự khác biệt quan trọng.

Đầu tiên, không giống như `reset --hard`, `checkout` an toàn cho thư mục làm việc; nó sẽ kiểm tra để đảm bảo nó không thổi bay các tệp có thay đổi đối với chúng.
Thực ra, nó thông minh hơn thế một chút -- nó cố gắng thực hiện một hợp nhất tầm thường trong thư mục làm việc, vì vậy tất cả các tệp bạn _chưa_ thay đổi sẽ được cập nhật.
`reset --hard`, mặt khác, sẽ đơn giản thay thế mọi thứ trên diện rộng mà không cần kiểm tra.

Sự khác biệt quan trọng thứ hai là cách `checkout` cập nhật HEAD.
Trong khi `reset` sẽ di chuyển nhánh mà HEAD trỏ đến, `checkout` sẽ di chuyển chính HEAD để trỏ đến một nhánh khác.

Ví dụ, giả sử chúng ta có các nhánh `master` và `develop` trỏ đến các commit khác nhau, và chúng ta hiện đang ở trên `develop` (vì vậy HEAD trỏ đến nó).
Nếu chúng ta chạy `git reset master`, bản thân `develop` bây giờ sẽ trỏ đến cùng một commit mà `master` làm.
Nếu thay vào đó chúng ta chạy `git checkout master`, `develop` không di chuyển, chính HEAD di chuyển.
HEAD bây giờ sẽ trỏ đến `master`.

Vì vậy, trong cả hai trường hợp, chúng ta đang di chuyển HEAD để trỏ đến commit A, nhưng _cách_ chúng ta làm như vậy rất khác nhau.
`reset` sẽ di chuyển nhánh mà HEAD trỏ đến, `checkout` di chuyển chính HEAD.

.`git checkout` và `git reset`
image::images/reset-checkout.png[`git checkout` và `git reset`]

===== Với Đường dẫn

Cách khác để chạy `checkout` là với một đường dẫn tệp, giống như `reset`, không di chuyển HEAD.
Nó giống như `git reset [nhánh] tệp` ở chỗ nó cập nhật chỉ mục với tệp đó tại commit đó, nhưng nó cũng ghi đè lên tệp trong thư mục làm việc.
Nó sẽ chính xác giống như `git reset --hard [nhánh] tệp` (nếu `reset` cho phép bạn chạy điều đó) -- nó không an toàn cho thư mục làm việc, và nó không di chuyển HEAD.

Ngoài ra, giống như `git reset` và `git add`, `checkout` sẽ chấp nhận tùy chọn `--patch` để cho phép bạn hoàn nguyên nội dung tệp một cách chọn lọc trên cơ sở từng đoạn một.

==== Tóm tắt

Hy vọng bây giờ bạn hiểu và cảm thấy thoải mái hơn với lệnh `reset`, nhưng có lẽ vẫn còn một chút bối rối về việc nó khác chính xác như thế nào so với `checkout` và không thể nhớ tất cả các quy tắc của các lời gọi khác nhau.

Dưới đây là một bảng ghi nhớ cho các lệnh nào ảnh hưởng đến các cây nào.
Cột "`HEAD`" đọc là "`REF`" nếu lệnh đó di chuyển tham chiếu (nhánh) mà HEAD trỏ đến, và "`HEAD`" nếu nó di chuyển chính HEAD.
Đặc biệt chú ý đến cột 'An toàn cho TMLV?' (WD Safe?) -- nếu nó nói *KHÔNG*, hãy dành một giây để suy nghĩ trước khi chạy lệnh đó.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | An toàn cho TMLV?
| *Cấp độ Commit* | | | |
| `reset --soft [commit]` | REF | KHÔNG | KHÔNG | CÓ
| `reset [commit]` | REF | CÓ | KHÔNG | CÓ
| `reset --hard [commit]` | REF | CÓ | CÓ | *KHÔNG*
| `checkout <commit>` | HEAD | CÓ | CÓ | CÓ
| *Cấp độ Tệp* | | | |
| `reset [commit] <paths>` | KHÔNG | CÓ | KHÔNG | CÓ
| `checkout [commit] <paths>` | KHÔNG | CÓ | CÓ | *KHÔNG*
|================================
