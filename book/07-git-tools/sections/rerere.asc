[[ref_rerere]]
=== Rerere

Chức năng `git rerere` là một tính năng hơi ẩn.
Tên này là viết tắt của "`reuse recorded resolution`" (tái sử dụng giải pháp đã ghi lại) và, như tên gọi, nó cho phép bạn yêu cầu Git ghi nhớ cách bạn đã giải quyết một xung đột đoạn mã để lần sau khi nó thấy xung đột tương tự, Git có thể tự động giải quyết nó cho bạn.

Có một số kịch bản mà chức năng này có thể thực sự tiện dụng.
Một trong những ví dụ được đề cập trong tài liệu là khi bạn muốn đảm bảo một nhánh chủ đề có tuổi thọ cao cuối cùng sẽ hợp nhất sạch sẽ, nhưng bạn không muốn có nhiều cam kết hợp nhất trung gian làm lộn xộn lịch sử cam kết của bạn.
Với `rerere` được bật, bạn có thể thử hợp nhất không thường xuyên, giải quyết xung đột, sau đó rút lại việc hợp nhất.
Nếu bạn làm điều này liên tục, thì lần hợp nhất cuối cùng sẽ dễ dàng vì `rerere` có thể tự động làm mọi thứ cho bạn.

Chiến thuật tương tự có thể được sử dụng nếu bạn muốn giữ một nhánh được rebase để bạn không phải đối phó với cùng một xung đột rebase mỗi khi bạn thực hiện nó.
Hoặc nếu bạn muốn lấy một nhánh bạn đã hợp nhất và sửa một loạt xung đột và sau đó quyết định rebase nó -- bạn có thể sẽ không phải làm lại tất cả các xung đột tương tự.

Một ứng dụng khác của `rerere` là khi bạn hợp nhất một loạt các nhánh chủ đề đang phát triển lại với nhau thành một đầu có thể kiểm thử không thường xuyên, như dự án Git thường làm.
Nếu các thử nghiệm thất bại, bạn có thể hoàn tác các lần hợp nhất và thực hiện lại chúng mà không có nhánh chủ đề đã làm cho các thử nghiệm thất bại mà không cần phải giải quyết lại các xung đột.

Để bật chức năng `rerere`, bạn chỉ cần chạy cài đặt cấu hình này:

[source,console]
----
$ git config --global rerere.enabled true
----

Bạn cũng có thể bật nó bằng cách tạo thư mục `.git/rr-cache` trong một kho lưu trữ cụ thể, nhưng cài đặt cấu hình rõ ràng hơn và bật tính năng đó trên toàn cầu cho bạn.

Bây giờ hãy xem một ví dụ đơn giản, tương tự như ví dụ trước của chúng ta.
Giả sử chúng ta có một tệp có tên `hello.rb` trông như thế này:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end
----

Trong một nhánh, chúng ta thay đổi từ "`hello`" thành "`hola`", sau đó trong một nhánh khác, chúng ta thay đổi "`world`" thành "`mundo`", giống như trước.

.Hai nhánh thay đổi cùng một phần của cùng một tệp khác nhau
image::images/rerere1.png[Hai nhánh thay đổi cùng một phần của cùng một tệp khác nhau]

Khi chúng ta hợp nhất hai nhánh lại với nhau, chúng ta sẽ gặp xung đột hợp nhất:

[source,console]
----
$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.
----

Bạn nên lưu ý dòng mới `Recorded preimage for FILE` ở đó.
Nếu không thì nó sẽ trông giống hệt như một xung đột hợp nhất thông thường.
Tại thời điểm này, `rerere` có thể cho chúng ta biết một vài điều.
Thông thường, bạn có thể chạy `git status` tại thời điểm này để xem tất cả những gì bị xung đột:

[source,console]
----
$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD <file>..." to unstage)
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      hello.rb
#
----

Tuy nhiên, `git rerere` cũng sẽ cho bạn biết nó đã ghi lại trạng thái trước khi hợp nhất cho những gì bằng `git rerere status`:

[source,console]
----
$ git rerere status
hello.rb
----

Và `git rerere diff` sẽ hiển thị trạng thái hiện tại của giải pháp -- những gì bạn đã bắt đầu để giải quyết và những gì bạn đã giải quyết nó thành.

[source,console]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
+<<<<<<< HEAD
   puts 'hola world'
->>>>>>>
+=======
+  puts 'hello mundo'
+>>>>>>> i18n-world
 end
----

Cũng (và điều này không thực sự liên quan đến `rerere`), bạn có thể sử dụng `git ls-files -u` để xem các tệp xung đột và các phiên bản trước, trái và phải:

[source,console]
----
$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb
----

Bây giờ bạn có thể giải quyết nó để chỉ còn `puts 'hola mundo'` và bạn có thể chạy `git rerere diff` một lần nữa để xem rerere sẽ ghi nhớ những gì:

[source,console]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
-  puts 'hola world'
->>>>>>>
+  puts 'hola mundo'
 end
----

Vì vậy, về cơ bản nó nói rằng, khi Git thấy một xung đột đoạn mã trong một tệp `hello.rb` có "`hello mundo`" ở một bên và "`hola world`" ở bên kia, nó sẽ giải quyết nó thành "`hola mundo`".

Bây giờ chúng ta có thể đánh dấu nó là đã giải quyết và cam kết nó:

[source,console]
----
$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'
----

Bạn có thể thấy rằng nó "Recorded resolution for FILE".

.Giải pháp đã ghi lại cho FILE
image::images/rerere2.png[Giải pháp đã ghi lại cho FILE]

Bây giờ, hãy hoàn tác việc hợp nhất đó và sau đó rebase nó trên đỉnh nhánh `master` của chúng ta.
Chúng ta có thể di chuyển nhánh của mình trở lại bằng cách sử dụng `git reset` như chúng ta đã thấy trong <<ch07-git-tools#_git_reset>>.

[source,console]
----
$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello
----

Việc hợp nhất của chúng ta đã được hoàn tác.
Bây giờ hãy rebase nhánh chủ đề.

[source,console]
----
$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word
----

Bây giờ, chúng ta đã gặp cùng một xung đột hợp nhất như chúng ta mong đợi, nhưng hãy xem dòng `Resolved FILE using previous resolution`.
Nếu chúng ta nhìn vào tệp, chúng ta sẽ thấy rằng nó đã được giải quyết, không có dấu xung đột hợp nhất nào trong đó.

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----

Ngoài ra, `git diff` sẽ hiển thị cho bạn cách nó đã được giải quyết lại tự động:

[source,console]
----
$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end
----

.Xung đột hợp nhất được giải quyết tự động bằng giải pháp trước đó
image::images/rerere3.png[Xung đột hợp nhất được giải quyết tự động bằng giải pháp trước đó]

Bạn cũng có thể tạo lại trạng thái tệp bị xung đột bằng `git checkout`:

[source,console]
----
$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end
----

Chúng ta đã thấy một ví dụ về điều này trong <<ch07-git-tools#_advanced_merging>>.
Tuy nhiên, bây giờ, hãy giải quyết lại nó bằng cách chạy `git rerere` một lần nữa:

[source,console]
----
$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----

Chúng ta đã giải quyết lại tệp tự động bằng cách sử dụng giải pháp `rerere` đã được lưu vào bộ nhớ cache.
Bây giờ bạn có thể thêm và tiếp tục rebase để hoàn thành nó.

[source,console]
----
$ git add hello.rb
$ git rebase --continue
Applying: i18n one word
----

Vì vậy, nếu bạn thực hiện nhiều lần hợp nhất lại, hoặc muốn giữ một nhánh chủ đề được cập nhật với nhánh `master` của bạn mà không cần nhiều lần hợp nhất, hoặc bạn rebase thường xuyên, bạn có thể bật `rerere` để giúp cuộc sống của bạn dễ dàng hơn một chút.