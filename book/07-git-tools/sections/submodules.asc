[[_git_submodules]]
=== Mô-đun con (Submodules)

Thường xảy ra trường hợp khi đang làm việc trên một dự án, bạn cần sử dụng một dự án khác từ bên trong nó.
Có lẽ đó là một thư viện mà bên thứ ba đã phát triển hoặc bạn đang phát triển riêng biệt và sử dụng trong nhiều dự án cha.
Một vấn đề phổ biến nảy sinh trong các tình huống này: bạn muốn có thể coi hai dự án là riêng biệt nhưng vẫn có thể sử dụng một dự án từ bên trong dự án kia.

Dưới đây là một ví dụ.
Giả sử bạn đang phát triển một trang web và tạo nguồn cấp dữ liệu Atom.
Thay vì viết mã tạo Atom của riêng bạn, bạn quyết định sử dụng một thư viện.
Bạn có thể sẽ phải bao gồm mã này từ một thư viện chia sẻ như cài đặt CPAN hoặc Ruby gem, hoặc sao chép mã nguồn vào cây dự án của riêng bạn.
Vấn đề với việc bao gồm thư viện là khó tùy chỉnh thư viện theo bất kỳ cách nào và thường khó triển khai hơn, bởi vì bạn cần đảm bảo mọi máy khách đều có sẵn thư viện đó.
Vấn đề với việc sao chép mã vào dự án của riêng bạn là bất kỳ thay đổi tùy chỉnh nào bạn thực hiện đều khó hợp nhất khi các thay đổi thượng nguồn trở nên khả dụng.

Git giải quyết vấn đề này bằng cách sử dụng các mô-đun con.
Các mô-đun con cho phép bạn giữ một kho lưu trữ Git dưới dạng một thư mục con của một kho lưu trữ Git khác.
Điều này cho phép bạn sao chép một kho lưu trữ khác vào dự án của mình và giữ các cam kết của bạn tách biệt.

[[_starting_submodules]]
==== Bắt đầu với các Mô-đun con

Chúng ta sẽ đi qua việc phát triển một dự án đơn giản đã được chia thành một dự án chính và một vài dự án con.

Hãy bắt đầu bằng cách thêm một kho lưu trữ Git hiện có làm mô-đun con của kho lưu trữ mà chúng ta đang làm việc.
Để thêm một mô-đun con mới, bạn sử dụng lệnh `git submodule add` với URL tuyệt đối hoặc tương đối của dự án bạn muốn bắt đầu theo dõi.
Trong ví dụ này, chúng ta sẽ thêm một thư viện có tên "`DbConnector`".

[source,console]
----
$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

Theo mặc định, các mô-đun con sẽ thêm dự án con vào một thư mục có tên giống với kho lưu trữ, trong trường hợp này là "`DbConnector`".
Bạn có thể thêm một đường dẫn khác vào cuối lệnh nếu bạn muốn nó đi đến nơi khác.

Nếu bạn chạy `git status` tại thời điểm này, bạn sẽ nhận thấy một vài điều.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector
----

Đầu tiên bạn nên chú ý đến tệp `.gitmodules` mới.
Đây là một tệp cấu hình lưu trữ ánh xạ giữa URL của dự án và thư mục con cục bộ mà bạn đã kéo nó vào:

[source,ini]
----
[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector
----

Nếu bạn có nhiều mô-đun con, bạn sẽ có nhiều mục trong tệp này.
Điều quan trọng cần lưu ý là tệp này được kiểm soát phiên bản cùng với các tệp khác của bạn, giống như tệp `.gitignore` của bạn.
Nó được đẩy và kéo cùng với phần còn lại của dự án của bạn.
Đây là cách những người khác sao chép dự án này biết nơi lấy các dự án mô-đun con.

[NOTE]
=====
Vì URL trong tệp .gitmodules là những gì người khác sẽ thử sao chép/fetch đầu tiên, hãy đảm bảo sử dụng URL mà họ có thể truy cập nếu có thể.
Ví dụ, nếu bạn sử dụng một URL khác để đẩy so với những người khác sẽ sử dụng để kéo, hãy sử dụng URL mà những người khác có quyền truy cập.
Bạn có thể ghi đè giá trị này cục bộ bằng `git config submodule.DbConnector.url PRIVATE_URL` để sử dụng cho riêng bạn.
Khi áp dụng, một URL tương đối có thể hữu ích.
=====

Mục liệt kê khác trong đầu ra `git status` là mục nhập thư mục dự án.
Nếu bạn chạy `git diff` trên đó, bạn sẽ thấy điều gì đó thú vị:

[source,console]
----
$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc
----

Mặc dù `DbConnector` là một thư mục con trong thư mục làm việc của bạn, Git coi nó là một mô-đun con và không theo dõi nội dung của nó khi bạn không ở trong thư mục đó.
Thay vào đó, Git coi nó là một cam kết cụ thể từ kho lưu trữ đó.

Nếu bạn muốn đầu ra diff đẹp hơn một chút, bạn có thể chuyển tùy chọn `--submodule` cho `git diff`.

[source,console]
----
$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)
----

Khi bạn cam kết, bạn thấy một cái gì đó giống như thế này:

[source,console]
----
$ git commit -am 'Add DbConnector module'
[master fb9093c] Add DbConnector module
 2 files changed, 4 insertions(+)
  create mode 100644 .gitmodules
  create mode 160000 DbConnector
----

Lưu ý chế độ `160000` cho mục nhập `DbConnector`.
Đó là một chế độ đặc biệt trong Git về cơ bản có nghĩa là bạn đang ghi lại một cam kết dưới dạng một mục nhập thư mục thay vì một thư mục con hoặc một tệp.

Cuối cùng, đẩy các thay đổi này:

[source,console]
----
$ git push origin master
----

[[_cloning_submodules]]
==== Sao chép một Dự án với các Mô-đun con

Ở đây chúng ta sẽ sao chép một dự án có một mô-đun con trong đó.
Khi bạn sao chép một dự án như vậy, theo mặc định bạn nhận được các thư mục chứa các mô-đun con, nhưng chưa có tệp nào bên trong chúng:

[source,console]
----
$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$
----

Thư mục `DbConnector` có ở đó, nhưng trống rỗng.
Bạn phải chạy hai lệnh từ dự án chính: `git submodule init` để khởi tạo tệp cấu hình cục bộ của bạn, và `git submodule update` để lấy tất cả dữ liệu từ dự án đó và checkout cam kết thích hợp được liệt kê trong siêu dự án của bạn:

[source,console]
----
$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

Bây giờ thư mục con `DbConnector` của bạn đang ở trạng thái chính xác như khi bạn cam kết trước đó.

Tuy nhiên, có một cách khác để làm điều này đơn giản hơn một chút.
Nếu bạn chuyển `--recurse-submodules` cho lệnh `git clone`, nó sẽ tự động khởi tạo và cập nhật từng mô-đun con trong kho lưu trữ, bao gồm cả các mô-đun con lồng nhau nếu bất kỳ mô-đun con nào trong kho lưu trữ cũng có các mô-đun con.

[source,console]
----
$ git clone --recurse-submodules https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

Nếu bạn đã sao chép dự án và quên `--recurse-submodules`, bạn có thể kết hợp các bước `git submodule init` và `git submodule update` bằng cách chạy `git submodule update --init`.
Để cũng khởi tạo, fetch và checkout bất kỳ mô-đun con lồng nhau nào, bạn có thể sử dụng `git submodule update --init --recursive` chắc chắn.

==== Làm việc trên một Dự án với các Mô-đun con

Bây giờ chúng ta có một bản sao của một dự án với các mô-đun con trong đó và sẽ cộng tác với các đồng đội của mình trên cả dự án chính và dự án mô-đun con.

===== Kéo vào các Thay đổi Thượng nguồn từ Điều khiển từ xa Mô-đun con

Mô hình đơn giản nhất của việc sử dụng các mô-đun con trong một dự án sẽ là nếu bạn chỉ đơn giản là tiêu thụ một dự án con và muốn nhận các bản cập nhật từ nó theo thời gian nhưng không thực sự sửa đổi bất cứ điều gì trong bản checkout của bạn.
Hãy đi qua một ví dụ đơn giản ở đó.

Nếu bạn muốn kiểm tra công việc mới trong một mô-đun con, bạn có thể đi vào thư mục và chạy `git fetch` và `git merge` nhánh thượng nguồn để cập nhật mã cục bộ.

[source,console]
----
$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -> origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)
----

Bây giờ nếu bạn quay lại dự án chính và chạy `git diff --submodule`, bạn có thể thấy rằng mô-đun con đã được cập nhật và nhận danh sách các cam kết đã được thêm vào nó.
Nếu bạn không muốn gõ `--submodule` mỗi lần bạn chạy `git diff`, bạn có thể đặt nó làm định dạng mặc định bằng cách đặt giá trị cấu hình `diff.submodule` thành "`log`".

[source,console]
----
$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  > more efficient db routine
  > better connection routine
----

Nếu bạn cam kết tại thời điểm này thì bạn sẽ khóa mô-đun con vào việc có mã mới khi những người khác cập nhật.

Cũng có một cách dễ dàng hơn để làm điều này, nếu bạn muốn không phải fetch và merge thủ công trong thư mục con.
Nếu bạn chạy `git submodule update --remote`, Git sẽ đi vào các mô-đun con của bạn và fetch và cập nhật cho bạn.

[source,console]
----
$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -> origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'
----

Lệnh này theo mặc định sẽ giả định rằng bạn muốn cập nhật checkout đến nhánh mặc định của kho lưu trữ mô-đun con từ xa (nhánh được trỏ bởi `HEAD` trên điều khiển từ xa).
Tuy nhiên, bạn có thể đặt điều này thành một cái gì đó khác nếu bạn muốn.
Ví dụ, nếu bạn muốn mô-đun con `DbConnector` theo dõi nhánh "`stable`" của kho lưu trữ đó, bạn có thể đặt nó trong tệp `.gitmodules` của mình (để mọi người khác cũng theo dõi nó), hoặc chỉ trong tệp `.git/config` cục bộ của bạn.
Hãy đặt nó trong tệp `.gitmodules`:

[source,console]
----
$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -> origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'
----

Nếu bạn bỏ qua `-f .gitmodules`, nó sẽ chỉ thực hiện thay đổi cho bạn, nhưng có lẽ hợp lý hơn khi theo dõi thông tin đó với kho lưu trữ để mọi người khác cũng làm như vậy.

Khi chúng ta chạy `git status` tại thời điểm này, Git sẽ hiển thị cho chúng ta thấy rằng chúng ta có "`new commits`" (các cam kết mới) trên mô-đun con.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")
----

Nếu bạn đặt cài đặt cấu hình `status.submodulesummary`, Git cũng sẽ hiển thị cho bạn một bản tóm tắt ngắn gọn về các thay đổi đối với các mô-đun con của bạn:

[source,console]
----
$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  > catch non-null terminated lines
----

Tại thời điểm này nếu bạn chạy `git diff`, chúng ta có thể thấy cả việc chúng ta đã sửa đổi tệp `.gitmodules` của mình và cũng có một số cam kết mà chúng ta đã kéo xuống và sẵn sàng cam kết vào dự án mô-đun con của mình.

[source,console]
----
$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

Điều này khá tuyệt vì chúng ta thực sự có thể thấy nhật ký các cam kết mà chúng ta sắp cam kết trong mô-đun con của mình.
Sau khi cam kết, bạn cũng có thể xem thông tin này sau khi thực tế khi bạn chạy `git log -p`.

[source,console]
----
$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

Git theo mặc định sẽ cố gắng cập nhật *tất cả* các mô-đun con của bạn khi bạn chạy `git submodule update --remote`.
Nếu bạn có nhiều mô-đun con, bạn có thể muốn chuyển tên của chỉ mô-đun con bạn muốn thử cập nhật.

===== Kéo các Thay đổi Thượng nguồn từ Điều khiển từ xa Dự án

Bây giờ hãy bước vào vị trí của cộng tác viên của bạn, người có bản sao cục bộ riêng của kho lưu trữ MainProject.
Chỉ cần thực hiện `git pull` để lấy các thay đổi mới được cam kết của bạn là không đủ:

[source,console]
----
$ git pull
From https://github.com/chaconinc/MainProject
   fb9093c..0a24cfc  master     -> origin/master
Fetching submodule DbConnector
From https://github.com/chaconinc/DbConnector
   c3f01dc..c87d55d  stable     -> origin/stable
Updating fb9093c..0a24cfc
Fast-forward
 .gitmodules         | 2 +-
 DbConnector         | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c87d55d...c3f01dc (4):
  < catch non-null terminated lines
  < more robust error handling
  < more efficient db routine
  < better connection routine

no changes added to commit (use "git add" and/or "git commit -a")
----

Theo mặc định, lệnh `git pull` fetch đệ quy các thay đổi mô-đun con, như chúng ta có thể thấy trong đầu ra của lệnh đầu tiên ở trên.
Tuy nhiên, nó không *cập nhật* các mô-đun con.
Điều này được hiển thị bởi đầu ra của lệnh `git status`, cho thấy mô-đun con bị "`modified`" (sửa đổi), và có "`new commits`" (cam kết mới).
Hơn nữa, các dấu ngoặc hiển thị các cam kết mới trỏ sang trái (<), cho biết rằng các cam kết này được ghi lại trong MainProject nhưng không có trong bản checkout `DbConnector` cục bộ.
Để hoàn tất cập nhật, bạn cần chạy `git submodule update`:

[source,console]
----
$ git submodule update --init --recursive
Submodule path 'vendor/plugins/demo': checked out '48679c6302815f6c76f1fe30625d795d9e55fc56'

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
----

Lưu ý rằng để an toàn, bạn nên chạy `git submodule update` với cờ `--init` trong trường hợp các cam kết MainProject bạn vừa kéo đã thêm các mô-đun con mới, và với cờ `--recursive` nếu bất kỳ mô-đun con nào có các mô-đun con lồng nhau.

Nếu bạn muốn tự động hóa quá trình này, bạn có thể thêm cờ `--recurse-submodules` vào lệnh `git pull` (kể từ Git 2.14).
Điều này sẽ làm cho Git chạy `git submodule update` ngay sau khi pull, đưa các mô-đun con vào trạng thái chính xác.
Hơn nữa, nếu bạn muốn làm cho Git luôn pull với `--recurse-submodules`, bạn có thể đặt tùy chọn cấu hình `submodule.recurse` thành `true` (điều này hoạt động cho `git pull` kể từ Git 2.15).
Tùy chọn này sẽ làm cho Git sử dụng cờ `--recurse-submodules` cho tất cả các lệnh hỗ trợ nó (ngoại trừ `clone`).

Có một tình huống đặc biệt có thể xảy ra khi kéo các bản cập nhật siêu dự án: có thể là kho lưu trữ thượng nguồn đã thay đổi URL của mô-đun con trong tệp `.gitmodules` trong một trong các cam kết bạn kéo.
Điều này có thể xảy ra ví dụ nếu dự án mô-đun con thay đổi nền tảng lưu trữ của nó.
Trong trường hợp đó, có khả năng `git pull --recurse-submodules`, hoặc `git submodule update`, sẽ thất bại nếu siêu dự án tham chiếu đến một cam kết mô-đun con không được tìm thấy trong điều khiển từ xa mô-đun con được cấu hình cục bộ trong kho lưu trữ của bạn.
Để khắc phục tình huống này, lệnh `git submodule sync` là bắt buộc:

[source,console]
----
# copy the new URL to your local config
$ git submodule sync --recursive
# update the submodule from the new URL
$ git submodule update --init --recursive
----

===== Làm việc trên một Mô-đun con

Rất có khả năng là nếu bạn đang sử dụng các mô-đun con, bạn đang làm như vậy vì bạn thực sự muốn làm việc trên mã trong mô-đun con cùng lúc với bạn đang làm việc trên mã trong dự án chính (hoặc trên một vài mô-đun con).
Nếu không, bạn có lẽ thay vào đó sẽ sử dụng một hệ thống quản lý phụ thuộc đơn giản hơn (chẳng hạn như Maven hoặc Rubygems).

Vì vậy, bây giờ hãy đi qua một ví dụ về việc thực hiện các thay đổi đối với mô-đun con cùng lúc với dự án chính và cam kết và xuất bản các thay đổi đó cùng một lúc.

Cho đến nay, khi chúng ta chạy lệnh `git submodule update` để fetch các thay đổi từ các kho lưu trữ mô-đun con, Git sẽ nhận các thay đổi và cập nhật các tệp trong thư mục con nhưng sẽ để lại kho lưu trữ con trong cái gọi là trạng thái "`detached HEAD`" (HEAD bị tách rời).
Điều này có nghĩa là không có nhánh làm việc cục bộ nào (như `master`, chẳng hạn) theo dõi các thay đổi.
Với việc không có nhánh làm việc nào theo dõi các thay đổi, điều đó có nghĩa là ngay cả khi bạn cam kết các thay đổi đối với mô-đun con, các thay đổi đó rất có thể sẽ bị mất lần sau khi bạn chạy `git submodule update`.
Bạn phải thực hiện một số bước bổ sung nếu bạn muốn các thay đổi trong một mô-đun con được theo dõi.

Để thiết lập mô-đun con của bạn để dễ dàng đi vào và hack, bạn cần làm hai việc.
Bạn cần đi vào từng mô-đun con và checkout một nhánh để làm việc.
Sau đó, bạn cần cho Git biết phải làm gì nếu bạn đã thực hiện các thay đổi và sau đó `git submodule update --remote` kéo vào công việc mới từ thượng nguồn.
Các tùy chọn là bạn có thể hợp nhất chúng vào công việc cục bộ của mình, hoặc bạn có thể thử rebase công việc cục bộ của mình lên trên các thay đổi mới.

Trước hết, hãy đi vào thư mục mô-đun con của chúng ta và checkout một nhánh.

[source,console]
----
$ cd DbConnector/
$ git checkout stable
Switched to branch 'stable'
----

Hãy thử cập nhật mô-đun con của chúng ta với tùy chọn "`merge`".
Để chỉ định nó thủ công, chúng ta chỉ cần thêm tùy chọn `--merge` vào cuộc gọi `update` của chúng ta.
Ở đây chúng ta sẽ thấy rằng đã có một thay đổi trên máy chủ cho mô-đun con này và nó được hợp nhất vào.

[source,console]
----
$ cd ..
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -> origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'
----

Nếu chúng ta đi vào thư mục `DbConnector`, chúng ta có các thay đổi mới đã được hợp nhất vào nhánh `stable` cục bộ của chúng ta.
Bây giờ hãy xem điều gì xảy ra khi chúng ta thực hiện thay đổi cục bộ của riêng mình đối với thư viện và ai đó khác đẩy một thay đổi khác lên thượng nguồn cùng một lúc.

[source,console]
----
$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'Unicode support'
[stable f906e16] Unicode support
 1 file changed, 1 insertion(+)
----

Bây giờ nếu chúng ta cập nhật mô-đun con của mình, chúng ta có thể thấy điều gì xảy ra khi chúng ta đã thực hiện một thay đổi cục bộ và thượng nguồn cũng có một thay đổi mà chúng ta cần kết hợp.

[source,console]
----
$ cd ..
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: Unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

Nếu bạn quên `--rebase` hoặc `--merge`, Git sẽ chỉ cập nhật mô-đun con thành bất cứ thứ gì có trên máy chủ và đặt lại dự án của bạn về trạng thái HEAD bị tách rời.

[source,console]
----
$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

Nếu điều này xảy ra, đừng lo lắng, bạn có thể đơn giản quay lại thư mục và checkout lại nhánh của mình (nhánh vẫn sẽ chứa công việc của bạn) và hợp nhất hoặc rebase `origin/stable` (hoặc bất kỳ nhánh từ xa nào bạn muốn) thủ công.

Nếu bạn chưa cam kết các thay đổi của mình trong mô-đun con và bạn chạy một `submodule update` sẽ gây ra sự cố, Git sẽ fetch các thay đổi nhưng không ghi đè lên công việc chưa được lưu trong thư mục mô-đun con của bạn.

[source,console]
----
$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -> origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

Nếu bạn đã thực hiện các thay đổi xung đột với một cái gì đó đã thay đổi ở thượng nguồn, Git sẽ cho bạn biết khi bạn chạy cập nhật.

[source,console]
----
$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

Bạn có thể đi vào thư mục mô-đun con và sửa xung đột giống như bạn thường làm.

[[_publishing_submodules]]
===== Xuất bản Thay đổi Mô-đun con

Bây giờ chúng ta có một số thay đổi trong thư mục mô-đun con của mình.
Một số trong số này được đưa vào từ thượng nguồn bởi các bản cập nhật của chúng ta và những cái khác được thực hiện cục bộ và chưa có sẵn cho bất kỳ ai khác vì chúng ta chưa đẩy chúng.

[source,console]
----
$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  > Merge from origin/stable
  > Update setup script
  > Unicode support
  > Remove unnecessary method
  > Add new option for conn pooling
----

Nếu chúng ta cam kết trong dự án chính và đẩy nó lên mà không đẩy các thay đổi mô-đun con lên, những người khác cố gắng checkout các thay đổi của chúng ta sẽ gặp rắc rối vì họ sẽ không có cách nào để lấy các thay đổi mô-đun con được phụ thuộc vào.
Những thay đổi đó sẽ chỉ tồn tại trên bản sao cục bộ của chúng ta.

Để đảm bảo điều này không xảy ra, bạn có thể yêu cầu Git kiểm tra xem tất cả các mô-đun con của bạn đã được đẩy đúng cách chưa trước khi đẩy dự án chính.
Lệnh `git push` nhận đối số `--recurse-submodules` có thể được đặt thành "`check`" hoặc "`on-demand`".
Tùy chọn "`check`" sẽ làm cho `push` đơn giản thất bại nếu bất kỳ thay đổi mô-đun con nào đã cam kết chưa được đẩy.

[source,console]
----
$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.
----

Như bạn có thể thấy, nó cũng cung cấp cho chúng ta một số lời khuyên hữu ích về những gì chúng ta có thể muốn làm tiếp theo.
Tùy chọn đơn giản là đi vào từng mô-đun con và đẩy thủ công đến các điều khiển từ xa để đảm bảo chúng có sẵn bên ngoài và sau đó thử đẩy lại lần này.
Nếu bạn muốn hành vi "`check`" xảy ra cho tất cả các lần đẩy, bạn có thể đặt hành vi này làm mặc định bằng cách thực hiện `git config push.recurseSubmodules check`.

Tùy chọn khác là sử dụng giá trị "`on-demand`", sẽ cố gắng làm điều này cho bạn.

[source,console]
----
$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -> stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -> master
----

Như bạn có thể thấy ở đó, Git đã đi vào mô-đun `DbConnector` và đẩy nó trước khi đẩy dự án chính.
Nếu việc đẩy mô-đun con đó thất bại vì lý do nào đó, việc đẩy dự án chính cũng sẽ thất bại.
Bạn có thể đặt hành vi này làm mặc định bằng cách thực hiện `git config push.recurseSubmodules on-demand`.

===== Hợp nhất Thay đổi Mô-đun con

Nếu bạn thay đổi một tham chiếu mô-đun con cùng lúc với người khác, bạn có thể gặp phải một số vấn đề.
Nghĩa là, nếu lịch sử mô-đun con đã phân kỳ và được cam kết vào các nhánh phân kỳ trong một siêu dự án, có thể mất một chút công sức để bạn sửa chữa.

Nếu một trong các cam kết là tổ tiên trực tiếp của cái kia (hợp nhất fast-forward), thì Git sẽ đơn giản chọn cái sau cho việc hợp nhất, vì vậy điều đó hoạt động tốt.

Tuy nhiên, Git sẽ không cố gắng thực hiện ngay cả một hợp nhất tầm thường cho bạn.
Nếu các cam kết mô-đun con phân kỳ và cần được hợp nhất, bạn sẽ nhận được một cái gì đó trông giống như thế này:

[source,console]
----
$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -> origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

Vì vậy, về cơ bản những gì đã xảy ra ở đây là Git đã tìm ra rằng hai nhánh ghi lại các điểm trong lịch sử của mô-đun con là phân kỳ và cần được hợp nhất.
Nó giải thích nó là "`merge following commits not found`" (hợp nhất các cam kết sau không tìm thấy), điều này gây nhầm lẫn nhưng chúng ta sẽ giải thích tại sao lại như vậy một chút nữa.

Để giải quyết vấn đề, bạn cần tìm ra trạng thái mà mô-đun con nên ở.
Thật kỳ lạ, Git không thực sự cung cấp cho bạn nhiều thông tin để giúp đỡ ở đây, thậm chí không phải là các SHA-1 của các cam kết của cả hai bên lịch sử.
May mắn thay, thật đơn giản để tìm ra.
Nếu bạn chạy `git diff` bạn có thể nhận được các SHA-1 của các cam kết được ghi lại trong cả hai nhánh bạn đang cố gắng hợp nhất.

[source,console]
----
$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
----

Vì vậy, trong trường hợp này, `eb41d76` là cam kết trong mô-đun con của chúng ta mà *chúng ta* có và `c771610` là cam kết mà thượng nguồn có.
Nếu chúng ta đi vào thư mục mô-đun con của mình, nó đã nên ở trên `eb41d76` vì việc hợp nhất sẽ không chạm vào nó.
Nếu vì lý do nào đó nó không phải vậy, bạn có thể đơn giản tạo và checkout một nhánh trỏ đến nó.

Điều quan trọng là SHA-1 của cam kết từ phía bên kia.
Đây là những gì bạn sẽ phải hợp nhất vào và giải quyết.
Bạn có thể chỉ cần thử hợp nhất với SHA-1 trực tiếp, hoặc bạn có thể tạo một nhánh cho nó và sau đó thử hợp nhất cái đó vào.
Chúng tôi sẽ đề xuất cái sau, ngay cả khi chỉ để tạo một thông điệp cam kết hợp nhất đẹp hơn.

Vì vậy, chúng ta sẽ đi vào thư mục mô-đun con của mình, tạo một nhánh có tên "`try-merge`" dựa trên SHA-1 thứ hai đó từ `git diff`, và hợp nhất thủ công.

[source,console]
----
$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610

$ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.
----

Chúng ta đã gặp một xung đột hợp nhất thực sự ở đây, vì vậy nếu chúng ta giải quyết nó và cam kết nó, thì chúng ta có thể đơn giản cập nhật dự án chính với kết quả.

[source,console]
----
$ vim src/main.c <1>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <2>
$ git diff <3>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <4>

$ git commit -m "Merge Tom's Changes" <5>
[master 10d2c60] Merge Tom's Changes
----

<1> Đầu tiên chúng ta giải quyết xung đột.
<2> Sau đó chúng ta quay lại thư mục dự án chính.
<3> Chúng ta có thể kiểm tra lại các SHA-1.
<4> Giải quyết mục nhập mô-đun con bị xung đột.
<5> Cam kết hợp nhất của chúng ta.

Nó có thể hơi khó hiểu, nhưng nó thực sự không quá khó.

Thú vị thay, có một trường hợp khác mà Git xử lý.
Nếu một cam kết hợp nhất tồn tại trong thư mục mô-đun con chứa *cả hai* cam kết trong lịch sử của nó, Git sẽ đề xuất nó cho bạn như một giải pháp khả thi.
Nó thấy rằng tại một thời điểm nào đó trong dự án mô-đun con, ai đó đã hợp nhất các nhánh chứa hai cam kết này, vì vậy có lẽ bạn sẽ muốn cái đó.

Đây là lý do tại sao thông báo lỗi từ trước là "`merge following commits not found`", bởi vì nó không thể làm *điều này*.
Thật khó hiểu vì ai sẽ mong đợi nó *cố gắng* làm điều này?

Nếu nó tìm thấy một cam kết hợp nhất chấp nhận được duy nhất, bạn sẽ thấy một cái gì đó giống như thế này:

[source,console]
----
$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

Lệnh được đề xuất mà Git đang cung cấp sẽ cập nhật chỉ mục như thể bạn đã chạy `git add` (làm sạch xung đột), sau đó cam kết.
Tuy nhiên, bạn có lẽ không nên làm điều này.
Bạn có thể dễ dàng đi vào thư mục mô-đun con, xem sự khác biệt là gì, fast-forward đến cam kết này, kiểm tra nó đúng cách, và sau đó cam kết nó.

[source,console]
----
$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forward to a common submodule child'
----

Điều này hoàn thành điều tương tự, nhưng ít nhất theo cách này bạn có thể xác minh rằng nó hoạt động và bạn có mã trong thư mục mô-đun con của mình khi bạn hoàn tất.

==== Mẹo Mô-đun con

Có một vài điều bạn có thể làm để làm việc với các mô-đun con dễ dàng hơn một chút.

===== Submodule Foreach

Có một lệnh mô-đun con `foreach` để chạy một lệnh tùy ý trong mỗi mô-đun con.
Điều này có thể thực sự hữu ích nếu bạn có một số lượng mô-đun con trong cùng một dự án.

Ví dụ, giả sử chúng ta muốn bắt đầu một tính năng mới hoặc sửa lỗi và chúng ta có công việc đang diễn ra trong một vài mô-đun con.
Chúng ta có thể dễ dàng cất giữ (stash) tất cả công việc trong tất cả các mô-đun con của mình.

[source,console]
----
$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable
----

Sau đó, chúng ta có thể tạo một nhánh mới và chuyển sang nó trong tất cả các mô-đun con của mình.

[source,console]
----
$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'
----

Bạn hiểu ý tưởng rồi đấy.
Một điều thực sự hữu ích bạn có thể làm là tạo ra một diff thống nhất đẹp về những gì đã thay đổi trong dự án chính của bạn và tất cả các dự án con của bạn.

[source,console]
----
$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&url, len, NULL, &out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;
----

Ở đây chúng ta có thể thấy rằng chúng ta đang định nghĩa một hàm trong một mô-đun con và gọi nó trong dự án chính.
Đây rõ ràng là một ví dụ đơn giản hóa, nhưng hy vọng nó cung cấp cho bạn một ý tưởng về cách điều này có thể hữu ích.

===== Các Bí danh Hữu ích (Useful Aliases)

Bạn có thể muốn thiết lập một số bí danh cho một số lệnh này vì chúng có thể khá dài và bạn không thể đặt các tùy chọn cấu hình cho hầu hết chúng để biến chúng thành mặc định.
Chúng ta đã đề cập đến việc thiết lập các bí danh Git trong <<ch02-git-basics-chapter#_git_aliases>>, nhưng đây là một ví dụ về những gì bạn có thể muốn thiết lập nếu bạn dự định làm việc với các mô-đun con trong Git nhiều.

[source,console]
----
$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'
----

Bằng cách này, bạn có thể chỉ cần chạy `git supdate` khi bạn muốn cập nhật các mô-đun con của mình, hoặc `git spush` để đẩy với kiểm tra phụ thuộc mô-đun con.

==== Các vấn đề với Mô-đun con

Tuy nhiên, việc sử dụng các mô-đun con không phải là không có trục trặc.

===== Chuyển nhánh

Ví dụ, chuyển nhánh với các mô-đun con trong đó cũng có thể khó khăn với các phiên bản Git cũ hơn Git 2.13.
Nếu bạn tạo một nhánh mới, thêm một mô-đun con ở đó, và sau đó chuyển trở lại một nhánh không có mô-đun con đó, bạn vẫn có thư mục mô-đun con dưới dạng một thư mục không được theo dõi:

[source,console]
----
$ git --version
git version 2.12.2

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)
----

Việc xóa thư mục không khó, nhưng có thể hơi khó hiểu khi có nó ở đó.
Nếu bạn xóa nó và sau đó chuyển trở lại nhánh có mô-đun con đó, bạn sẽ cần chạy `submodule update --init` để điền lại nó.

[source,console]
----
$ git clean -ffdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src
----

Một lần nữa, không thực sự quá khó, nhưng nó có thể hơi khó hiểu.

Các phiên bản Git mới hơn (Git >= 2.13) đơn giản hóa tất cả những điều này bằng cách thêm cờ `--recurse-submodules` vào lệnh `git checkout`, lệnh này sẽ lo việc đặt các mô-đun con vào trạng thái đúng cho nhánh chúng ta đang chuyển sang.

[source,console]
----
$ git --version
git version 2.13.3

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout --recurse-submodules master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

nothing to commit, working tree clean
----

Sử dụng cờ `--recurse-submodules` của `git checkout` cũng có thể hữu ích khi bạn làm việc trên một vài nhánh trong siêu dự án, mỗi nhánh có mô-đun con của bạn trỏ đến các cam kết khác nhau.
Thật vậy, nếu bạn chuyển đổi giữa các nhánh ghi lại mô-đun con tại các cam kết khác nhau, khi thực thi `git status`, mô-đun con sẽ xuất hiện dưới dạng "`modified`" (đã sửa đổi), và chỉ ra "`new commits`" (cam kết mới).
Đó là bởi vì trạng thái mô-đun con theo mặc định không được chuyển sang khi chuyển nhánh.

Điều này có thể thực sự gây nhầm lẫn, vì vậy, một ý tưởng tốt là luôn `git checkout --recurse-submodules` khi dự án của bạn có các mô-đun con.
Đối với các phiên bản Git cũ hơn không có cờ `--recurse-submodules`, sau khi checkout, bạn có thể sử dụng `git submodule update --init --recursive` để đưa các mô-đun con vào trạng thái đúng.

May mắn thay, bạn có thể bảo Git (>=2.14) luôn sử dụng cờ `--recurse-submodules` bằng cách đặt tùy chọn cấu hình `submodule.recurse`: `git config submodule.recurse true`.
Như đã lưu ý ở trên, điều này cũng sẽ làm cho Git đệ quy vào các mô-đun con cho mọi lệnh có tùy chọn `--recurse-submodules` (ngoại trừ `git clone`).

===== Chuyển từ thư mục con sang mô-đun con

Cảnh báo chính khác mà nhiều người gặp phải liên quan đến việc chuyển từ thư mục con sang mô-đun con.
Nếu bạn đang theo dõi các tệp trong dự án của mình và bạn muốn di chuyển chúng ra thành một mô-đun con, bạn phải cẩn thận nếu không Git sẽ nổi giận với bạn.
Giả sử rằng bạn có các tệp trong một thư mục con của dự án của mình, và bạn muốn chuyển nó thành một mô-đun con.
Nếu bạn xóa thư mục con và sau đó chạy `submodule add`, Git sẽ hét vào mặt bạn:

[source,console]
----
$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index
----

Bạn phải hủy tổ chức thư mục `CryptoLibrary` trước.
Sau đó, bạn có thể thêm mô-đun con:

[source,console]
----
$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

Bây giờ giả sử bạn đã làm điều đó trong một nhánh.
Nếu bạn cố gắng chuyển trở lại một nhánh nơi các tệp đó vẫn nằm trong cây thực tế thay vì một mô-đun con -- bạn sẽ nhận được lỗi này:

[source,console]
----
$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting
----

Bạn có thể buộc nó chuyển đổi với `checkout -f`, nhưng hãy cẩn thận rằng bạn không có các thay đổi chưa được lưu trong đó vì chúng có thể bị ghi đè bằng lệnh đó.

[source,console]
----
$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
----

Sau đó, khi bạn chuyển trở lại, bạn nhận được một thư mục `CryptoLibrary` trống vì lý do nào đó và `git submodule update` cũng có thể không sửa được nó.
Bạn có thể cần phải đi vào thư mục mô-đun con của mình và chạy `git checkout .` để lấy lại tất cả các tệp của mình.
Bạn có thể chạy lệnh này trong một tập lệnh `submodule foreach` để chạy nó cho nhiều mô-đun con.

Điều quan trọng cần lưu ý là các mô-đun con ngày nay giữ tất cả dữ liệu Git của chúng trong thư mục `.git` của dự án hàng đầu, vì vậy không giống như các phiên bản Git cũ hơn nhiều, việc phá hủy một thư mục mô-đun con sẽ không làm mất bất kỳ cam kết hoặc nhánh nào mà bạn đã có.

Với các công cụ này, các mô-đun con có thể là một phương pháp khá đơn giản và hiệu quả để phát triển trên một vài dự án liên quan nhưng vẫn riêng biệt cùng một lúc.
