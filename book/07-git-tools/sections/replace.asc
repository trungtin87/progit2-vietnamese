[[_replace]]
=== Thay thế

Như chúng ta đã nhấn mạnh trước đây, các đối tượng trong cơ sở dữ liệu đối tượng của Git là không thể thay đổi, nhưng Git cung cấp một cách thú vị để _giả vờ_ thay thế các đối tượng trong cơ sở dữ liệu của nó bằng các đối tượng khác.

Lệnh `replace` cho phép bạn chỉ định một đối tượng trong Git và nói "mỗi khi bạn tham chiếu đến đối tượng _này_, hãy giả vờ đó là một đối tượng _khác_".
Điều này hữu ích nhất để thay thế một cam kết trong lịch sử của bạn bằng một cam kết khác mà không cần phải xây dựng lại toàn bộ lịch sử bằng, chẳng hạn, `git filter-branch`.

Ví dụ, giả sử bạn có một lịch sử mã khổng lồ và muốn chia kho lưu trữ của mình thành một lịch sử ngắn cho các nhà phát triển mới và một lịch sử dài hơn và lớn hơn nhiều cho những người quan tâm đến khai thác dữ liệu.
Bạn có thể ghép một lịch sử này vào lịch sử khác bằng cách "thay thế" cam kết sớm nhất trong dòng mới bằng cam kết cuối cùng trong dòng cũ hơn.
Điều này rất hay vì nó có nghĩa là bạn không thực sự phải viết lại mọi cam kết trong lịch sử mới, như bạn thường phải làm để nối chúng lại với nhau (vì cha mẹ ảnh hưởng đến các SHA-1).

Hãy thử điều này.
Hãy lấy một kho lưu trữ hiện có, chia nó thành hai kho lưu trữ, một gần đây và một lịch sử, và sau đó chúng ta sẽ xem cách chúng ta có thể kết hợp lại chúng mà không cần sửa đổi các giá trị SHA-1 của các kho lưu trữ gần đây qua `replace`.

Chúng ta sẽ sử dụng một kho lưu trữ đơn giản với năm cam kết đơn giản:

[source,console]
----
$ git log --oneline
ef989d8 Fifth commit
c6e1e95 Fourth commit
9c68fdc Third commit
945704c Second commit
c1822cf First commit
----

Chúng ta muốn chia cái này thành hai dòng lịch sử.
Một dòng đi từ cam kết một đến cam kết bốn - đó sẽ là lịch sử.
Dòng thứ hai sẽ chỉ là các cam kết bốn và năm - đó sẽ là lịch sử gần đây.

.Ví dụ về lịch sử Git
image::images/replace1.png[Ví dụ về lịch sử Git]

Vâng, tạo lịch sử lịch sử rất dễ dàng, chúng ta có thể chỉ cần đặt một nhánh trong lịch sử và sau đó đẩy nhánh đó vào nhánh `master` của một kho lưu trữ từ xa mới.

[source,console]
----
$ git branch history c6e1e95
$ git log --oneline --decorate
ef989d8 (HEAD, master) Fifth commit
c6e1e95 (history) Fourth commit
9c68fdc Third commit
945704c Second commit
c1822cf First commit
----

.Tạo một nhánh `history` mới
image::images/replace2.png[Tạo một nhánh `history` mới]

Bây giờ chúng ta có thể đẩy nhánh `history` mới vào nhánh `master` của kho lưu trữ mới của chúng ta:

[source,console]
----
$ git remote add project-history https://github.com/schacon/project-history
$ git push project-history history:master
Counting objects: 12, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (12/12), 907 bytes, done.
Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
To git@github.com:schacon/project-history.git
 * [new branch]      history -> master
----

OK, vì vậy lịch sử của chúng ta đã được xuất bản.
Bây giờ phần khó hơn là cắt bớt lịch sử gần đây của chúng ta để nó nhỏ hơn.
Chúng ta cần một sự chồng chéo để chúng ta có thể thay thế một cam kết này bằng một cam kết tương đương trong cam kết kia, vì vậy chúng ta sẽ cắt bớt cái này chỉ còn các cam kết bốn và năm (vì vậy cam kết bốn chồng chéo).

[source,console]
----
$ git log --oneline --decorate
ef989d8 (HEAD, master) Fifth commit
c6e1e95 (history) Fourth commit
9c68fdc Third commit
945704c Second commit
c1822cf First commit
----

Trong trường hợp này, rất hữu ích khi tạo một cam kết cơ sở có hướng dẫn về cách mở rộng lịch sử, để các nhà phát triển khác biết phải làm gì nếu họ gặp cam kết đầu tiên trong lịch sử bị cắt bớt và cần thêm.
Vì vậy, những gì chúng ta sẽ làm là tạo một đối tượng cam kết ban đầu làm điểm cơ sở của chúng ta với các hướng dẫn, sau đó rebase các cam kết còn lại (bốn và năm) lên trên nó.

Để làm điều đó, chúng ta cần chọn một điểm để chia, đó là cam kết thứ ba, là `9c68fdc` trong SHA-speak.
Vì vậy, cam kết cơ sở của chúng ta sẽ dựa trên cây đó.
Chúng ta có thể tạo cam kết cơ sở của mình bằng lệnh `commit-tree`, lệnh này chỉ nhận một cây và sẽ trả về cho chúng ta một đối tượng cam kết SHA-1 hoàn toàn mới, không có cha mẹ.

[source,console]
----
$ echo 'Get history from blah blah blah' | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf
----

[NOTE]
=====
Lệnh `commit-tree` là một trong một tập hợp các lệnh thường được gọi là các lệnh 'plumbing'.
Đây là các lệnh không được thiết kế để sử dụng trực tiếp, mà thay vào đó được các lệnh Git *khác* sử dụng để thực hiện các công việc nhỏ hơn.
Trong những trường hợp chúng ta đang làm những điều kỳ lạ như thế này, chúng cho phép chúng ta làm những việc cấp thấp thực sự nhưng không dành cho việc sử dụng hàng ngày.
Bạn có thể đọc thêm về các lệnh plumbing trong <<ch10-git-internals#_plumbing_porcelain>>.
=====

.Tạo một cam kết cơ sở bằng `commit-tree`
image::images/replace3.png[Tạo một cam kết cơ sở bằng `commit-tree`]

OK, vì vậy bây giờ chúng ta có một cam kết cơ sở, chúng ta có thể rebase phần còn lại của lịch sử của chúng ta lên trên đó bằng `git rebase --onto`.
Đối số `--onto` sẽ là SHA-1 chúng ta vừa nhận được từ `commit-tree` và điểm rebase sẽ là cam kết thứ ba (cha của cam kết đầu tiên chúng ta muốn giữ lại, `9c68fdc`):

[source,console]
----
$ git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit
----

.Rebase lịch sử trên đỉnh cam kết cơ sở
image::images/replace4.png[Rebase lịch sử trên đỉnh cam kết cơ sở]

OK, vì vậy bây giờ chúng ta đã viết lại lịch sử gần đây của chúng ta trên đỉnh một cam kết cơ sở dùng một lần mà bây giờ có hướng dẫn về cách tái tạo toàn bộ lịch sử nếu chúng ta muốn.
Chúng ta có thể đẩy lịch sử mới đó vào một dự án mới và bây giờ khi mọi người sao chép kho lưu trữ đó, họ sẽ chỉ thấy hai cam kết gần đây nhất và sau đó là một cam kết cơ sở với hướng dẫn.

Bây giờ hãy chuyển vai trò sang một người đang sao chép dự án lần đầu tiên muốn toàn bộ lịch sử.
Để lấy dữ liệu lịch sử sau khi sao chép kho lưu trữ bị cắt bớt này, người ta sẽ phải thêm một remote thứ hai cho kho lưu trữ lịch sử và tìm nạp:

[source,console]
----
$ git clone https://github.com/schacon/project
$ cd project

$ git log --oneline master
e146b5f Fifth commit
81a708d Fourth commit
622e88e Get history from blah blah blah

$ git remote add project-history https://github.com/schacon/project-history
$ git fetch project-history
From https://github.com/schacon/project-history
 * [new branch]      master     -> project-history/master
----

Bây giờ cộng tác viên sẽ có các cam kết gần đây của họ trong nhánh `master` và các cam kết lịch sử trong nhánh `project-history/master`.

[source,console]
----
$ git log --oneline master
e146b5f Fifth commit
81a708d Fourth commit
622e88e Get history from blah blah blah

$ git log --oneline project-history/master
c6e1e95 Fourth commit
9c68fdc Third commit
945704c Second commit
c1822cf First commit
----

Để kết hợp chúng, bạn có thể chỉ cần gọi `git replace` với cam kết bạn muốn thay thế và sau đó là cam kết bạn muốn thay thế nó.
Vì vậy, chúng ta muốn thay thế cam kết "thứ tư" trong nhánh `master` bằng cam kết "thứ tư" trong nhánh `project-history/master`:

[source,console]
----
$ git replace 81a708d c6e1e95
----

Bây giờ, nếu bạn nhìn vào lịch sử của nhánh `master`, nó sẽ trông như thế này:

[source,console]
----
$ git log --oneline master
e146b5f Fifth commit
81a708d Fourth commit
9c68fdc Third commit
945704c Second commit
c1822cf First commit
----

Tuyệt vời phải không? Mà không cần phải thay đổi tất cả các SHA-1 ngược dòng, chúng ta đã có thể thay thế một cam kết trong lịch sử của chúng ta bằng một cam kết hoàn toàn khác và tất cả các công cụ bình thường (`bisect`, `blame`, v.v.) sẽ hoạt động như chúng ta mong đợi.

.Kết hợp các cam kết bằng `git replace`
image::images/replace5.png[Kết hợp các cam kết bằng `git replace`]

Điều thú vị là, nó vẫn hiển thị `81a708d` là SHA-1, mặc dù nó thực sự đang sử dụng dữ liệu cam kết `c6e1e95` mà chúng ta đã thay thế nó.
Ngay cả khi bạn chạy một lệnh như `cat-file`, nó sẽ hiển thị dữ liệu đã thay thế:

[source,console]
----
$ git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon <schacon@gmail.com> 1268712581 -0700
committer Scott Chacon <schacon@gmail.com> 1268712581 -0700

fourth commit
----

Hãy nhớ rằng cha mẹ thực sự của `81a708d` là cam kết giữ chỗ của chúng ta (`622e88e`), chứ không phải `9c68fdce` như nó nói ở đây.

Một điều thú vị khác là dữ liệu này được giữ trong các tham chiếu của chúng ta:

[source,console]
----
$ git for-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f31423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040
----

Điều này có nghĩa là dễ dàng chia sẻ bản thay thế của chúng ta với những người khác, bởi vì chúng ta có thể đẩy cái này lên máy chủ của chúng ta và những người khác có thể dễ dàng tải xuống nó.
Điều này không hữu ích lắm trong kịch bản ghép lịch sử mà chúng ta đã xem xét ở đây (vì mọi người dù sao cũng sẽ tải xuống cả hai lịch sử, vậy tại sao lại tách chúng ra?) nhưng nó có thể hữu ích trong các trường hợp khác.