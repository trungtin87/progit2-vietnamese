[[_bundling]]
=== Đóng gói

Mặc dù chúng ta đã đề cập đến các cách phổ biến để truyền dữ liệu Git qua mạng (HTTP, SSH, v.v.), thực ra còn một cách nữa để làm điều đó không được sử dụng phổ biến nhưng thực sự có thể khá hữu ích.

Git có khả năng "`đóng gói`" dữ liệu của mình vào một tệp duy nhất.
Điều này có thể hữu ích trong nhiều tình huống khác nhau.
Có thể mạng của bạn bị hỏng và bạn muốn gửi các thay đổi cho đồng nghiệp của mình.
Có lẽ bạn đang làm việc ở một nơi xa và không có quyền truy cập vào mạng cục bộ vì lý do bảo mật.
Có thể card không dây/ethernet của bạn vừa bị hỏng.
Có thể bạn không có quyền truy cập vào một máy chủ được chia sẻ vào lúc này, bạn muốn gửi email cập nhật cho ai đó và bạn không muốn chuyển 40 cam kết qua `format-patch`.

Đây là lúc lệnh `git bundle` có thể hữu ích.
Lệnh `bundle` sẽ đóng gói mọi thứ thường được đẩy qua dây bằng lệnh `git push` vào một tệp nhị phân mà bạn có thể gửi email cho ai đó hoặc đặt trên một ổ đĩa flash, sau đó giải nén vào một kho lưu trữ khác.

Hãy xem một ví dụ đơn giản.
Giả sử bạn có một kho lưu trữ với hai cam kết:

[source,console]
----
$ git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:10 2010 -0800

    Second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:01 2010 -0800

    First commit
----

Nếu bạn muốn gửi kho lưu trữ đó cho ai đó và bạn không có quyền truy cập vào một kho lưu trữ để đẩy đến, hoặc đơn giản là không muốn thiết lập một kho lưu trữ, bạn có thể đóng gói nó bằng `git bundle create`.

[source,console]
----
$ git bundle create repo.bundle HEAD master
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 441 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)
----

Bây giờ bạn có một tệp có tên `repo.bundle` có tất cả dữ liệu cần thiết để tạo lại nhánh `master` của kho lưu trữ.
Với lệnh `bundle`, bạn cần liệt kê mọi tham chiếu hoặc phạm vi cam kết cụ thể mà bạn muốn được bao gồm.
Nếu bạn dự định điều này sẽ được sao chép ở nơi khác, bạn cũng nên thêm HEAD làm tham chiếu như chúng ta đã làm ở đây.

Bạn có thể gửi email tệp `repo.bundle` này cho người khác, hoặc đặt nó trên một ổ USB và mang nó đi.

Ở phía bên kia, giả sử bạn được gửi tệp `repo.bundle` này và muốn làm việc trên dự án.
Bạn có thể sao chép từ tệp nhị phân vào một thư mục, giống như bạn làm từ một URL.

[source,console]
----
$ git clone repo.bundle repo
Cloning into 'repo'...
...
$ cd repo
$ git log --oneline
9a466c5 Second commit
b1ec324 First commit
----

Nếu bạn không bao gồm HEAD trong các tham chiếu, bạn cũng phải chỉ định `-b master` hoặc bất kỳ nhánh nào được bao gồm vì nếu không nó sẽ không biết nhánh nào để kiểm tra.

Bây giờ giả sử bạn thực hiện ba cam kết trên đó và muốn gửi lại các cam kết mới qua một gói trên một thanh USB hoặc email.

[source,console]
----
$ git log --oneline
71b84da Last commit - second repo
c99cf5b Fourth commit - second repo
7011d3d Third commit - second repo
9a466c5 Second commit
b1ec324 First commit
----

Đầu tiên chúng ta cần xác định phạm vi các cam kết chúng ta muốn bao gồm trong gói.
Không giống như các giao thức mạng tự động tìm ra tập hợp dữ liệu tối thiểu để truyền qua mạng cho chúng ta, chúng ta sẽ phải tự tìm ra điều này.
Bây giờ, bạn có thể chỉ cần làm điều tương tự và đóng gói toàn bộ kho lưu trữ, điều này sẽ hoạt động, nhưng tốt hơn là chỉ đóng gói sự khác biệt - chỉ ba cam kết chúng ta vừa thực hiện cục bộ.

Để làm điều đó, bạn sẽ phải tính toán sự khác biệt.
Như chúng ta đã mô tả trong <<ch07-git-tools#_commit_ranges>>, bạn có thể chỉ định một phạm vi các cam kết theo một số cách.
Để có được ba cam kết mà chúng ta có trong nhánh `master` của mình mà không có trong nhánh chúng ta đã sao chép ban đầu, chúng ta có thể sử dụng một cái gì đó như `origin/master..master` hoặc `master ^origin/master`.
Bạn có thể kiểm tra điều đó bằng lệnh `log`.

[source,console]
----
$ git log --oneline master ^origin/master
71b84da Last commit - second repo
c99cf5b Fourth commit - second repo
7011d3d Third commit - second repo
----

Vì vậy, bây giờ chúng ta đã có danh sách các cam kết chúng ta muốn bao gồm trong gói, hãy đóng gói chúng lại.
Chúng ta làm điều đó bằng lệnh `git bundle create`, cung cấp cho nó một tên tệp chúng ta muốn gói của mình và phạm vi các cam kết chúng ta muốn đi vào đó.

[source,console]
----
$ git bundle create commits.bundle master ^9a466c5
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 775 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)
----

Bây giờ chúng ta có một tệp `commits.bundle` trong thư mục của mình.
Nếu chúng ta lấy tệp đó và gửi cho đối tác của mình, cô ấy sau đó có thể nhập nó vào kho lưu trữ ban đầu, ngay cả khi nhiều công việc hơn đã được thực hiện ở đó trong khi chờ đợi.

Khi cô ấy nhận được gói, cô ấy có thể kiểm tra nó để xem nó chứa gì trước khi nhập nó vào kho lưu trữ của mình.
Lệnh đầu tiên là lệnh `bundle verify` sẽ đảm bảo tệp thực sự là một gói Git hợp lệ và bạn có tất cả các tổ tiên cần thiết để tái tạo nó một cách chính xác.

[source,console]
----
$ git bundle verify ../commits.bundle
The bundle contains 1 ref
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
The bundle requires these 1 ref
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle is okay
----

Nếu người đóng gói đã tạo một gói chỉ có hai cam kết cuối cùng họ đã thực hiện, thay vì cả ba, kho lưu trữ ban đầu sẽ không thể nhập nó, vì nó thiếu lịch sử cần thiết.
Lệnh `verify` sẽ trông như thế này thay thế:

[source,console]
----
$ git bundle verify ../commits-bad.bundle
error: Repository lacks these prerequisite commits:
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 Third commit - second repo
----

Tuy nhiên, gói đầu tiên của chúng ta là hợp lệ, vì vậy chúng ta có thể tìm nạp các cam kết từ nó.
Nếu bạn muốn xem các nhánh nào có trong gói có thể được nhập, cũng có một lệnh để chỉ liệt kê các đầu:

[source,console]
----
$ git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
----

Lệnh con `verify` cũng sẽ cho bạn biết các đầu.
Mục đích là để xem những gì có thể được kéo vào, vì vậy bạn có thể sử dụng các lệnh `fetch` hoặc `pull` để nhập các cam kết từ gói này.
Ở đây chúng ta sẽ tìm nạp nhánh `master` của gói vào một nhánh có tên `other-master` trong kho lưu trữ của chúng ta:

[source,console]
----
$ git fetch ../commits.bundle master:other-master
From ../commits.bundle
 * [new branch]      master     -> other-master
----

Bây giờ chúng ta có thể thấy rằng chúng ta có các cam kết đã nhập trên nhánh `other-master` cũng như bất kỳ cam kết nào chúng ta đã thực hiện trong khi chờ đợi trong nhánh `master` của riêng mình.

[source,console]
----
$ git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) Third commit - first repo
| * 71b84da (other-master) Last commit - second repo
| * c99cf5b Fourth commit - second repo
| * 7011d3d Third commit - second repo
|/
* 9a466c5 Second commit
* b1ec324 First commit
----

Vì vậy, `git bundle` có thể thực sự hữu ích để chia sẻ hoặc thực hiện các hoạt động kiểu mạng khi bạn không có mạng hoặc kho lưu trữ được chia sẻ phù hợp để làm điều đó.