[[_rewriting_history]]
=== Viết lại Lịch sử (Rewriting History)

Nhiều lần, khi làm việc với Git, bạn có thể muốn sửa lại lịch sử commit cục bộ của mình.
Một trong những điều tuyệt vời về Git là nó cho phép bạn đưa ra quyết định vào giây phút cuối cùng có thể.
Bạn có thể quyết định tệp nào sẽ đi vào commit nào ngay trước khi bạn commit với khu vực tổ chức, bạn có thể quyết định rằng bạn chưa có ý định làm việc trên một cái gì đó với `git stash`, và bạn có thể viết lại các commit đã xảy ra để chúng trông giống như chúng đã xảy ra theo một cách khác.
Điều này có thể liên quan đến việc thay đổi thứ tự của các commit, thay đổi thông điệp hoặc sửa đổi các tệp trong một commit, gộp (squash) lại với nhau hoặc tách rời các commit, hoặc xóa hoàn toàn các commit -- tất cả trước khi bạn chia sẻ công việc của mình với người khác.

Trong phần này, bạn sẽ thấy cách hoàn thành các tác vụ này để bạn có thể làm cho lịch sử commit của mình trông theo cách bạn muốn trước khi bạn chia sẻ nó với người khác.

[NOTE]
.Đừng đẩy công việc của bạn cho đến khi bạn hài lòng với nó
====
Một trong những quy tắc cốt yếu của Git là, vì rất nhiều công việc là cục bộ trong bản sao của bạn, bạn có rất nhiều tự do để viết lại lịch sử của mình _cục bộ_.
Tuy nhiên, một khi bạn đẩy công việc của mình, đó là một câu chuyện hoàn toàn khác, và bạn nên coi công việc đã đẩy là cuối cùng trừ khi bạn có lý do chính đáng để thay đổi nó.
Tóm lại, bạn nên tránh đẩy công việc của mình cho đến khi bạn hài lòng với nó và sẵn sàng chia sẻ nó với phần còn lại của thế giới.
====

[[_git_amend]]
==== Thay đổi Commit Cuối cùng

Thay đổi commit gần đây nhất của bạn có lẽ là việc viết lại lịch sử phổ biến nhất mà bạn sẽ làm.
Bạn sẽ thường muốn làm hai việc cơ bản đối với commit cuối cùng của mình: đơn giản là thay đổi thông điệp commit, hoặc thay đổi nội dung thực tế của commit bằng cách thêm, xóa và sửa đổi các tệp.

Nếu bạn chỉ muốn sửa đổi thông điệp commit cuối cùng của mình, điều đó thật dễ dàng:

[source,console]
----
$ git commit --amend
----

Lệnh trên tải thông điệp commit trước đó vào một phiên soạn thảo, nơi bạn có thể thực hiện các thay đổi đối với thông điệp, lưu các thay đổi đó và thoát.
Khi bạn lưu và đóng trình soạn thảo, trình soạn thảo sẽ viết một commit mới chứa thông điệp commit đã cập nhật đó và biến nó thành commit cuối cùng mới của bạn.

Mặt khác, nếu bạn muốn thay đổi _nội dung_ thực tế của commit cuối cùng của mình, quy trình hoạt động cơ bản theo cùng một cách -- trước tiên hãy thực hiện các thay đổi mà bạn nghĩ rằng bạn đã quên, tổ chức các thay đổi đó, và `git commit --amend` tiếp theo sẽ _thay thế_ commit cuối cùng đó bằng commit mới, được cải thiện của bạn.

Bạn cần cẩn thận với kỹ thuật này vì việc sửa đổi (amending) sẽ thay đổi SHA-1 của commit.
Nó giống như một rebase rất nhỏ -- đừng sửa đổi commit cuối cùng của bạn nếu bạn đã đẩy nó.

[TIP]
.Một commit đã sửa đổi có thể (hoặc không) cần một thông điệp commit đã sửa đổi
====
Khi bạn sửa đổi một commit, bạn có cơ hội thay đổi cả thông điệp commit và nội dung của commit.
Nếu bạn sửa đổi nội dung của commit một cách đáng kể, bạn gần như chắc chắn nên cập nhật thông điệp commit để phản ánh nội dung đã sửa đổi đó.

Mặt khác, nếu các sửa đổi của bạn là nhỏ nhặt (sửa lỗi đánh máy ngớ ngẩn hoặc thêm một tệp bạn quên tổ chức) sao cho thông điệp commit trước đó vẫn ổn, bạn có thể đơn giản thực hiện các thay đổi, tổ chức chúng, và tránh phiên soạn thảo không cần thiết hoàn toàn với:

[source,console]
----
$ git commit --amend --no-edit
----

====

[[_changing_multiple]]
==== Thay đổi Nhiều Thông điệp Commit

Để sửa đổi một commit nằm xa hơn trong lịch sử của bạn, bạn phải chuyển sang các công cụ phức tạp hơn.
Git không có công cụ sửa đổi lịch sử, nhưng bạn có thể sử dụng công cụ rebase để rebase một loạt các commit lên HEAD mà chúng dựa trên ban đầu thay vì di chuyển chúng sang một cái khác.
Với công cụ rebase tương tác, bạn có thể dừng lại sau mỗi commit bạn muốn sửa đổi và thay đổi thông điệp, thêm tệp, hoặc làm bất cứ điều gì bạn muốn.
Bạn có thể chạy rebase một cách tương tác bằng cách thêm tùy chọn `-i` vào `git rebase`.
Bạn phải chỉ ra bạn muốn viết lại các commit bao xa về phía sau bằng cách bảo lệnh commit nào để rebase lên.

Ví dụ, nếu bạn muốn thay đổi ba thông điệp commit cuối cùng, hoặc bất kỳ thông điệp commit nào trong nhóm đó, bạn cung cấp làm đối số cho `git rebase -i` cha mẹ của commit cuối cùng bạn muốn chỉnh sửa, đó là `HEAD~2^` hoặc `HEAD~3`.
Có thể dễ nhớ `~3` hơn vì bạn đang cố gắng chỉnh sửa ba commit cuối cùng, nhưng hãy nhớ rằng bạn thực sự đang chỉ định bốn commit trước đó, cha mẹ của commit cuối cùng bạn muốn chỉnh sửa:

[source,console]
----
$ git rebase -i HEAD~3
----

Hãy nhớ lại rằng đây là một lệnh rebasing -- mọi commit trong khoảng `HEAD~3..HEAD` với một thông điệp đã thay đổi _và tất cả các hậu duệ của nó_ sẽ được viết lại.
Đừng bao gồm bất kỳ commit nào bạn đã đẩy lên một máy chủ trung tâm -- làm như vậy sẽ gây nhầm lẫn cho các nhà phát triển khác bằng cách cung cấp một phiên bản thay thế của cùng một thay đổi.

Chạy lệnh này cung cấp cho bạn một danh sách các commit trong trình soạn thảo văn bản của bạn trông giống như thế này:

[source,console]
----
pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Điều quan trọng cần lưu ý là các commit này được liệt kê theo thứ tự ngược lại so với bạn thường thấy chúng sử dụng lệnh `log`.
Nếu bạn chạy một `log`, bạn thấy một cái gì đó giống như thế này:

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d Add cat-file
310154e Update README formatting and add blame
f7f3f6d Change my name a bit
----

Lưu ý thứ tự đảo ngược.
Rebase tương tác cung cấp cho bạn một kịch bản mà nó sẽ chạy.
Nó sẽ bắt đầu tại commit bạn chỉ định trên dòng lệnh (`HEAD~3`) và phát lại các thay đổi được giới thiệu trong mỗi commit này từ trên xuống dưới.
Nó liệt kê cái cũ nhất ở trên cùng, thay vì cái mới nhất, bởi vì đó là cái đầu tiên nó sẽ phát lại.

Bạn cần chỉnh sửa kịch bản để nó dừng lại tại commit bạn muốn chỉnh sửa.
Để làm như vậy, hãy thay đổi từ "`pick`" thành từ "`edit`" cho mỗi commit bạn muốn kịch bản dừng lại sau đó.
Ví dụ, để sửa đổi chỉ thông điệp commit thứ ba, bạn thay đổi tệp để trông giống như thế này:

[source,console]
----
edit f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file
----

Khi bạn lưu và thoát trình soạn thảo, Git tua lại bạn trở lại commit cuối cùng trong danh sách đó và thả bạn xuống dòng lệnh với thông điệp sau:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... Change my name a bit
You can amend the commit now, with

       git commit --amend

Once you're satisfied with your changes, run

       git rebase --continue
----

Những hướng dẫn này cho bạn biết chính xác phải làm gì.
Gõ:

[source,console]
----
$ git commit --amend
----

Thay đổi thông điệp commit, và thoát trình soạn thảo.
Sau đó, chạy:

[source,console]
----
$ git rebase --continue
----

Lệnh này sẽ áp dụng hai commit khác một cách tự động, và sau đó bạn đã hoàn tất.
Nếu bạn thay đổi `pick` thành `edit` trên nhiều dòng hơn, bạn có thể lặp lại các bước này cho mỗi commit bạn thay đổi thành `edit`.
Mỗi lần, Git sẽ dừng lại, cho phép bạn sửa đổi commit, và tiếp tục khi bạn hoàn tất.

==== Sắp xếp lại Commit

Bạn cũng có thể sử dụng rebase tương tác để sắp xếp lại hoặc xóa hoàn toàn các commit.
Nếu bạn muốn xóa commit "`Add cat-file`" và thay đổi thứ tự mà hai commit khác được giới thiệu, bạn có thể thay đổi kịch bản rebase từ thế này:

[source,console]
----
pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file
----

thành thế này:

[source,console]
----
pick 310154e Update README formatting and add blame
pick f7f3f6d Change my name a bit
----

Khi bạn lưu và thoát trình soạn thảo, Git tua lại nhánh của bạn về cha mẹ của các commit này, áp dụng `310154e` và sau đó `f7f3f6d`, và sau đó dừng lại.
Bạn thay đổi hiệu quả thứ tự của các commit đó và xóa hoàn toàn commit "`Add cat-file`".

[[_squashing]]
==== Gộp Commit (Squashing Commits)

Cũng có thể lấy một loạt các commit và gộp (squash) chúng xuống thành một commit đơn lẻ với công cụ rebasing tương tác.
Kịch bản đặt các hướng dẫn hữu ích trong thông điệp rebase:

[source,console]
----
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Nếu, thay vì "`pick`" hoặc "`edit`", bạn chỉ định "`squash`", Git áp dụng cả thay đổi đó và thay đổi ngay trước nó và làm cho bạn hợp nhất các thông điệp commit lại với nhau.
Vì vậy, nếu bạn muốn tạo một commit đơn lẻ từ ba commit này, bạn làm cho kịch bản trông giống như thế này:

[source,console]
----
pick f7f3f6d Change my name a bit
squash 310154e Update README formatting and add blame
squash a5f4a0d Add cat-file
----

Khi bạn lưu và thoát trình soạn thảo, Git áp dụng tất cả ba thay đổi và sau đó đưa bạn trở lại trình soạn thảo để hợp nhất ba thông điệp commit:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
Change my name a bit

# This is the 2nd commit message:

Update README formatting and add blame

# This is the 3rd commit message:

Add cat-file
----

Khi bạn lưu cái đó, bạn có một commit đơn lẻ giới thiệu các thay đổi của tất cả ba commit trước đó.

==== Tách một Commit

Tách một commit hoàn tác một commit và sau đó tổ chức một phần và commit bao nhiêu lần tùy ý bạn muốn kết thúc.
Ví dụ, giả sử bạn muốn tách commit ở giữa của ba commit của bạn.
Thay vì "`Update README formatting and add blame`", bạn muốn tách nó thành hai commit: "`Update README formatting`" cho cái đầu tiên, và "`Add blame`" cho cái thứ hai.
Bạn có thể làm điều đó trong kịch bản `rebase -i` bằng cách thay đổi hướng dẫn trên commit bạn muốn tách thành "`edit`":

[source,console]
----
pick f7f3f6d Change my name a bit
edit 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file
----

Sau đó, khi kịch bản thả bạn xuống dòng lệnh, bạn đặt lại (reset) commit đó, lấy các thay đổi đã được đặt lại, và tạo nhiều commit từ chúng.
Khi bạn lưu và thoát trình soạn thảo, Git tua lại về cha mẹ của commit đầu tiên trong danh sách của bạn, áp dụng commit đầu tiên (`f7f3f6d`), áp dụng commit thứ hai (`310154e`), và thả bạn xuống bảng điều khiển.
Ở đó, bạn có thể thực hiện một thiết lập lại hỗn hợp (mixed reset) của commit đó với `git reset HEAD^`, điều này hoàn tác hiệu quả commit đó và để lại các tệp đã sửa đổi chưa được tổ chức.
Bây giờ bạn có thể tổ chức và commit các tệp cho đến khi bạn có một vài commit, và chạy `git rebase --continue` khi bạn hoàn tất:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'Update README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'Add blame'
$ git rebase --continue
----

Git áp dụng commit cuối cùng (`a5f4a0d`) trong kịch bản, và lịch sử của bạn trông giống như thế này:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd Add cat-file
9b29157 Add blame
35cfb2b Update README formatting
f7f3f6d Change my name a bit
----

Điều này thay đổi các SHA-1 của ba commit gần đây nhất trong danh sách của bạn, vì vậy hãy chắc chắn rằng không có commit đã thay đổi nào hiển thị trong danh sách đó mà bạn đã đẩy đến một kho lưu trữ chia sẻ.
Lưu ý rằng commit cuối cùng (`f7f3f6d`) trong danh sách không thay đổi.
Mặc dù commit này được hiển thị trong kịch bản, bởi vì nó được đánh dấu là "`pick`" và đã được áp dụng trước bất kỳ thay đổi rebase nào, Git để commit không bị sửa đổi.

==== Xóa một commit

Nếu bạn muốn loại bỏ một commit, bạn có thể xóa nó bằng cách sử dụng kịch bản `rebase -i`.
Trong danh sách các commit, đặt từ "`drop`" trước commit bạn muốn xóa (hoặc chỉ cần xóa dòng đó khỏi kịch bản rebase):

[source,console]
----
pick 461cb2a This commit is OK
drop 5aecc10 This commit is broken
----

Do cách Git xây dựng các đối tượng commit, việc xóa hoặc thay đổi một commit sẽ gây ra việc viết lại tất cả các commit theo sau nó.
Bạn càng đi xa về phía sau trong lịch sử repo của mình, càng nhiều commit sẽ cần phải được tạo lại.
Điều này có thể gây ra rất nhiều xung đột hợp nhất nếu bạn có nhiều commit sau đó trong chuỗi phụ thuộc vào cái bạn vừa xóa.

Nếu bạn đi được một phần qua một rebase như thế này và quyết định đó không phải là một ý tưởng hay, bạn luôn có thể dừng lại.
Gõ `git rebase --abort`, và repo của bạn sẽ được trả lại trạng thái trước khi bạn bắt đầu rebase.

Nếu bạn hoàn thành một rebase và quyết định đó không phải là những gì bạn muốn, bạn có thể sử dụng `git reflog` để khôi phục một phiên bản cũ hơn của nhánh của bạn.
Xem <<ch10-git-internals#_data_recovery>> để biết thêm thông tin về lệnh `reflog`.

[NOTE]
====
Drew DeVault đã thực hiện một hướng dẫn thực hành thực tế với các bài tập để học cách sử dụng `git rebase`.
Bạn có thể tìm thấy nó tại: https://git-rebase.io/[^]
====

==== Phương án Hạt nhân: filter-branch

Có một tùy chọn viết lại lịch sử khác mà bạn có thể sử dụng nếu bạn cần viết lại một số lượng lớn các commit theo một cách có thể viết kịch bản -- ví dụ, thay đổi địa chỉ email của bạn trên toàn cầu hoặc xóa một tệp khỏi mọi commit.
Lệnh là `filter-branch`, và nó có thể viết lại những vùng lớn lịch sử của bạn, vì vậy bạn có lẽ không nên sử dụng nó trừ khi dự án của bạn chưa công khai và những người khác chưa dựa công việc vào các commit bạn sắp viết lại.
Tuy nhiên, nó có thể rất hữu ích.
Bạn sẽ tìm hiểu một vài cách sử dụng phổ biến để bạn có thể có ý tưởng về một số điều nó có khả năng làm.

[CAUTION]
====
`git filter-branch` có nhiều cạm bẫy, và không còn là cách được khuyến nghị để viết lại lịch sử.
Thay vào đó, hãy xem xét sử dụng `git-filter-repo`, là một kịch bản Python thực hiện công việc tốt hơn cho hầu hết các ứng dụng mà bạn thường chuyển sang `filter-branch`.
Tài liệu và mã nguồn của nó có thể được tìm thấy tại https://github.com/newren/git-filter-repo[^].
====

[[_removing_file_every_commit]]
===== Xóa một Tệp khỏi Mọi Commit

Điều này xảy ra khá thường xuyên.
Ai đó vô tình commit một tệp nhị phân khổng lồ với một lệnh `git add .` thiếu suy nghĩ, và bạn muốn xóa nó ở mọi nơi.
Có lẽ bạn vô tình commit một tệp chứa mật khẩu, và bạn muốn làm cho dự án của mình thành mã nguồn mở.
`filter-branch` là công cụ bạn có lẽ muốn sử dụng để làm sạch toàn bộ lịch sử của mình.
Để xóa một tệp có tên `passwords.txt` khỏi toàn bộ lịch sử của bạn, bạn có thể sử dụng tùy chọn `--tree-filter` cho `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

Tùy chọn `--tree-filter` chạy lệnh được chỉ định sau mỗi lần checkout của dự án và sau đó commit lại kết quả.
Trong trường hợp này, bạn xóa một tệp gọi là `passwords.txt` khỏi mọi ảnh chụp nhanh, cho dù nó có tồn tại hay không.
Nếu bạn muốn xóa tất cả các tệp sao lưu trình soạn thảo vô tình được commit, bạn có thể chạy một cái gì đó như `git filter-branch --tree-filter 'rm -f *~' HEAD`.

Bạn sẽ có thể xem Git viết lại các cây và commit và sau đó di chuyển con trỏ nhánh ở cuối.
Nói chung là một ý tưởng tốt để làm điều này trong một nhánh thử nghiệm và sau đó hard-reset nhánh `master` của bạn sau khi bạn đã xác định kết quả là những gì bạn thực sự muốn.
Để chạy `filter-branch` trên tất cả các nhánh của bạn, bạn có thể truyền `--all` cho lệnh.

===== Làm cho một Thư mục con thành Gốc Mới

Giả sử bạn đã thực hiện một lần nhập từ một hệ thống kiểm soát nguồn khác và có các thư mục con không có ý nghĩa (`trunk`, `tags`, v.v.).
Nếu bạn muốn làm cho thư mục con `trunk` trở thành gốc dự án mới cho mọi commit, `filter-branch` cũng có thể giúp bạn làm điều đó:

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Bây giờ gốc dự án mới của bạn là những gì đã ở trong thư mục con `trunk` mỗi lần.
Git cũng sẽ tự động xóa các commit không ảnh hưởng đến thư mục con.

===== Thay đổi Địa chỉ Email Toàn cầu

Một trường hợp phổ biến khác là bạn quên chạy `git config` để đặt tên và địa chỉ email của mình trước khi bạn bắt đầu làm việc, hoặc có lẽ bạn muốn mở mã nguồn một dự án tại nơi làm việc và thay đổi tất cả các địa chỉ email công việc của bạn thành địa chỉ cá nhân của bạn.
Trong mọi trường hợp, bạn cũng có thể thay đổi địa chỉ email trong nhiều commit theo lô với `filter-branch`.
Bạn cần cẩn thận chỉ thay đổi các địa chỉ email là của bạn, vì vậy bạn sử dụng `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

Điều này đi qua và viết lại mọi commit để có địa chỉ mới của bạn.
Bởi vì các commit chứa các giá trị SHA-1 của cha mẹ chúng, lệnh này thay đổi mọi SHA-1 commit trong lịch sử của bạn, không chỉ những cái có địa chỉ email phù hợp.
