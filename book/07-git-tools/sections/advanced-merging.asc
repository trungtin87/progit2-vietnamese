[[_advanced_merging]]
=== Hợp nhất Nâng cao

Việc hợp nhất trong Git thường khá dễ dàng.
Vì Git giúp dễ dàng hợp nhất một nhánh khác nhiều lần, điều đó có nghĩa là bạn có thể có một nhánh sống rất lâu nhưng bạn có thể giữ nó được cập nhật khi bạn đi, giải quyết các xung đột nhỏ thường xuyên, thay vì bị bất ngờ bởi một xung đột khổng lồ vào cuối chuỗi.

Tuy nhiên, đôi khi các xung đột phức tạp vẫn xảy ra.
Không giống như một số hệ thống kiểm soát phiên bản khác, Git không cố gắng tỏ ra quá thông minh về việc giải quyết xung đột hợp nhất.
Triết lý của Git là thông minh trong việc xác định khi nào một giải pháp hợp nhất là không mơ hồ, nhưng nếu có xung đột, nó không cố gắng tỏ ra thông minh về việc tự động giải quyết nó.
Do đó, nếu bạn đợi quá lâu để hợp nhất hai nhánh phân kỳ nhanh chóng, bạn có thể gặp phải một số vấn đề.

Trong phần này, chúng ta sẽ xem xét một số vấn đề đó có thể là gì và những công cụ nào Git cung cấp cho bạn để giúp xử lý những tình huống phức tạp hơn này.
Chúng ta cũng sẽ đề cập đến một số loại hợp nhất khác nhau, không tiêu chuẩn mà bạn có thể thực hiện, cũng như xem cách rút lại các lần hợp nhất bạn đã thực hiện.

==== Xung đột Hợp nhất

Mặc dù chúng ta đã đề cập đến một số điều cơ bản về việc giải quyết xung đột hợp nhất trong <<ch03-git-branching#_basic_merge_conflicts>>, đối với các xung đột phức tạp hơn, Git cung cấp một vài công cụ để giúp bạn tìm hiểu những gì đang xảy ra và cách xử lý xung đột tốt hơn.

Trước hết, nếu có thể, hãy cố gắng đảm bảo thư mục làm việc của bạn sạch sẽ trước khi thực hiện một hợp nhất có thể có xung đột.
Nếu bạn có công việc đang dang dở, hãy cam kết nó vào một nhánh tạm thời hoặc cất giữ nó.
Điều này giúp bạn có thể hoàn tác _bất cứ điều gì_ bạn thử ở đây.
Nếu bạn có những thay đổi chưa được lưu trong thư mục làm việc của mình khi bạn thử một hợp nhất, một số mẹo này có thể giúp bạn bảo tồn công việc đó.

Hãy cùng xem một ví dụ rất đơn giản.
Chúng ta có một tệp Ruby siêu đơn giản in ra 'hello world'.

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
----

Trong kho lưu trữ của chúng ta, chúng ta tạo một nhánh mới có tên `whitespace` và tiến hành thay đổi tất cả các kết thúc dòng Unix thành kết thúc dòng DOS, về cơ bản là thay đổi mọi dòng của tệp, nhưng chỉ với khoảng trắng.
Sau đó, chúng ta thay đổi dòng "`hello world`" thành "`hello mundo`".

[source,console]
----
$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'Convert hello.rb to DOS'
[whitespace 3270f76] Convert hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'Use Spanish instead of English'
[whitespace 6d338d2] Use Spanish instead of English
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Bây giờ chúng ta chuyển về nhánh `master` của mình và thêm một số tài liệu cho hàm.

[source,console]
----
$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'Add comment documenting the function'
[master bec6336] Add comment documenting the function
 1 file changed, 1 insertion(+)
----

Bây giờ chúng ta cố gắng hợp nhất nhánh `whitespace` của mình và chúng ta sẽ gặp xung đột vì các thay đổi khoảng trắng.

[source,console]
----
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

[[_abort_merge]]
===== Hủy bỏ một Hợp nhất

Bây giờ chúng ta có một vài lựa chọn.
Đầu tiên, hãy xem cách thoát khỏi tình huống này.
Nếu có lẽ bạn không mong đợi xung đột và chưa muốn giải quyết tình hình ngay lập tức, bạn có thể chỉ cần rút lại việc hợp nhất bằng `git merge --abort`.

[source,console]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

Tùy chọn `git merge --abort` cố gắng hoàn nguyên về trạng thái của bạn trước khi bạn chạy hợp nhất.
Những trường hợp duy nhất mà nó có thể không thể làm điều này một cách hoàn hảo là nếu bạn có những thay đổi chưa được cất giữ, chưa được cam kết trong thư mục làm việc của mình khi bạn chạy nó, nếu không thì nó sẽ hoạt động tốt.

Nếu vì lý do nào đó bạn chỉ muốn bắt đầu lại, bạn cũng có thể chạy `git reset --hard HEAD`, và kho lưu trữ của bạn sẽ trở lại trạng thái đã cam kết cuối cùng.
Hãy nhớ rằng bất kỳ công việc chưa được cam kết nào cũng sẽ bị mất, vì vậy hãy chắc chắn rằng bạn không muốn bất kỳ thay đổi nào của mình.

===== Bỏ qua Khoảng trắng

Trong trường hợp cụ thể này, các xung đột liên quan đến khoảng trắng.
Chúng ta biết điều này bởi vì trường hợp này đơn giản, nhưng cũng khá dễ dàng để nhận biết trong các trường hợp thực tế khi xem xét xung đột vì mọi dòng đều bị xóa ở một bên và được thêm lại ở bên kia.
Theo mặc định, Git thấy tất cả các dòng này đã bị thay đổi, vì vậy nó không thể hợp nhất các tệp.

Tuy nhiên, chiến lược hợp nhất mặc định có thể nhận các đối số, và một vài trong số đó là về việc bỏ qua các thay đổi khoảng trắng một cách hợp lý.
Nếu bạn thấy rằng bạn có nhiều vấn đề về khoảng trắng trong một hợp nhất, bạn có thể chỉ cần hủy bỏ nó và thực hiện lại, lần này với `-Xignore-all-space` hoặc `-Xignore-space-change`.
Tùy chọn đầu tiên bỏ qua khoảng trắng _hoàn toàn_ khi so sánh các dòng, tùy chọn thứ hai coi các chuỗi của một hoặc nhiều ký tự khoảng trắng là tương đương.

[source,console]
----
$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Vì trong trường hợp này, các thay đổi tệp thực tế không xung đột, một khi chúng ta bỏ qua các thay đổi khoảng trắng, mọi thứ sẽ hợp nhất tốt.

Đây là một cứu cánh nếu bạn có ai đó trong nhóm của mình thỉnh thoảng thích định dạng lại mọi thứ từ dấu cách thành tab hoặc ngược lại.

[[_manual_remerge]]
===== Hợp nhất lại Tệp Thủ công

Mặc dù Git xử lý việc tiền xử lý khoảng trắng khá tốt, nhưng có những loại thay đổi khác mà có lẽ Git không thể xử lý tự động, nhưng là các bản sửa lỗi có thể lập trình được.
Ví dụ, hãy giả vờ rằng Git không thể xử lý thay đổi khoảng trắng và chúng ta cần phải làm điều đó bằng tay.

Những gì chúng ta thực sự cần làm là chạy tệp chúng ta đang cố gắng hợp nhất qua một chương trình `dos2unix` trước khi thử hợp nhất tệp thực tế.
Vậy làm thế nào chúng ta có thể làm điều đó?

Đầu tiên, chúng ta vào trạng thái xung đột hợp nhất.
Sau đó, chúng ta muốn lấy các bản sao của phiên bản tệp của mình, phiên bản của họ (từ nhánh chúng ta đang hợp nhất) và phiên bản chung (từ nơi cả hai bên phân nhánh).
Sau đó, chúng ta muốn sửa chữa bên của họ hoặc bên của chúng ta và thử lại việc hợp nhất chỉ cho tệp đơn này.

Việc lấy ba phiên bản tệp thực sự khá dễ dàng.
Git lưu trữ tất cả các phiên bản này trong chỉ mục dưới dạng "`stages`" mà mỗi phiên bản đều có các số được liên kết với chúng.
Giai đoạn 1 là tổ tiên chung, giai đoạn 2 là phiên bản của bạn và giai đoạn 3 là từ `MERGE_HEAD`, phiên bản bạn đang hợp nhất ("`của họ`").

Bạn có thể trích xuất một bản sao của mỗi phiên bản của tệp xung đột này bằng lệnh `git show` và một cú pháp đặc biệt.

[source,console]
----
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
----

Nếu bạn muốn hardcore hơn một chút, bạn cũng có thể sử dụng lệnh `ls-files -u` để lấy các SHA-1 thực tế của các blob Git cho mỗi tệp này.

[source,console]
----
$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1\thello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2\thello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3\thello.rb
----

`:1:hello.rb` chỉ là một cách viết tắt để tra cứu SHA-1 blob đó.

Bây giờ chúng ta đã có nội dung của cả ba giai đoạn trong thư mục làm việc của mình, chúng ta có thể sửa chữa thủ công của họ để khắc phục sự cố khoảng trắng và hợp nhất lại tệp bằng lệnh `git merge-file` ít được biết đến, lệnh này làm chính xác điều đó.

[source,console]
----
$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
 end

 hello()
----

Tại thời điểm này, chúng ta đã hợp nhất tệp một cách tốt đẹp.
Trên thực tế, điều này hoạt động tốt hơn tùy chọn `ignore-space-change` vì điều này thực sự khắc phục các thay đổi khoảng trắng trước khi hợp nhất thay vì chỉ bỏ qua chúng.
Trong hợp nhất `ignore-space-change`, chúng ta thực sự đã kết thúc với một vài dòng có kết thúc dòng DOS, làm cho mọi thứ bị lẫn lộn.

Nếu bạn muốn có một ý tưởng trước khi hoàn tất cam kết này về những gì đã thực sự thay đổi giữa một bên hoặc bên kia, bạn có thể yêu cầu `git diff` so sánh những gì có trong thư mục làm việc của bạn mà bạn sắp cam kết là kết quả của việc hợp nhất với bất kỳ giai đoạn nào trong số này.
Hãy cùng xem tất cả chúng.

Để so sánh kết quả của bạn với những gì bạn đã có trong nhánh của mình trước khi hợp nhất, nói cách khác, để xem những gì việc hợp nhất đã giới thiệu, bạn có thể chạy `git diff --ours`:

[source,console]
----
$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Vì vậy, ở đây chúng ta có thể dễ dàng thấy rằng những gì đã xảy ra trong nhánh của chúng ta, những gì chúng ta thực sự đang giới thiệu vào tệp này với lần hợp nhất này, là thay đổi dòng đơn đó.

Nếu chúng ta muốn xem kết quả của việc hợp nhất khác với những gì ở phía họ như thế nào, bạn có thể chạy `git diff --theirs`.
Trong ví dụ này và ví dụ sau, chúng ta phải sử dụng `-b` để loại bỏ khoảng trắng vì chúng ta đang so sánh nó với những gì có trong Git, chứ không phải tệp `hello.theirs.rb` đã được làm sạch của chúng ta.

[source,console]
----
$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end
----

Cuối cùng, bạn có thể xem tệp đã thay đổi như thế nào từ cả hai phía với `git diff --base`.

[source,console]
----
$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Tại thời điểm này, chúng ta có thể sử dụng lệnh `git clean` để dọn dẹp các tệp bổ sung mà chúng ta đã tạo để thực hiện việc hợp nhất thủ công nhưng không còn cần nữa.

[source,console]
----
$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb
----

[[_checking_out_conflicts]]
===== Kiểm tra Xung đột

Có lẽ chúng ta không hài lòng với giải pháp tại thời điểm này vì lý do nào đó, hoặc có thể việc chỉnh sửa thủ công một hoặc cả hai bên vẫn không hoạt động tốt và chúng ta cần thêm ngữ cảnh.

Hãy thay đổi ví dụ một chút.
Đối với ví dụ này, chúng ta có hai nhánh sống lâu hơn, mỗi nhánh có một vài cam kết trong đó nhưng tạo ra một xung đột nội dung hợp pháp khi được hợp nhất.

[source,console]
----
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) Update README
* 9af9d3b Create README
* 694971d Update phrase to 'hola world'
| * e3eb223 (mundo) Add more tests
| * 7cff591 Create initial testing script
| * c3ffff1 Change text to 'hello mundo'
|/
* b7dcc89 Initial hello world code
----

Bây giờ chúng ta có ba cam kết duy nhất chỉ tồn tại trên nhánh `master` và ba cam kết khác tồn tại trên nhánh `mundo`.
Nếu chúng ta cố gắng hợp nhất nhánh `mundo` vào, chúng ta sẽ gặp xung đột.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

Chúng ta muốn xem xung đột hợp nhất là gì.
Nếu chúng ta mở tệp, chúng ta sẽ thấy một cái gì đó như thế này:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
----

Cả hai bên của việc hợp nhất đều đã thêm nội dung vào tệp này, nhưng một số cam kết đã sửa đổi tệp ở cùng một nơi gây ra xung đột này.

Hãy khám phá một vài công cụ mà bạn hiện có để xác định xung đột này đã xảy ra như thế nào.
Có lẽ không rõ ràng chính xác bạn nên khắc phục xung đột này như thế nào.
Bạn cần thêm ngữ cảnh.

Một công cụ hữu ích là `git checkout` với tùy chọn `--conflict`.
Điều này sẽ kiểm tra lại tệp và thay thế các dấu xung đột hợp nhất.
Điều này có thể hữu ích nếu bạn muốn đặt lại các dấu và thử giải quyết chúng lại.

Bạn có thể chuyển `--conflict` hoặc `diff3` hoặc `merge` (là mặc định).
Nếu bạn chuyển nó `diff3`, Git sẽ sử dụng một phiên bản hơi khác của các dấu xung đột, không chỉ cung cấp cho bạn các phiên bản "`của chúng ta`" và "`của họ`", mà còn cả phiên bản "`cơ sở`" cùng dòng để cung cấp cho bạn nhiều ngữ cảnh hơn.

[source,console]
----
$ git checkout --conflict=diff3 hello.rb
----

Sau khi chúng ta chạy lệnh đó, tệp sẽ trông như thế này thay thế:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
----

Nếu bạn thích định dạng này, bạn có thể đặt nó làm mặc định cho các xung đột hợp nhất trong tương lai bằng cách đặt cài đặt `merge.conflictstyle` thành `diff3`.

[source,console]
----
$ git config --global merge.conflictstyle diff3
----

Lệnh `git checkout` cũng có thể nhận các tùy chọn `--ours` và `--theirs`, đây có thể là một cách rất nhanh để chỉ chọn một bên hoặc bên kia mà không cần hợp nhất mọi thứ.

Điều này có thể đặc biệt hữu ích đối với các xung đột của các tệp nhị phân nơi bạn có thể chỉ cần chọn một bên, hoặc nơi bạn chỉ muốn hợp nhất một số tệp nhất định từ một nhánh khác -- bạn có thể thực hiện việc hợp nhất và sau đó kiểm tra một số tệp nhất định từ một bên hoặc bên kia trước khi cam kết.

[[_merge_log]]
===== Nhật ký Hợp nhất

Một công cụ hữu ích khác khi giải quyết xung đột hợp nhất là `git log`.
Điều này có thể giúp bạn có được ngữ cảnh về những gì có thể đã góp phần vào các xung đột.
Xem lại một chút lịch sử để nhớ tại sao hai dòng phát triển lại chạm vào cùng một khu vực mã đôi khi có thể rất hữu ích.

Để có được danh sách đầy đủ tất cả các cam kết duy nhất đã được bao gồm trong cả hai nhánh liên quan đến việc hợp nhất này, chúng ta có thể sử dụng cú pháp "`ba chấm`" mà chúng ta đã học trong <<ch07-git-tools#_triple_dot>>.

[source,console]
----
$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 Update README
< 9af9d3b Create README
< 694971d Update phrase to 'hola world'
> e3eb223 Add more tests
> 7cff591 Create initial testing script
> c3ffff1 Change text to 'hello mundo'
----

Đó là một danh sách tốt của sáu cam kết tổng cộng có liên quan, cũng như dòng phát triển nào mà mỗi cam kết thuộc về.

Tuy nhiên, chúng ta có thể đơn giản hóa điều này hơn nữa để cung cấp cho chúng ta ngữ cảnh cụ thể hơn nhiều.
Nếu chúng ta thêm tùy chọn `--merge` vào `git log`, nó sẽ chỉ hiển thị các cam kết ở cả hai bên của việc hợp nhất chạm vào một tệp hiện đang bị xung đột.

[source,console]
----
$ git log --oneline --left-right --merge
< 694971d Update phrase to 'hola world'
> c3ffff1 Change text to 'hello mundo'
----

Nếu bạn chạy lệnh đó với tùy chọn `-p`, bạn chỉ nhận được các diff cho tệp đã kết thúc trong xung đột.
Điều này có thể _thực sự_ hữu ích trong việc nhanh chóng cung cấp cho bạn ngữ cảnh bạn cần để giúp hiểu tại sao một cái gì đó xung đột và cách giải quyết nó một cách thông minh hơn.

===== Định dạng Diff Kết hợp

Vì Git tổ chức bất kỳ kết quả hợp nhất nào thành công, khi bạn chạy `git diff` trong khi ở trạng thái hợp nhất bị xung đột, bạn chỉ nhận được những gì hiện vẫn còn trong xung đột.
Điều này có thể hữu ích để xem bạn vẫn còn phải giải quyết những gì.

Khi bạn chạy `git diff` ngay sau một xung đột hợp nhất, nó sẽ cung cấp cho bạn thông tin ở một định dạng đầu ra diff khá độc đáo.

[source,console]
----
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
+  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
----

Định dạng này được gọi là "`Diff Kết hợp`" và cung cấp cho bạn hai cột dữ liệu bên cạnh mỗi dòng.
Cột đầu tiên cho bạn biết dòng đó có khác biệt (được thêm hoặc xóa) giữa nhánh "`của chúng ta`" và tệp trong thư mục làm việc của bạn hay không và cột thứ hai làm điều tương tự giữa nhánh "`của họ`" và bản sao thư mục làm việc của bạn.

Vì vậy, trong ví dụ đó, bạn có thể thấy rằng các dòng `<<<<<<<` và `>>>>>>>` có trong bản sao làm việc nhưng không có ở cả hai bên của việc hợp nhất.
Điều này có ý nghĩa vì công cụ hợp nhất đã dán chúng vào đó để cung cấp ngữ cảnh cho chúng ta, nhưng chúng ta được mong đợi sẽ xóa chúng.

Nếu chúng ta giải quyết xung đột và chạy lại `git diff`, chúng ta sẽ thấy điều tương tự, nhưng nó hữu ích hơn một chút.

[source,console]
----
$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
-  puts 'hello mundo'
+  puts 'hola mundo'
  end

  hello()
----

Điều này cho chúng ta thấy rằng "`hola world`" có ở phía chúng ta nhưng không có trong bản sao làm việc, rằng "`hello mundo`" có ở phía họ nhưng không có trong bản sao làm việc và cuối cùng là "`hola mundo`" không có ở cả hai bên nhưng bây giờ có trong bản sao làm việc.
Điều này có thể hữu ích để xem xét trước khi cam kết giải pháp.

Bạn cũng có thể lấy điều này từ `git log` cho bất kỳ hợp nhất nào để xem một cái gì đó đã được giải quyết như thế nào sau đó.
Git sẽ xuất ra định dạng này nếu bạn chạy `git show` trên một cam kết hợp nhất, hoặc nếu bạn thêm tùy chọn `--cc` vào một `git log -p` (mà theo mặc định chỉ hiển thị các bản vá cho các cam kết không phải là hợp nhất).

[source,console]
----
$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
-  puts 'hello mundo'
+  puts 'hola mundo'
  end

  hello()
----

[[_undoing_merges]]
==== Hoàn tác các Hợp nhất

Bây giờ bạn đã biết cách tạo một cam kết hợp nhất, bạn có thể sẽ mắc phải một số sai lầm.
Một trong những điều tuyệt vời khi làm việc với Git là bạn có thể mắc sai lầm, bởi vì có thể (và trong nhiều trường hợp là dễ dàng) để sửa chữa chúng.

Các cam kết hợp nhất cũng không khác.
Giả sử bạn bắt đầu làm việc trên một nhánh chủ đề, vô tình hợp nhất nó vào `master`, và bây giờ lịch sử cam kết của bạn trông như thế này:

.Cam kết hợp nhất vô tình
image::images/undomerge-start.png[Cam kết hợp nhất vô tình]

Có hai cách để tiếp cận vấn đề này, tùy thuộc vào kết quả mong muốn của bạn.

===== Sửa các tham chiếu

Nếu cam kết hợp nhất không mong muốn chỉ tồn tại trên kho lưu trữ cục bộ của bạn, giải pháp dễ nhất và tốt nhất là di chuyển các nhánh để chúng trỏ đến nơi bạn muốn.
Trong hầu hết các trường hợp, nếu bạn theo sau `git merge` sai lầm bằng `git reset --hard HEAD~`, điều này sẽ đặt lại các con trỏ nhánh để chúng trông như thế này:

.Lịch sử sau `git reset --hard HEAD~`
image::images/undomerge-reset.png[Lịch sử sau `git reset --hard HEAD~`]

Chúng ta đã đề cập đến `reset` trong <<ch07-git-tools#_git_reset>>, vì vậy không quá khó để hiểu những gì đang xảy ra ở đây.
Đây là một bản tóm tắt nhanh: `reset --hard` thường trải qua ba bước:

. Di chuyển nhánh mà HEAD đang trỏ đến.
  Trong trường hợp này, chúng ta muốn di chuyển `master` đến nơi nó đã ở trước khi cam kết hợp nhất (`C6`).
. Làm cho chỉ mục trông giống như HEAD.
. Làm cho thư mục làm việc trông giống như chỉ mục.

Nhược điểm của phương pháp này là nó đang viết lại lịch sử, điều này có thể gây ra vấn đề với một kho lưu trữ được chia sẻ.
Hãy xem <<ch03-git-branching#_rebase_peril>> để biết thêm về những gì có thể xảy ra; phiên bản ngắn gọn là nếu những người khác có các cam kết bạn đang viết lại, bạn có lẽ nên tránh `reset`.
Phương pháp này cũng sẽ không hoạt động nếu bất kỳ cam kết nào khác đã được tạo ra kể từ khi hợp nhất; việc di chuyển các tham chiếu sẽ thực sự làm mất các thay đổi đó.

[[_reverse_commit]]
===== Hoàn nguyên cam kết

Nếu việc di chuyển các con trỏ nhánh không phù hợp với bạn, Git cung cấp cho bạn tùy chọn tạo một cam kết mới hoàn tác tất cả các thay đổi từ một cam kết hiện có.
Git gọi hoạt động này là "`hoàn nguyên`", và trong kịch bản cụ thể này, bạn sẽ gọi nó như thế này:

[source,console]
----
$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"
----

Cờ `-m 1` cho biết cha mẹ nào là "`dòng chính`" và nên được giữ lại.
Khi bạn gọi một hợp nhất vào `HEAD` (`git merge topic`), cam kết mới có hai cha mẹ: cha mẹ đầu tiên là `HEAD` (`C6`), và cha mẹ thứ hai là đầu của nhánh đang được hợp nhất (`C4`).
Trong trường hợp này, chúng ta muốn hoàn tác tất cả các thay đổi được giới thiệu bằng cách hợp nhất vào cha mẹ #2 (`C4`), trong khi vẫn giữ tất cả nội dung từ cha mẹ #1 (`C6`).

Lịch sử với cam kết hoàn nguyên trông như thế này:

.Lịch sử sau `git revert -m 1`
image::images/undomerge-revert.png[Lịch sử sau `git revert -m 1`]

Cam kết mới `^M` có nội dung hoàn toàn giống với `C6`, vì vậy bắt đầu từ đây, nó giống như việc hợp nhất chưa bao giờ xảy ra, ngoại trừ việc các cam kết hiện chưa được hợp nhất vẫn còn trong lịch sử của ``HEAD```.
Git sẽ bị rối nếu bạn cố gắng hợp nhất ``topic`` vào ``master`` một lần nữa:

[source,console]
----
$ git merge topic
Already up-to-date.
----

Không có gì trong `topic` mà không thể truy cập được từ `master`.
Tệ hơn nữa, nếu bạn thêm công việc vào `topic` và hợp nhất lại, Git sẽ chỉ mang vào các thay đổi _kể từ_ lần hợp nhất bị hoàn nguyên:

.Lịch sử với một hợp nhất tồi
image::images/undomerge-revert2.png[Lịch sử với một hợp nhất tồi]

Cách tốt nhất để giải quyết vấn đề này là hoàn tác lại lần hợp nhất ban đầu, vì bây giờ bạn muốn mang vào các thay đổi đã bị hoàn nguyên, *sau đó* tạo một cam kết hợp nhất mới:

[source,console]
----
$ git revert ^M
[master 09f0126] Revert "Revert \"Merge branch 'topic'\""
$ git merge topic
----

.Lịch sử sau khi hợp nhất lại một hợp nhất bị hoàn nguyên
image::images/undomerge-revert3.png[Lịch sử sau khi hợp nhất lại một hợp nhất bị hoàn nguyên]

Trong ví dụ này, `M` và `^M` triệt tiêu nhau.
`^^M` thực sự hợp nhất các thay đổi từ `C3` và `C4`, và `C8` hợp nhất các thay đổi từ `C7`, vì vậy bây giờ `topic` đã được hợp nhất hoàn toàn.

==== Các Loại Hợp nhất Khác

Đến đây, chúng ta đã đề cập đến việc hợp nhất thông thường của hai nhánh, thường được xử lý bằng một chiến lược hợp nhất gọi là "`đệ quy`".
Tuy nhiên, có những cách khác để hợp nhất các nhánh lại với nhau.
Hãy cùng xem qua một vài trong số đó một cách nhanh chóng.

===== Ưu tiên Của chúng ta hoặc Của họ

Trước hết, có một điều hữu ích khác chúng ta có thể làm với chế độ hợp nhất "`đệ quy`" thông thường.
Chúng ta đã thấy các tùy chọn `ignore-all-space` và `ignore-space-change` được truyền bằng một `-X` nhưng chúng ta cũng có thể bảo Git ưu tiên một bên hoặc bên kia khi nó thấy một xung đột.

Theo mặc định, khi Git thấy một xung đột giữa hai nhánh đang được hợp nhất, nó sẽ thêm các dấu xung đột hợp nhất vào mã của bạn và đánh dấu tệp là bị xung đột và để bạn giải quyết nó.
Nếu bạn muốn Git chỉ cần chọn một bên cụ thể và bỏ qua bên kia thay vì để bạn giải quyết xung đột thủ công, bạn có thể truyền cho lệnh `merge` hoặc `-Xours` hoặc `-Xtheirs`.

Nếu Git thấy điều này, nó sẽ không thêm các dấu xung đột.
Bất kỳ sự khác biệt nào có thể hợp nhất, nó sẽ hợp nhất.
Bất kỳ sự khác biệt nào xung đột, nó sẽ chỉ chọn bên bạn chỉ định toàn bộ, bao gồm cả các tệp nhị phân.

Nếu chúng ta quay lại ví dụ "`hello world`" mà chúng ta đã sử dụng trước đó, chúng ta có thể thấy rằng việc hợp nhất nhánh của chúng ta gây ra xung đột.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.
----

Tuy nhiên, nếu chúng ta chạy nó với `-Xours` hoặc `-Xtheirs` thì không.

[source,console]
----
$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh
----

Trong trường hợp đó, thay vì nhận được các dấu xung đột trong tệp với "`hello mundo`" ở một bên và "`hola world`" ở bên kia, nó sẽ chỉ chọn "`hola world`".
Tuy nhiên, tất cả các thay đổi không xung đột khác trên nhánh đó đều được hợp nhất thành công.

Tùy chọn này cũng có thể được truyền cho lệnh `git merge-file` mà chúng ta đã thấy trước đó bằng cách chạy một cái gì đó như `git merge-file --ours` cho các lần hợp nhất tệp riêng lẻ.

Nếu bạn muốn làm một cái gì đó như thế này nhưng không muốn Git thậm chí cố gắng hợp nhất các thay đổi từ phía bên kia, có một tùy chọn hà khắc hơn, đó là _chiến lược_ hợp nhất "`ours`".
Điều này khác với _tùy chọn_ hợp nhất đệ quy "`ours`".

Về cơ bản, điều này sẽ thực hiện một hợp nhất giả.
Nó sẽ ghi lại một cam kết hợp nhất mới với cả hai nhánh là cha mẹ, nhưng nó sẽ không nhìn vào nhánh bạn đang hợp nhất.
Nó sẽ chỉ ghi lại kết quả của việc hợp nhất là mã chính xác trong nhánh hiện tại của bạn.

[source,console]
----
$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$
----

Bạn có thể thấy rằng không có sự khác biệt giữa nhánh chúng ta đang ở và kết quả của việc hợp nhất.

Điều này thường có thể hữu ích để về cơ bản lừa Git nghĩ rằng một nhánh đã được hợp nhất khi thực hiện một hợp nhất sau này.
Ví dụ, giả sử bạn đã phân nhánh từ một nhánh `release` và đã thực hiện một số công việc trên đó mà bạn sẽ muốn hợp nhất trở lại vào nhánh `master` của mình vào một thời điểm nào đó.
Trong khi đó, một số bản sửa lỗi trên `master` cần được chuyển ngược vào nhánh `release` của bạn.
Bạn có thể hợp nhất nhánh sửa lỗi vào nhánh `release` và cũng `merge -s ours` cùng một nhánh vào nhánh `master` của bạn (mặc dù bản sửa lỗi đã có ở đó) để khi bạn hợp nhất lại nhánh `release` sau này, không có xung đột nào từ bản sửa lỗi.

include::subtree-merges.asc[]