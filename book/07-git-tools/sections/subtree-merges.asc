[[_subtree_merge]]
===== Hợp nhất Cây con (Subtree Merging)

Ý tưởng của việc hợp nhất cây con là bạn có hai dự án, và một trong các dự án ánh xạ tới một thư mục con của dự án kia.
Khi bạn chỉ định một hợp nhất cây con, Git thường đủ thông minh để nhận ra rằng một cái là cây con của cái kia và hợp nhất một cách thích hợp.

Chúng ta sẽ đi qua một ví dụ về việc thêm một dự án riêng biệt vào một dự án hiện có và sau đó hợp nhất mã của dự án thứ hai vào một thư mục con của dự án thứ nhất.

Đầu tiên, chúng ta sẽ thêm ứng dụng Rack vào dự án của mình.
Chúng ta sẽ thêm dự án Rack dưới dạng một tham chiếu từ xa trong dự án của riêng mình và sau đó checkout nó vào nhánh riêng của nó:

[source,console]
----
$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -> rack_remote/build
 * [new branch]      master     -> rack_remote/master
 * [new branch]      rack-0.4   -> rack_remote/rack-0.4
 * [new branch]      rack-0.9   -> rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"
----

Bây giờ chúng ta có gốc của dự án Rack trong nhánh `rack_branch` của chúng ta và dự án riêng của chúng ta trong nhánh `master`.
Nếu bạn checkout cái này rồi cái kia, bạn có thể thấy rằng chúng có các gốc dự án khác nhau:

[source,console]
----
$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README
----

Đây là một khái niệm hơi lạ.
Không phải tất cả các nhánh trong kho lưu trữ của bạn thực sự phải là các nhánh của cùng một dự án.
Điều này không phổ biến, bởi vì nó hiếm khi hữu ích, nhưng khá dễ dàng để có các nhánh chứa các lịch sử hoàn toàn khác nhau.

Trong trường hợp này, chúng ta muốn kéo dự án Rack vào dự án `master` của chúng ta dưới dạng một thư mục con.
Chúng ta có thể làm điều đó trong Git với `git read-tree`.
Bạn sẽ tìm hiểu thêm về `read-tree` và những người bạn của nó trong <<ch10-git-internals#ch10-git-internals>>, nhưng hiện tại hãy biết rằng nó đọc cây gốc của một nhánh vào khu vực tổ chức và thư mục làm việc hiện tại của bạn.
Chúng ta vừa chuyển trở lại nhánh `master` của bạn, và chúng ta kéo nhánh `rack_branch` vào thư mục con `rack` của nhánh `master` của dự án chính của chúng ta:

[source,console]
----
$ git read-tree --prefix=rack/ -u rack_branch
----

Khi chúng ta commit, có vẻ như chúng ta có tất cả các tệp Rack dưới thư mục con đó -- như thể chúng ta đã sao chép chúng vào từ một tarball.
Điều thú vị là chúng ta có thể khá dễ dàng hợp nhất các thay đổi từ một trong các nhánh sang nhánh kia.
Vì vậy, nếu dự án Rack cập nhật, chúng ta có thể kéo vào các thay đổi thượng nguồn bằng cách chuyển sang nhánh đó và kéo (pulling):

[source,console]
----
$ git checkout rack_branch
$ git pull
----

Sau đó, chúng ta có thể hợp nhất các thay đổi đó trở lại vào nhánh `master` của mình.
Để kéo vào các thay đổi và điền trước thông điệp commit, hãy sử dụng tùy chọn `--squash`, cũng như tùy chọn `-Xsubtree` của chiến lược hợp nhất đệ quy.
Chiến lược đệ quy là mặc định ở đây, nhưng chúng ta bao gồm nó cho rõ ràng.

[source,console]
----
$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
----

Tất cả các thay đổi từ dự án Rack được hợp nhất vào và sẵn sàng để được commit cục bộ.
Bạn cũng có thể làm ngược lại -- thực hiện các thay đổi trong thư mục con `rack` của nhánh `master` của bạn và sau đó hợp nhất chúng vào nhánh `rack_branch` của bạn sau này để gửi chúng cho những người bảo trì hoặc đẩy chúng lên thượng nguồn.

Điều này cung cấp cho chúng ta một cách để có một quy trình làm việc hơi giống với quy trình làm việc mô-đun con (submodule) mà không cần sử dụng các mô-đun con (mà chúng ta sẽ đề cập trong <<ch07-git-tools#_git_submodules>>).
Chúng ta có thể giữ các nhánh với các dự án liên quan khác trong kho lưu trữ của mình và hợp nhất cây con chúng vào dự án của mình thỉnh thoảng.
Nó tốt theo một số cách, ví dụ tất cả mã được commit vào một nơi duy nhất.
Tuy nhiên, nó có những hạn chế khác ở chỗ nó phức tạp hơn một chút và dễ mắc lỗi hơn trong việc tích hợp lại các thay đổi hoặc vô tình đẩy một nhánh vào một kho lưu trữ không liên quan.

Một điều hơi kỳ lạ nữa là để lấy diff giữa những gì bạn có trong thư mục con `rack` của bạn và mã trong nhánh `rack_branch` của bạn -- để xem liệu bạn có cần hợp nhất chúng hay không -- bạn không thể sử dụng lệnh `diff` thông thường.
Thay vào đó, bạn phải chạy `git diff-tree` với nhánh bạn muốn so sánh với:

[source,console]
----
$ git diff-tree -p rack_branch
----

Hoặc, để so sánh những gì có trong thư mục con `rack` của bạn với những gì nhánh `master` trên máy chủ là lần cuối cùng bạn fetch, bạn có thể chạy:

[source,console]
----
$ git diff-tree -p rack_remote/master
----
