[[_scripting_github]]
=== Lập trình kịch bản cho GitHub

Đến đây, chúng ta đã đề cập đến tất cả các tính năng và quy trình làm việc chính của GitHub, nhưng bất kỳ nhóm hoặc dự án lớn nào cũng sẽ có các tùy chỉnh mà họ có thể muốn thực hiện hoặc các dịch vụ bên ngoài mà họ có thể muốn tích hợp.

May mắn cho chúng ta, GitHub thực sự khá dễ dàng để "hack" theo nhiều cách.
Trong phần này, chúng ta sẽ đề cập đến cách sử dụng hệ thống hook của GitHub và API của nó để làm cho GitHub hoạt động theo cách chúng ta muốn.

==== Các Dịch vụ và Hook

Phần Hook và Dịch vụ trong quản trị kho lưu trữ GitHub là cách dễ nhất để GitHub tương tác với các hệ thống bên ngoài.

===== Các Dịch vụ

Đầu tiên, hãy xem xét các Dịch vụ.
Cả hai tích hợp Hook và Dịch vụ đều có thể được tìm thấy trong phần Cài đặt của kho lưu trữ của bạn, dưới tab Webhook và Dịch vụ.

.Tab Webhook & Dịch vụ
image::images/services-and-hooks-tab.png[Tab Webhook & Dịch vụ]

Có hàng tá dịch vụ bạn có thể lựa chọn, hầu hết trong số đó là tích hợp vào các hệ thống thương mại và mã nguồn mở khác.
Hầu hết chúng là dành cho các dịch vụ Tích hợp Liên tục, các trình theo dõi lỗi và vấn đề, các hệ thống phòng trò chuyện, và các hệ thống tài liệu.
Chúng ta sẽ đi qua việc thiết lập một cái rất đơn giản, hook Email.
Nếu bạn chọn "Email" từ trình đơn thả xuống "Thêm dịch vụ", bạn sẽ nhận được một màn hình cấu hình giống như trong <<_email_hook_config>>.

[[_email_hook_config]]
.Cấu hình hook email
image::images/email-hook-config.png[Cấu hình hook email]

Trong trường hợp này, nếu chúng ta nhấp vào nút "Thêm dịch vụ", một email sẽ được gửi đến địa chỉ chúng ta đã cung cấp mỗi khi ai đó đẩy vào kho lưu trữ.
Các dịch vụ có thể được sử dụng để lắng nghe nhiều loại sự kiện khác nhau, nhưng hầu hết chúng chỉ lắng nghe các sự kiện đẩy và sau đó làm gì đó với dữ liệu đó.

Nếu bạn có một hệ thống bạn muốn tích hợp với GitHub, nhưng nó không được liệt kê trong danh sách này, bạn có một lựa chọn khác: webhook.

===== Webhook

Webhook là một loại tích hợp Dịch vụ đặc biệt có khả năng tùy chỉnh cao.
Chúng là một cách rất đơn giản để GitHub thực hiện một POST HTTP đến một URL bất cứ khi nào một sự kiện nhất định xảy ra.

Để thiết lập một webhook, bạn nhấp vào nút "Thêm webhook" trong phần Webhook của trang cài đặt "Webhook & dịch vụ".
Điều này sẽ hiển thị một biểu mẫu giống như trong <<_webhook_form>>.

[[_webhook_form]]
.Biểu mẫu cấu hình webhook
image::images/webhook-form.png[Biểu mẫu cấu hình webhook]

Việc thiết lập khá đơn giản.
Bạn cung cấp một URL mà bạn muốn GitHub POST đến, và bạn có thể chọn một bí mật sẽ được gửi cùng với POST, mà bạn có thể sử dụng để xác minh rằng POST đến từ GitHub.

Bạn cũng có thể chọn từ một số sự kiện khác nhau sẽ kích hoạt webhook.
Mặc định là chỉ được kích hoạt bởi một sự kiện `push` -- khi ai đó đẩy mã mới vào bất kỳ nhánh nào của kho lưu trữ.
Bạn có thể để nó được kích hoạt khi một kho lưu trữ được phân nhánh (`fork`), một nhánh hoặc thẻ mới được tạo (`create`), một nhánh hoặc thẻ bị xóa (`delete`), một yêu cầu kéo được mở (`pull_request`), hoặc một vấn đề mới được mở (`issues`).
Hoặc, bạn có thể để nó kích hoạt cho mọi thứ.

Nếu chúng ta nhấp vào "Thêm webhook", GitHub sẽ POST đến URL chúng ta đã cung cấp với một số thông tin về sự kiện đã kích hoạt nó.

==== API GitHub

Cách cuối cùng chúng ta có thể làm cho GitHub hoạt động với các hệ thống bên ngoài là thông qua API của nó.
GitHub có một số API, nhưng cho mục đích của chúng ta, chúng ta sẽ tập trung vào API chính, hiện đang là phiên bản 3.
Bạn có thể tìm thấy tài liệu đầy đủ tại https://docs.github.com/rest/[^].

===== Những điều Cơ bản

Tất cả quyền truy cập API đều qua HTTPS, và tất cả dữ liệu được gửi và nhận dưới dạng JSON.
Mọi yêu cầu API đều yêu cầu một tiêu đề `Accept`.

[source,console]
----
$ curl -i https://api.github.com/users/schacon
HTTP/1.1 200 OK
Server: GitHub.com
Date: Sun, 11 May 2014 15:43:16 GMT
Content-Type: application/json; charset=utf-8
Status: 200 OK
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 57
X-RateLimit-Reset: 1400000000

{
  "login": "schacon",
  "id": 70,
...
}
----

Nếu chúng ta không chỉ định một tiêu đề `Accept`, chúng ta sẽ nhận lại rất nhiều văn bản, và tiêu đề `Content-Type` sẽ là `text/html`.
Nếu chúng ta chỉ định `application/vnd.github.v3+json` làm giá trị cho tiêu đề `Accept`, chúng ta sẽ nhận lại một đối tượng JSON.

[source,console]
----
$ curl -i -H "Accept: application/vnd.github.v3+json" \
  https://api.github.com/users/schacon
----

Chúng ta sẽ sử dụng tiêu đề `Accept` này trong tất cả các yêu cầu API của mình.

Điều khác bạn sẽ cần là một mã thông báo OAuth để xác thực.
Có một số cách để có được một mã thông báo, nhưng đối với các kịch bản đơn giản, cách dễ nhất là tạo một Mã thông báo Truy cập Cá nhân.
Bạn có thể làm điều này từ tab "Mã thông báo truy cập cá nhân" trong trang cài đặt của bạn.

.Tab mã thông báo truy cập cá nhân
image::images/personal-access-tokens.png[Tab mã thông báo truy cập cá nhân]

Điều này sẽ yêu cầu bạn mô tả về mã thông báo và chọn "phạm vi" cho mã thông báo.
Các phạm vi xác định những gì bạn có thể làm với mã thông báo.
Một ý tưởng hay là giới hạn phạm vi chỉ trong những gì bạn cần.
 Ví dụ, nếu bạn chỉ muốn đọc dữ liệu người dùng và các kho lưu trữ, bạn có thể chọn các phạm vi `user:email` và `repo`.

[[_auth_token_scopes]]
.Các phạm vi cho một mã thông báo truy cập cá nhân mới
image::images/auth-token-scopes.png[Các phạm vi cho một mã thông báo truy cập cá nhân mới]

Khi bạn đã có mã thông báo, bạn có thể sử dụng nó để xác thực với API bằng cách chuyển nó trong tiêu đề `Authorization`.

[source,console]
----
$ curl -i -H "Authorization: token <token>" \
  -H "Accept: application/vnd.github.v3+json" \
  https://api.github.com/user
----

Tại thời điểm này, bạn sẽ có thể thực hiện các yêu cầu API cho dữ liệu người dùng của riêng mình.
Hãy thử lấy dữ liệu người dùng của bạn.

[source,console]
----
$ curl -i -H "Authorization: token <token>" \
  -H "Accept: application/vnd.github.v3+json" \
  https://api.github.com/user
----

Bây giờ hãy thử làm một cái gì đó thú vị hơn một chút.
Hãy xem chúng ta có thể tạo một vấn đề trong một kho lưu trữ hay không.

Để làm điều này, chúng ta sẽ cần biết chủ sở hữu của kho lưu trữ và tên kho lưu trữ.
Hãy thử tạo một vấn đề trong kho lưu trữ `schacon/blink`.
Chúng ta sẽ cần thực hiện một yêu cầu `POST` đến `/repos/<user>/<repo>/issues/<num>/comments` với một đối tượng JSON chứa tiêu đề và nội dung của vấn đề.

[source,console]
----
$ curl -i -H "Authorization: token <token>" \
  -H "Accept: application/vnd.github.v3+json" \
  -d '{"title": "Test issue", "body": "This is a test"}' \
  https://api.github.com/repos/schacon/blink/issues
----

Chúng ta cũng có thể sử dụng API để bình luận về vấn đề này.
Để làm điều này, chúng ta sẽ cần thực hiện một yêu cầu `POST` đến `/repos/:owner/:repo/issues/:number/comments` với một đối tượng JSON chứa nội dung của bình luận.

[source,console]
----
$ curl -i -H "Authorization: token <token>" \
  -H "Accept: application/vnd.github.v3+json" \
  -d '{"body": "This is a test comment"}' \
  https://api.github.com/repos/schacon/blink/issues/3/comments
----

Chúng ta có thể thấy rằng bình luận đã được tạo thành công.

Bạn có thể sử dụng API để làm những việc như:

* Liệt kê các cam kết
* Tạo và chỉnh sửa các nhãn
* Tạo, chỉnh sửa, và xóa các kho lưu trữ
* Thêm và xóa các cộng tác viên
* và nhiều hơn nữa

Đây chỉ là một mẫu nhỏ của những gì có sẵn.
Bạn có thể tìm thấy tài liệu đầy đủ cho API tại https://docs.github.com/rest/[^].

===== Ví dụ: Một Dịch vụ Trạng thái Cam kết

API GitHub khá rộng lớn, và bạn có thể nhận được gần như bất kỳ dữ liệu nào bạn muốn về các kho lưu trữ của mình.
Trong phần này, chúng ta sẽ viết một dịch vụ nhỏ sẽ lắng nghe các sự kiện đẩy và sau đó đăng một trạng thái lên cam kết cho bạn biết cam kết có "hợp lệ" hay không.

Để làm điều này, trước tiên chúng ta sẽ cần thiết lập một webhook.
Hãy truy cập phần "Webhook" trong cài đặt kho lưu trữ của chúng ta và nhấp vào "Thêm webhook".
Chúng ta sẽ cung cấp một URL cho dịch vụ của mình, và một bí mật.
Chúng ta cũng sẽ chọn chỉ nhận các sự kiện `push`.

Bây giờ, dịch vụ của chúng ta sẽ nhận được một yêu cầu `POST` mỗi khi ai đó đẩy vào kho lưu trữ.
Hãy viết một dịch vụ Sinatra đơn giản để xử lý điều này.

[source,ruby]
----
require 'sinatra'
require 'json'
require 'git'
require 'octokit'

post '/payload' do
  push = JSON.parse(request.body.read)
  repo = push['repository']['full_name']
  sha = push['after']

  client = Octokit::Client.new(access_token: ENV['GITHUB_TOKEN'])
  g = Git.open(ENV['GIT_REPO_PATH'])
  commit = g.gcommit(sha)

  if commit.message.include?('LGTM')
    client.create_status(repo, sha, 'success')
  else
    client.create_status(repo, sha, 'failure')
  end
end
----

Đây là một dịch vụ khá đơn giản.
Nó lấy tên kho lưu trữ và SHA-1 của cam kết đã được đẩy.
Sau đó, nó sử dụng gem `octokit` (https://github.com/octokit/octokit.rb[^]) để tạo một trạng thái trên cam kết.
Trạng thái có thể là một trong `pending`, `success`, `error`, hoặc `failure`.
Cuối cùng, nó kiểm tra xem thông điệp cam kết có chứa "LGTM" hay không và đặt trạng thái tương ứng.

Và đó là tất cả!
Bây giờ, mỗi khi ai đó đẩy vào kho lưu trữ của chúng ta, chúng ta sẽ nhận được một trạng thái trên cam kết cho chúng ta biết thông điệp cam kết có hợp lệ hay không.
Bạn có thể xem một ví dụ về điều này trong <<_commit_status>>.

[[_commit_status]]
.Trạng thái cam kết
image::images/commit-status.png[Trạng thái cam kết]

Bạn có thể thấy dấu kiểm màu xanh lá cây nhỏ bên cạnh SHA-1 cam kết.
Đây là một tính năng rất mạnh mẽ để tích hợp các dịch vụ bên ngoài với GitHub.