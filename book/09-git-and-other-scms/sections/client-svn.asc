[[_git_svn]]
==== Git và Subversion

(((Subversion)))(((Interoperation with other VCSs, Subversion)))
Một phần lớn các dự án phát triển mã nguồn mở và một số lượng lớn các dự án doanh nghiệp sử dụng Subversion để quản lý mã nguồn của họ.
Nó đã tồn tại hơn một thập kỷ, và trong phần lớn thời gian đó là lựa chọn VCS _thực tế_ (de facto) cho các dự án mã nguồn mở.
Nó cũng rất giống về nhiều mặt với CVS, vốn là ông lớn của thế giới kiểm soát nguồn trước đó.

(((git commands, svn)))(((git-svn)))
Một trong những tính năng tuyệt vời của Git là một cầu nối hai chiều đến Subversion được gọi là `git svn`.
Công cụ này cho phép bạn sử dụng Git như một máy khách hợp lệ cho máy chủ Subversion, vì vậy bạn có thể sử dụng tất cả các tính năng cục bộ của Git và sau đó đẩy lên máy chủ Subversion như thể bạn đang sử dụng Subversion cục bộ.
Điều này có nghĩa là bạn có thể thực hiện phân nhánh và trộn cục bộ, sử dụng khu vực tổ chức (staging area), sử dụng rebase và cherry-pick, và vân vân, trong khi các cộng tác viên của bạn tiếp tục làm việc theo những cách đen tối và cổ xưa của họ.
Đó là một cách tốt để đưa Git vào môi trường doanh nghiệp và giúp các nhà phát triển đồng nghiệp của bạn trở nên hiệu quả hơn trong khi bạn vận động để thay đổi cơ sở hạ tầng để hỗ trợ Git hoàn toàn.
Cầu nối Subversion là liều thuốc dẫn vào thế giới DVCS.

===== `git svn`

Lệnh cơ sở trong Git cho tất cả các lệnh cầu nối Subversion là `git svn`.
Nó nhận khá nhiều lệnh, vì vậy chúng tôi sẽ hiển thị những lệnh phổ biến nhất trong khi đi qua một vài quy trình làm việc đơn giản.

Điều quan trọng cần lưu ý là khi bạn đang sử dụng `git svn`, bạn đang tương tác với Subversion, một hệ thống hoạt động rất khác so với Git.
Mặc dù bạn *có thể* thực hiện phân nhánh và trộn cục bộ, nhưng nói chung tốt nhất là giữ cho lịch sử của bạn tuyến tính nhất có thể bằng cách rebase công việc của bạn, và tránh làm những việc như tương tác đồng thời với một kho chứa Git từ xa.

Đừng viết lại lịch sử của bạn và cố gắng đẩy lại, và đừng đẩy đến một kho chứa Git song song để cộng tác với các nhà phát triển Git đồng nghiệp cùng một lúc.
Subversion chỉ có thể có một lịch sử tuyến tính duy nhất, và làm nó bối rối là rất dễ dàng.
Nếu bạn đang làm việc với một nhóm, và một số đang sử dụng SVN và những người khác đang sử dụng Git, hãy đảm bảo mọi người đều đang sử dụng máy chủ SVN để cộng tác – làm như vậy sẽ giúp cuộc sống của bạn dễ dàng hơn.

===== Thiết lập

Để minh họa chức năng này, bạn cần một kho chứa SVN điển hình mà bạn có quyền ghi.
Nếu bạn muốn sao chép các ví dụ này, bạn sẽ phải tạo một bản sao có thể ghi của một kho chứa thử nghiệm SVN.
Để làm điều đó một cách dễ dàng, bạn có thể sử dụng một công cụ gọi là `svnsync` đi kèm với Subversion.

Để làm theo, trước tiên bạn cần tạo một kho chứa Subversion cục bộ mới:

[source,console]
----
$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn
----

Sau đó, cho phép tất cả người dùng thay đổi revprops – cách dễ nhất là thêm một tập tin kịch bản `pre-revprop-change` luôn thoát 0:

[source,console]
----
$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change
----

Bây giờ bạn có thể đồng bộ dự án này với máy cục bộ của mình bằng cách gọi `svnsync init` với các kho chứa đến và đi.

[source,console]
----
$ svnsync init file:///tmp/test-svn \
  http://your-svn-server.example.org/svn/
----

Điều này thiết lập các thuộc tính để chạy đồng bộ hóa.
Sau đó, bạn có thể sao chép mã bằng cách chạy:

[source,console]
----
$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]
----

Mặc dù thao tác này có thể chỉ mất vài phút, nhưng nếu bạn cố gắng sao chép kho chứa gốc sang một kho chứa từ xa khác thay vì một kho chứa cục bộ, quá trình này sẽ mất gần một giờ, ngay cả khi có ít hơn 100 commit.
Subversion phải sao chép từng bản sửa đổi một và sau đó đẩy nó trở lại vào một kho chứa khác – nó cực kỳ kém hiệu quả, nhưng đó là cách dễ dàng duy nhất để làm điều này.

===== Bắt đầu

Bây giờ bạn đã có một kho chứa Subversion mà bạn có quyền ghi, bạn có thể đi qua một quy trình làm việc điển hình.
Bạn sẽ bắt đầu với lệnh `git svn clone`, lệnh này nhập toàn bộ kho chứa Subversion vào một kho chứa Git cục bộ.
Hãy nhớ rằng nếu bạn đang nhập từ một kho chứa Subversion được lưu trữ thực sự, bạn nên thay thế `\file:///tmp/test-svn` ở đây bằng URL của kho chứa Subversion của bạn:

[source,console]
----
$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75
----

Điều này chạy tương đương với hai lệnh – `git svn init` theo sau là `git svn fetch` – trên URL bạn cung cấp.
Điều này có thể mất một lúc.
Ví dụ, nếu dự án thử nghiệm chỉ có khoảng 75 commit và cơ sở mã không quá lớn, Git vẫn phải check out từng phiên bản, từng cái một, và commit nó riêng lẻ.
Đối với một dự án có hàng trăm hoặc hàng nghìn commit, điều này thực sự có thể mất hàng giờ hoặc thậm chí hàng ngày để hoàn thành.

Phần `-T trunk -b branches -t tags` bảo Git rằng kho chứa Subversion này tuân theo các quy ước phân nhánh và gắn thẻ cơ bản.
Nếu bạn đặt tên trunk, branches, hoặc tags khác đi, bạn có thể thay đổi các tùy chọn này.
Bởi vì điều này rất phổ biến, bạn có thể thay thế toàn bộ phần này bằng `-s`, có nghĩa là bố cục tiêu chuẩn (standard layout) và ngụ ý tất cả các tùy chọn đó.
Lệnh sau đây là tương đương:

[source,console]
----
$ git svn clone file:///tmp/test-svn -s
----

Tại thời điểm này, bạn nên có một kho chứa Git hợp lệ đã nhập các nhánh và thẻ của bạn:

[source,console]
----
$ git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk
----

Lưu ý cách công cụ này quản lý các thẻ Subversion như các tham chiếu từ xa.
(((git commands, show-ref)))
Hãy xem xét kỹ hơn với lệnh plumbing Git `show-ref`:

[source,console]
----
$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk
----

Git không làm điều này khi nó sao chép từ một máy chủ Git; đây là những gì một kho chứa với các thẻ trông như thế nào sau khi sao chép mới:

[source,console]
----
$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0
----

Git lấy các thẻ trực tiếp vào `refs/tags`, thay vì coi chúng như các nhánh từ xa.

===== Commit Trở lại Subversion

Bây giờ bạn đã có một thư mục làm việc, bạn có thể thực hiện một số công việc trên dự án và đẩy các commit của bạn trở lại thượng nguồn (upstream), sử dụng Git một cách hiệu quả như một máy khách SVN.
Nếu bạn chỉnh sửa một trong các tập tin và commit nó, bạn có một commit tồn tại trong Git cục bộ mà không tồn tại trên máy chủ Subversion:

[source,console]
----
$ git commit -am 'Adding git-svn instructions to the README'
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)
----

Tiếp theo, bạn cần đẩy thay đổi của mình lên thượng nguồn.
Lưu ý cách điều này thay đổi cách bạn làm việc với Subversion – bạn có thể thực hiện một vài commit ngoại tuyến và sau đó đẩy tất cả chúng cùng một lúc lên máy chủ Subversion.
Để đẩy lên một máy chủ Subversion, bạn chạy lệnh `git svn dcommit`:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Lệnh này lấy tất cả các commit bạn đã thực hiện trên mã máy chủ Subversion, thực hiện một commit Subversion cho mỗi cái, và sau đó viết lại commit Git cục bộ của bạn để bao gồm một định danh duy nhất.
Điều này quan trọng vì nó có nghĩa là tất cả các tổng kiểm tra SHA-1 cho các commit của bạn đều thay đổi.
Một phần vì lý do này, làm việc với các phiên bản từ xa dựa trên Git của các dự án của bạn đồng thời với một máy chủ Subversion không phải là một ý tưởng hay.
Nếu bạn nhìn vào commit cuối cùng, bạn có thể thấy `git-svn-id` mới đã được thêm vào:

[source,console]
----
$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben <ben@0b684db3-b064-4277-89d1-21af03df0a68>
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68
----

Lưu ý rằng tổng kiểm tra SHA-1 ban đầu bắt đầu bằng `4af61fd` khi bạn commit bây giờ bắt đầu bằng `95e0222`.
Nếu bạn muốn đẩy lên cả máy chủ Git và máy chủ Subversion, bạn phải đẩy (`dcommit`) lên máy chủ Subversion trước, bởi vì hành động đó thay đổi dữ liệu commit của bạn.

===== Kéo vào Các Thay đổi Mới

Nếu bạn đang làm việc với các nhà phát triển khác, thì tại một thời điểm nào đó, một trong số các bạn sẽ đẩy, và sau đó người kia sẽ cố gắng đẩy một thay đổi gây xung đột.
Thay đổi đó sẽ bị từ chối cho đến khi bạn trộn công việc của họ vào.
Trong `git svn`, nó trông như thế này:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

Để giải quyết tình huống này, bạn có thể chạy `git svn rebase`, lệnh này kéo xuống bất kỳ thay đổi nào trên máy chủ mà bạn chưa có và rebase bất kỳ công việc nào bạn có lên trên những gì có trên máy chủ:

[source,console]
----
$ git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

Bây giờ, tất cả công việc của bạn đều nằm trên những gì có trên máy chủ Subversion, vì vậy bạn có thể `dcommit` thành công:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Lưu ý rằng không giống như Git, yêu cầu bạn trộn công việc thượng nguồn mà bạn chưa có cục bộ trước khi bạn có thể đẩy, `git svn` bắt bạn làm điều đó chỉ khi các thay đổi xung đột (giống như cách Subversion hoạt động).
Nếu người khác đẩy một thay đổi vào một tập tin và sau đó bạn đẩy một thay đổi vào một tập tin khác, `dcommit` của bạn sẽ hoạt động tốt:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...
----

Điều quan trọng cần nhớ là kết quả là một trạng thái dự án không tồn tại trên cả hai máy tính của bạn khi bạn đẩy.
Nếu các thay đổi không tương thích nhưng không xung đột, bạn có thể gặp các vấn đề khó chẩn đoán.
Điều này khác với việc sử dụng máy chủ Git – trong Git, bạn có thể kiểm tra đầy đủ trạng thái trên hệ thống máy khách của mình trước khi xuất bản nó, trong khi trong SVN, bạn không bao giờ có thể chắc chắn rằng các trạng thái ngay trước khi commit và sau khi commit là giống hệt nhau.

Bạn cũng nên chạy lệnh này để kéo vào các thay đổi từ máy chủ Subversion, ngay cả khi bạn chưa sẵn sàng commit.
Bạn có thể chạy `git svn fetch` để lấy dữ liệu mới, nhưng `git svn rebase` thực hiện việc lấy và sau đó cập nhật các commit cục bộ của bạn.

[source,console]
----
$ git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.
----

Chạy `git svn rebase` thỉnh thoảng đảm bảo mã của bạn luôn được cập nhật.
Tuy nhiên, bạn cần chắc chắn rằng thư mục làm việc của mình sạch sẽ khi bạn chạy lệnh này.
Nếu bạn có các thay đổi cục bộ, bạn phải stash công việc của mình hoặc commit tạm thời trước khi chạy `git svn rebase` – nếu không, lệnh sẽ dừng lại nếu nó thấy rằng việc rebase sẽ dẫn đến xung đột trộn.

===== Các Vấn đề Phân nhánh Git

Khi bạn đã trở nên thoải mái với quy trình làm việc Git, bạn có thể sẽ tạo các nhánh chủ đề, thực hiện công việc trên chúng, và sau đó trộn chúng vào.
Nếu bạn đang đẩy lên máy chủ Subversion thông qua `git svn`, bạn có thể muốn rebase công việc của mình lên một nhánh duy nhất mỗi lần thay vì trộn các nhánh lại với nhau.
Lý do để ưu tiên rebase là Subversion có lịch sử tuyến tính và không xử lý các lần trộn như Git, vì vậy `git svn` chỉ theo dõi cha mẹ đầu tiên khi chuyển đổi các ảnh chụp nhanh thành các commit Subversion.

Giả sử lịch sử của bạn trông giống như sau: bạn đã tạo một nhánh `experiment`, thực hiện hai commit, và sau đó trộn chúng trở lại vào `master`.
Khi bạn `dcommit`, bạn thấy đầu ra như thế này:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Chạy `dcommit` trên một nhánh với lịch sử đã trộn hoạt động tốt, ngoại trừ việc khi bạn nhìn vào lịch sử dự án Git của mình, nó chưa viết lại bất kỳ commit nào bạn đã thực hiện trên nhánh `experiment` – thay vào đó, tất cả các thay đổi đó xuất hiện trong phiên bản SVN của commit trộn duy nhất.

Khi người khác sao chép công việc đó, tất cả những gì họ thấy là commit trộn với tất cả công việc được squash vào đó, như thể bạn đã chạy `git merge --squash`; họ không thấy dữ liệu commit về việc nó đến từ đâu hoặc khi nào nó được commit.

===== Phân nhánh Subversion

Phân nhánh trong Subversion không giống như phân nhánh trong Git; nếu bạn có thể tránh sử dụng nó nhiều, đó có lẽ là tốt nhất.
Tuy nhiên, bạn có thể tạo và commit vào các nhánh trong Subversion bằng cách sử dụng `git svn`.

===== Tạo một Nhánh SVN Mới

Để tạo một nhánh mới trong Subversion, bạn chạy `git svn branch [new-branch]`:

[source,console]
----
$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)
----

Điều này thực hiện tương đương với lệnh `svn copy trunk branches/opera` trong Subversion và hoạt động trên máy chủ Subversion.
Điều quan trọng cần lưu ý là nó không check out bạn vào nhánh đó; nếu bạn commit tại thời điểm này, commit đó sẽ đi đến `trunk` trên máy chủ, không phải `opera`.

===== Chuyển đổi Các Nhánh Hoạt động

Git tìm ra nhánh nào dcommits của bạn đi đến bằng cách tìm kiếm đỉnh của bất kỳ nhánh Subversion nào của bạn trong lịch sử của bạn – bạn chỉ nên có một, và nó nên là cái cuối cùng có `git-svn-id` trong lịch sử nhánh hiện tại của bạn.

Nếu bạn muốn làm việc trên nhiều hơn một nhánh đồng thời, bạn có thể thiết lập các nhánh cục bộ để `dcommit` đến các nhánh Subversion cụ thể bằng cách bắt đầu chúng tại commit Subversion đã nhập cho nhánh đó.
Nếu bạn muốn một nhánh `opera` mà bạn có thể làm việc riêng biệt, bạn có thể chạy:

[source,console]
----
$ git branch opera remotes/origin/opera
----

Bây giờ, nếu bạn muốn trộn nhánh `opera` của mình vào `trunk` (nhánh `master` của bạn), bạn có thể làm như vậy với một `git merge` bình thường.
Nhưng bạn cần cung cấp một thông điệp commit mô tả (thông qua `-m`), nếu không việc trộn sẽ nói "`Merge branch opera`" thay vì một cái gì đó hữu ích.

Hãy nhớ rằng mặc dù bạn đang sử dụng `git merge` để thực hiện thao tác này, và việc trộn có thể sẽ dễ dàng hơn nhiều so với trong Subversion (vì Git sẽ tự động phát hiện cơ sở trộn thích hợp cho bạn), đây không phải là một commit trộn Git bình thường.
Bạn phải đẩy dữ liệu này trở lại một máy chủ Subversion không thể xử lý một commit theo dõi nhiều hơn một cha mẹ; vì vậy, sau khi bạn đẩy nó lên, nó sẽ trông giống như một commit duy nhất đã squash tất cả công việc của một nhánh khác dưới một commit duy nhất.
Sau khi bạn trộn một nhánh vào một nhánh khác, bạn không thể dễ dàng quay lại và tiếp tục làm việc trên nhánh đó, như bạn thường có thể làm trong Git.
Lệnh `dcommit` mà bạn chạy xóa bất kỳ thông tin nào nói rằng nhánh nào đã được trộn vào, vì vậy các tính toán cơ sở trộn tiếp theo sẽ sai – `dcommit` làm cho kết quả `git merge` của bạn trông giống như bạn đã chạy `git merge --squash`.
Thật không may, không có cách nào tốt để tránh tình huống này – Subversion không thể lưu trữ thông tin này, vì vậy bạn sẽ luôn bị tê liệt bởi những hạn chế của nó trong khi bạn đang sử dụng nó làm máy chủ của mình.
Để tránh các vấn đề, bạn nên xóa nhánh cục bộ (trong trường hợp này, `opera`) sau khi bạn trộn nó vào trunk.

===== Các Lệnh Subversion

Bộ công cụ `git svn` cung cấp một số lệnh để giúp giảm bớt quá trình chuyển đổi sang Git bằng cách cung cấp một số chức năng tương tự như những gì bạn có trong Subversion.
Dưới đây là một vài lệnh cung cấp cho bạn những gì Subversion đã từng làm.

====== Lịch sử Kiểu SVN

Nếu bạn đã quen với Subversion và muốn xem lịch sử của mình theo kiểu đầu ra SVN, bạn có thể chạy `git svn log` để xem lịch sử commit của mình theo định dạng SVN:

[source,console]
----
$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog
----

Bạn nên biết hai điều quan trọng về `git svn log`.
Đầu tiên, nó hoạt động ngoại tuyến, không giống như lệnh `svn log` thực sự, lệnh này yêu cầu máy chủ Subversion cung cấp dữ liệu.
Thứ hai, nó chỉ hiển thị cho bạn các commit đã được commit lên máy chủ Subversion.
Các commit Git cục bộ mà bạn chưa dcommited không hiển thị; các commit mà mọi người đã thực hiện cho máy chủ Subversion trong thời gian đó cũng không hiển thị.
Nó giống như trạng thái đã biết cuối cùng của các commit trên máy chủ Subversion.

====== Chú thích SVN

Cũng giống như lệnh `git svn log` mô phỏng lệnh `svn log` ngoại tuyến, bạn có thể nhận được tương đương của `svn annotate` bằng cách chạy `git svn blame [FILE]`.
Đầu ra trông giống như thế này:

[source,console]
----
$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal
----

Một lần nữa, nó không hiển thị các commit mà bạn đã thực hiện cục bộ trong Git hoặc đã được đẩy lên Subversion trong thời gian đó.

====== Thông tin Máy chủ SVN

Bạn cũng có thể nhận được cùng loại thông tin mà `svn info` cung cấp cho bạn bằng cách chạy `git svn info`:

[source,console]
----
$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)
----

Điều này giống như `blame` và `log` ở chỗ nó chạy ngoại tuyến và chỉ được cập nhật kể từ lần cuối cùng bạn giao tiếp với máy chủ Subversion.

====== Bỏ qua Những gì Subversion Bỏ qua

Nếu bạn sao chép một kho chứa Subversion có các thuộc tính `svn:ignore` được đặt ở bất kỳ đâu, bạn có thể sẽ muốn đặt các tập tin `.gitignore` tương ứng để bạn không vô tình commit các tập tin mà bạn không nên.
`git svn` có hai lệnh để giúp giải quyết vấn đề này.
Đầu tiên là `git svn create-ignore`, lệnh này tự động tạo các tập tin `.gitignore` tương ứng cho bạn để commit tiếp theo của bạn có thể bao gồm chúng.

Lệnh thứ hai là `git svn show-ignore`, lệnh này in ra stdout các dòng bạn cần đặt trong một tập tin `.gitignore` để bạn có thể chuyển hướng đầu ra vào tập tin loại trừ dự án của mình:

[source,console]
----
$ git svn show-ignore > .git/info/exclude
----

Bằng cách đó, bạn không xả rác dự án với các tập tin `.gitignore`.
Đây là một lựa chọn tốt nếu bạn là người dùng Git duy nhất trong một nhóm Subversion, và các đồng đội của bạn không muốn các tập tin `.gitignore` trong dự án.

===== Tóm tắt Git-Svn

Các công cụ `git svn` rất hữu ích nếu bạn bị mắc kẹt với một máy chủ Subversion, hoặc nếu không thì đang ở trong một môi trường phát triển đòi hỏi phải chạy một máy chủ Subversion.
Tuy nhiên, bạn nên coi nó là Git bị tê liệt, nếu không bạn sẽ gặp phải các vấn đề trong quá trình dịch có thể gây nhầm lẫn cho bạn và các cộng tác viên của bạn.
Để tránh rắc rối, hãy cố gắng tuân theo các hướng dẫn sau:

* Giữ một lịch sử Git tuyến tính không chứa các commit trộn được thực hiện bởi `git merge`.
  Rebase bất kỳ công việc nào bạn làm bên ngoài nhánh chính của mình trở lại nó; đừng trộn nó vào.
* Đừng thiết lập và cộng tác trên một máy chủ Git riêng biệt.
  Có thể có một cái để tăng tốc độ sao chép cho các nhà phát triển mới, nhưng đừng đẩy bất cứ thứ gì lên đó mà không có mục nhập `git-svn-id`.
  Bạn thậm chí có thể muốn thêm một móc `pre-receive` kiểm tra mỗi thông điệp commit cho một `git-svn-id` và từ chối các lần đẩy chứa các commit không có nó.

Nếu bạn tuân theo các hướng dẫn đó, làm việc với một máy chủ Subversion có thể dễ chịu hơn.
Tuy nhiên, nếu có thể chuyển sang một máy chủ Git thực sự, làm như vậy có thể mang lại cho nhóm của bạn nhiều hơn nữa.
