==== Git và Perforce

(((Interoperation with other VCSs, Perforce)))
(((Perforce)))
Perforce là một hệ thống kiểm soát phiên bản rất phổ biến trong môi trường doanh nghiệp.
Nó đã tồn tại từ năm 1995, điều này làm cho nó trở thành hệ thống lâu đời nhất được đề cập trong chương này.
Như vậy, nó được thiết kế với các ràng buộc của thời đại của nó; nó giả định rằng bạn luôn được kết nối với một máy chủ trung tâm duy nhất, và chỉ một phiên bản được giữ trên đĩa cục bộ.
Chắc chắn, các tính năng và ràng buộc của nó rất phù hợp với một số vấn đề cụ thể, nhưng có rất nhiều dự án sử dụng Perforce mà Git thực sự sẽ hoạt động tốt hơn.

Có hai tùy chọn nếu bạn muốn kết hợp việc sử dụng Perforce và Git.
Tùy chọn đầu tiên chúng tôi sẽ đề cập là cầu nối "`Git Fusion`" từ các nhà sản xuất Perforce, cho phép bạn hiển thị các cây con của kho lưu trữ Perforce của bạn dưới dạng các kho chứa Git đọc-ghi.
Tùy chọn thứ hai là git-p4, một cầu nối phía máy khách cho phép bạn sử dụng Git như một máy khách Perforce, mà không yêu cầu bất kỳ cấu hình lại nào của máy chủ Perforce.

[[_p4_git_fusion]]
===== Git Fusion

(((Perforce, Git Fusion)))
Perforce cung cấp một sản phẩm gọi là Git Fusion (có sẵn tại https://www.perforce.com/manuals/git-fusion/[^]), đồng bộ hóa một máy chủ Perforce với các kho chứa Git ở phía máy chủ.

====== Thiết lập

Đối với các ví dụ của chúng tôi, chúng tôi sẽ sử dụng phương pháp cài đặt dễ nhất cho Git Fusion, đó là tải xuống một máy ảo chạy daemon Perforce và Git Fusion.
Bạn có thể lấy hình ảnh máy ảo từ https://www.perforce.com/downloads[^], và khi nó tải xuống xong, hãy nhập nó vào phần mềm ảo hóa yêu thích của bạn (chúng tôi sẽ sử dụng VirtualBox).

Khi khởi động máy lần đầu tiên, nó yêu cầu bạn tùy chỉnh mật khẩu cho ba người dùng Linux (`root`, `perforce`, và `git`), và cung cấp một tên phiên bản, có thể được sử dụng để phân biệt cài đặt này với các cài đặt khác trên cùng một mạng.
Khi tất cả đã hoàn tất, bạn sẽ thấy điều này:

.Màn hình khởi động máy ảo Git Fusion
image::images/git-fusion-boot.png[Màn hình khởi động máy ảo Git Fusion]

Bạn nên ghi chú địa chỉ IP được hiển thị ở đây, chúng ta sẽ sử dụng nó sau này.
Tiếp theo, chúng ta sẽ tạo một người dùng Perforce.
Chọn tùy chọn "`Login`" ở dưới cùng và nhấn enter (hoặc SSH vào máy), và đăng nhập với tư cách `root`.
Sau đó sử dụng các lệnh này để tạo một người dùng:

[source,console]
----
$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit
----

Lệnh đầu tiên sẽ mở trình soạn thảo VI để tùy chỉnh người dùng, nhưng bạn có thể chấp nhận các giá trị mặc định bằng cách gõ `:wq` và nhấn enter.
Lệnh thứ hai sẽ nhắc bạn nhập mật khẩu hai lần.
Đó là tất cả những gì chúng ta cần làm với dấu nhắc shell, vì vậy hãy thoát khỏi phiên.

Điều tiếp theo bạn sẽ cần làm để theo dõi là bảo Git không xác minh chứng chỉ SSL.
Hình ảnh Git Fusion đi kèm với một chứng chỉ, nhưng nó dành cho một tên miền sẽ không khớp với địa chỉ IP của máy ảo của bạn, vì vậy Git sẽ từ chối kết nối HTTPS.
Nếu đây sẽ là một cài đặt vĩnh viễn, hãy tham khảo hướng dẫn sử dụng Perforce Git Fusion để cài đặt một chứng chỉ khác; cho mục đích ví dụ của chúng tôi, điều này sẽ đủ:

[source,console]
----
$ export GIT_SSL_NO_VERIFY=true
----

Bây giờ chúng ta có thể kiểm tra xem mọi thứ có hoạt động không.

[source,console]
----
$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.
----

Hình ảnh máy ảo đi kèm với một dự án mẫu mà bạn có thể sao chép.
Ở đây chúng ta đang sao chép qua HTTPS, với người dùng `john` mà chúng ta đã tạo ở trên; Git yêu cầu thông tin xác thực cho kết nối này, nhưng bộ nhớ cache thông tin xác thực sẽ cho phép chúng ta bỏ qua bước này cho bất kỳ yêu cầu tiếp theo nào.

====== Cấu hình Fusion

Khi bạn đã cài đặt Git Fusion, bạn sẽ muốn điều chỉnh cấu hình.
Điều này thực sự khá dễ dàng để thực hiện bằng cách sử dụng máy khách Perforce yêu thích của bạn; chỉ cần ánh xạ thư mục `//.git-fusion` trên máy chủ Perforce vào không gian làm việc của bạn.
Cấu trúc tập tin trông như thế này:

[source,console]
----
$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files
----

Thư mục `objects` được sử dụng nội bộ bởi Git Fusion để ánh xạ các đối tượng Perforce sang Git và ngược lại, bạn sẽ không phải làm gì với bất cứ thứ gì ở đó.
Có một tập tin `p4gf_config` toàn cục trong thư mục này, cũng như một tập tin cho mỗi kho chứa – đây là các tập tin cấu hình xác định cách Git Fusion hoạt động.
Hãy xem xét tập tin trong thư mục gốc:

[source,ini]
----
[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no
----

Chúng tôi sẽ không đi vào ý nghĩa của các cờ này ở đây, nhưng lưu ý rằng đây chỉ là một tập tin văn bản được định dạng INI, giống như Git sử dụng cho cấu hình.
Tập tin này chỉ định các tùy chọn toàn cục, sau đó có thể bị ghi đè bởi các tập tin cấu hình cụ thể cho kho chứa, như `repos/Talkhouse/p4gf_config`.
Nếu bạn mở tập tin này, bạn sẽ thấy một phần `[@repo]` với một số thiết lập khác với các giá trị mặc định toàn cục.
Bạn cũng sẽ thấy các phần trông giống như thế này:

[source,ini]
----
[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...
----

Đây là một ánh xạ giữa một nhánh Perforce và một nhánh Git.
Phần này có thể được đặt tên bất cứ thứ gì bạn thích, miễn là tên là duy nhất.
`git-branch-name` cho phép bạn chuyển đổi một đường dẫn depot sẽ rườm rà dưới Git thành một tên thân thiện hơn.
Thiết lập `view` kiểm soát cách các tập tin Perforce được ánh xạ vào kho chứa Git, sử dụng cú pháp ánh xạ view tiêu chuẩn.
Có thể chỉ định nhiều hơn một ánh xạ, như trong ví dụ này:

[source,ini]
----
[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...
----

Bằng cách này, nếu ánh xạ không gian làm việc bình thường của bạn bao gồm các thay đổi trong cấu trúc của các thư mục, bạn có thể sao chép điều đó với một kho chứa Git.

Tập tin cuối cùng chúng ta sẽ thảo luận là `users/p4gf_usermap`, ánh xạ người dùng Perforce sang người dùng Git, và bạn thậm chí có thể không cần.
Khi chuyển đổi từ một changeset Perforce sang một commit Git, hành vi mặc định của Git Fusion là tra cứu người dùng Perforce, và sử dụng địa chỉ email và tên đầy đủ được lưu trữ ở đó cho trường tác giả/người commit trong Git.
Khi chuyển đổi theo cách khác, mặc định là tra cứu người dùng Perforce với địa chỉ email được lưu trữ trong trường tác giả của commit Git, và gửi changeset với tư cách là người dùng đó (với các quyền được áp dụng).
Trong hầu hết các trường hợp, hành vi này sẽ hoạt động tốt, nhưng hãy xem xét tập tin ánh xạ sau:

[source]
----
john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"
----

Mỗi dòng có định dạng `<user> <email> "<full name>"`, và tạo một ánh xạ người dùng duy nhất.
Hai dòng đầu tiên ánh xạ hai địa chỉ email riêng biệt vào cùng một tài khoản người dùng Perforce.
Điều này hữu ích nếu bạn đã tạo các commit Git dưới một số địa chỉ email khác nhau (hoặc thay đổi địa chỉ email), nhưng muốn chúng được ánh xạ vào cùng một người dùng Perforce.
Khi tạo một commit Git từ một changeset Perforce, dòng đầu tiên khớp với người dùng Perforce được sử dụng cho thông tin tác giả Git.

Hai dòng cuối cùng che giấu tên thực và địa chỉ email của Bob và Joe khỏi các commit Git được tạo.
Điều này tốt nếu bạn muốn mở mã nguồn một dự án nội bộ, nhưng không muốn xuất bản thư mục nhân viên của bạn ra toàn thế giới.
Lưu ý rằng các địa chỉ email và tên đầy đủ nên là duy nhất, trừ khi bạn muốn tất cả các commit Git được gán cho một tác giả hư cấu duy nhất.

====== Quy trình làm việc

Perforce Git Fusion là một cầu nối hai chiều giữa Perforce và kiểm soát phiên bản Git.
Hãy xem xét cảm giác làm việc từ phía Git như thế nào.
Chúng ta sẽ giả định rằng chúng ta đã ánh xạ trong dự án "`Jam`" bằng cách sử dụng một tập tin cấu hình như được hiển thị ở trên, mà chúng ta có thể sao chép như thế này:

[source,console]
----
$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]
----

Lần đầu tiên bạn làm điều này, nó có thể mất một chút thời gian.
Điều đang xảy ra là Git Fusion đang chuyển đổi tất cả các changeset áp dụng trong lịch sử Perforce thành các commit Git.
Điều này xảy ra cục bộ trên máy chủ, vì vậy nó tương đối nhanh, nhưng nếu bạn có nhiều lịch sử, nó vẫn có thể mất một chút thời gian.
Các lần lấy tiếp theo thực hiện chuyển đổi gia tăng, vì vậy nó sẽ cảm thấy giống như tốc độ bản địa của Git hơn.

Như bạn có thể thấy, kho chứa của chúng ta trông giống hệt như bất kỳ kho chứa Git nào khác mà bạn có thể làm việc.
Có ba nhánh, và Git đã hữu ích tạo một nhánh `master` cục bộ theo dõi `origin/master`.
Hãy thực hiện một chút công việc, và tạo một vài commit mới:

[source,console]
----
# ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

Chúng ta có hai commit mới.
Bây giờ hãy kiểm tra xem có ai khác đã làm việc không:

[source,console]
----
$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -> origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

Có vẻ như có người đã làm!
Bạn sẽ không biết điều đó từ góc nhìn này, nhưng commit `6afeb15` thực sự đã được tạo bằng cách sử dụng một máy khách Perforce.
Nó chỉ trông giống như một commit khác từ quan điểm của Git, đó chính xác là điểm mấu chốt.
Hãy xem máy chủ Perforce xử lý một commit trộn như thế nào:

[source,console]
----
$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -> master
----

Git nghĩ rằng nó đã hoạt động.
Hãy xem lịch sử của tập tin `README` từ quan điểm của Perforce, sử dụng tính năng đồ thị bản sửa đổi của `p4v`:

.Đồ thị bản sửa đổi Perforce kết quả từ Git push
image::images/git-fusion-perforce-graph.png[Đồ thị bản sửa đổi Perforce kết quả từ Git push]

Nếu bạn chưa bao giờ thấy góc nhìn này trước đây, nó có thể có vẻ khó hiểu, nhưng nó hiển thị các khái niệm giống như một trình xem đồ họa cho lịch sử Git.
Chúng ta đang xem xét lịch sử của tập tin `README`, vì vậy cây thư mục ở trên cùng bên trái chỉ hiển thị tập tin đó khi nó xuất hiện trong các nhánh khác nhau.
Ở trên cùng bên phải, chúng ta có một đồ thị trực quan về cách các bản sửa đổi khác nhau của tập tin có liên quan, và góc nhìn toàn cảnh của đồ thị này ở dưới cùng bên phải.
Phần còn lại của góc nhìn được dành cho góc nhìn chi tiết cho bản sửa đổi được chọn (`2` trong trường hợp này).

Một điều cần lưu ý là đồ thị trông giống hệt như đồ thị trong lịch sử của Git.
Perforce không có một nhánh được đặt tên để lưu trữ các commit `1` và `2`, vì vậy nó đã tạo một nhánh "`ẩn danh`" trong thư mục `.git-fusion` để giữ nó.
Điều này cũng sẽ xảy ra đối với các nhánh Git được đặt tên không tương ứng với một nhánh Perforce được đặt tên (và sau đó bạn có thể ánh xạ chúng vào một nhánh Perforce bằng cách sử dụng tập tin cấu hình).

Hầu hết điều này xảy ra đằng sau hậu trường, nhưng kết quả cuối cùng là một người trong nhóm có thể đang sử dụng Git, một người khác có thể đang sử dụng Perforce, và không ai trong số họ sẽ biết về sự lựa chọn của người kia.

====== Tóm tắt Git-Fusion

Nếu bạn có (hoặc có thể có) quyền truy cập vào máy chủ Perforce của mình, Git Fusion là một cách tuyệt vời để làm cho Git và Perforce nói chuyện với nhau.
Có một chút cấu hình liên quan, nhưng đường cong học tập không quá dốc.
Đây là một trong số ít phần trong chương này mà các cảnh báo về việc sử dụng toàn bộ sức mạnh của Git sẽ không xuất hiện.
Điều đó không có nghĩa là Perforce sẽ hài lòng với mọi thứ bạn ném vào nó – nếu bạn cố gắng viết lại lịch sử đã được đẩy, Git Fusion sẽ từ chối nó – nhưng Git Fusion cố gắng rất nhiều để cảm thấy bản địa.
Bạn thậm chí có thể sử dụng các submodule Git (mặc dù chúng sẽ trông lạ đối với người dùng Perforce), và trộn các nhánh (điều này sẽ được ghi lại như một tích hợp ở phía Perforce).

Nếu bạn không thể thuyết phục quản trị viên máy chủ của mình thiết lập Git Fusion, vẫn có một cách để sử dụng các công cụ này cùng nhau.

[[_git_p4_client]]
===== Git-p4

(((git commands, p4)))
Git-p4 là một cầu nối hai chiều giữa Git và Perforce.
Nó chạy hoàn toàn bên trong kho chứa Git của bạn, vì vậy bạn sẽ không cần bất kỳ loại quyền truy cập nào vào máy chủ Perforce (ngoài thông tin xác thực người dùng, tất nhiên).
Git-p4 không phải là một giải pháp linh hoạt hoặc hoàn chỉnh như Git Fusion, nhưng nó cho phép bạn làm hầu hết những gì bạn muốn làm mà không xâm phạm vào môi trường máy chủ.

[NOTE]
======
Bạn sẽ cần công cụ `p4` ở đâu đó trong `PATH` của bạn để làm việc với git-p4.
Tính đến thời điểm viết bài này, nó có sẵn miễn phí tại https://www.perforce.com/downloads/helix-command-line-client-p4[^].
======

====== Thiết lập

Cho mục đích ví dụ, chúng ta sẽ chạy máy chủ Perforce từ Git Fusion OVA như được hiển thị ở trên, nhưng chúng ta sẽ bỏ qua máy chủ Git Fusion và đi trực tiếp đến kiểm soát phiên bản Perforce.

Để sử dụng máy khách dòng lệnh `p4` (mà git-p4 phụ thuộc vào), bạn sẽ cần đặt một vài biến môi trường:

[source,console]
----
$ export P4PORT=10.0.1.254:1666
$ export P4USER=john
----

====== Bắt đầu

Như với bất cứ thứ gì trong Git, lệnh đầu tiên là sao chép:

[source,console]
----
$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master
----

Điều này tạo ra những gì trong thuật ngữ Git là một bản sao "`nông`" (shallow); chỉ bản sửa đổi Perforce mới nhất được nhập vào Git; hãy nhớ rằng, Perforce không được thiết kế để cung cấp mọi bản sửa đổi cho mọi người dùng.
Điều này đủ để sử dụng Git như một máy khách Perforce, nhưng cho các mục đích khác thì không đủ.

Khi nó hoàn thành, chúng ta có một kho chứa Git hoạt động đầy đủ:

[source,console]
----
$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head
----

Lưu ý cách có một máy từ xa "`p4`" cho máy chủ Perforce, nhưng mọi thứ khác trông giống như một bản sao tiêu chuẩn.
Thực ra, điều đó hơi gây hiểu lầm; thực sự không có một máy từ xa ở đó.

[source,console]
----
$ git remote -v
----

Không có máy từ xa nào tồn tại trong kho chứa này cả.
Git-p4 đã tạo một số tham chiếu để đại diện cho trạng thái của máy chủ, và chúng trông giống như các tham chiếu từ xa đối với `git log`, nhưng chúng không được quản lý bởi chính Git, và bạn không thể đẩy lên chúng.

====== Quy trình làm việc

Được rồi, hãy thực hiện một số công việc.
Giả sử bạn đã đạt được một số tiến bộ trên một tính năng rất quan trọng, và bạn đã sẵn sàng để hiển thị nó cho phần còn lại của nhóm của bạn.

[source,console]
----
$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head
----

Chúng ta đã thực hiện hai commit mới mà chúng ta đã sẵn sàng gửi đến máy chủ Perforce.
Hãy kiểm tra xem có ai khác đã làm việc hôm nay không:

[source,console]
----
$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Có vẻ như họ đã làm, và `master` và `p4/master` đã phân kỳ.
Hệ thống phân nhánh của Perforce _không giống gì_ như của Git, vì vậy việc gửi các commit trộn không có ý nghĩa gì.
Git-p4 khuyến nghị rằng bạn rebase các commit của mình, và thậm chí đi kèm với một phím tắt để làm như vậy:

[source,console]
----
$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Bạn có thể có thể biết từ đầu ra, nhưng `git p4 rebase` là một phím tắt cho `git p4 sync` theo sau là `git rebase p4/master`.
Nó thông minh hơn một chút so với điều đó, đặc biệt là khi làm việc với nhiều nhánh, nhưng đây là một xấp xỉ tốt.

Bây giờ lịch sử của chúng ta lại tuyến tính, và chúng ta đã sẵn sàng đóng góp các thay đổi của mình trở lại Perforce.
Lệnh `git p4 submit` sẽ cố gắng tạo một bản sửa đổi Perforce mới cho mỗi commit Git giữa `p4/master` và `master`.
Chạy nó đưa chúng ta vào trình soạn thảo yêu thích của chúng ta, và nội dung của tập tin trông giống như thế này:

[source,console]
----
# A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 </td>
 <td valign=top>
 Source and documentation for
-<a href="http://www.perforce.com/jam/jam.html">
+<a href="jam.html">
 Jam/MR</a>,
 a software build tool.
 </td>
----

Đây chủ yếu là cùng một nội dung mà bạn sẽ thấy bằng cách chạy `p4 submit`, ngoại trừ phần ở cuối mà git-p4 đã hữu ích bao gồm.
Git-p4 cố gắng tôn trọng các thiết lập Git và Perforce của bạn riêng lẻ khi nó phải cung cấp một tên cho một commit hoặc changeset, nhưng trong một số trường hợp bạn muốn ghi đè nó.
Ví dụ, nếu commit Git bạn đang nhập được viết bởi một người đóng góp không có tài khoản người dùng Perforce, bạn vẫn có thể muốn changeset kết quả trông giống như họ đã viết nó (và không phải bạn).

Git-p4 đã hữu ích nhập thông điệp từ commit Git làm nội dung cho changeset Perforce này, vì vậy tất cả những gì chúng ta phải làm là lưu và thoát, hai lần (một lần cho mỗi commit).
Đầu ra shell kết quả sẽ trông giống như thế này:

[source,console]
----
$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Kết quả là như thể chúng ta vừa thực hiện một `git push`, đó là sự tương tự gần nhất với những gì thực sự đã xảy ra.

Lưu ý rằng trong quá trình này, mỗi commit Git được biến thành một changeset Perforce; nếu bạn muốn squash chúng xuống thành một changeset duy nhất, bạn có thể làm điều đó với một rebase tương tác trước khi chạy `git p4 submit`.
Cũng lưu ý rằng các hàm băm SHA-1 của tất cả các commit đã được gửi dưới dạng changeset đã thay đổi; điều này là do git-p4 thêm một dòng vào cuối mỗi commit mà nó chuyển đổi:

[source,console]
----
$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe <john@example.com>
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]
----

Điều gì xảy ra nếu bạn cố gắng gửi một commit trộn?
Hãy thử xem.
Đây là tình huống chúng ta đã tự đưa mình vào:

[source,console]
----
$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Lịch sử Git và Perforce phân kỳ sau `775a46f`.
Phía Git có hai commit, sau đó là một commit trộn với đầu Perforce, sau đó là một commit khác.
Chúng ta sẽ cố gắng gửi những cái này lên trên một changeset duy nhất ở phía Perforce.
Hãy xem điều gì sẽ xảy ra nếu chúng ta cố gắng gửi bây giờ:

[source,console]
----
$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address
----

Cờ `-n` là viết tắt của `--dry-run`, cố gắng báo cáo những gì sẽ xảy ra nếu lệnh submit được chạy thực sự.
Trong trường hợp này, có vẻ như chúng ta sẽ tạo ba changeset Perforce, tương ứng với ba commit không trộn chưa tồn tại trên máy chủ Perforce.
Điều đó nghe giống như chính xác những gì chúng ta muốn, hãy xem nó hóa ra như thế nào:

[source,console]
----
$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Lịch sử của chúng ta đã trở nên tuyến tính, giống như thể chúng ta đã rebase trước khi gửi (đó thực sự chính xác là những gì đã xảy ra).
Điều này có nghĩa là bạn có thể tự do tạo, làm việc, vứt bỏ, và trộn các nhánh ở phía Git mà không sợ rằng lịch sử của bạn sẽ bằng cách nào đó trở nên không tương thích với Perforce.
Nếu bạn có thể rebase nó, bạn có thể đóng góp nó cho một máy chủ Perforce.

[[_git_p4_branches]]
====== Phân nhánh

Nếu dự án Perforce của bạn có nhiều nhánh, bạn không hết may mắn; git-p4 có thể xử lý điều đó theo cách làm cho nó cảm thấy giống như Git.
Giả sử depot Perforce của bạn được bố trí như thế này:

[source]
----
//depot
  └── project
      ├── main
      └── dev
----

Và giả sử bạn có một nhánh `dev`, có một đặc tả view trông giống như thế này:

[source]
----
//depot/project/main/... //depot/project/dev/...
----

Git-p4 có thể tự động phát hiện tình huống đó và làm điều đúng đắn:

[source,console]
----
$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init
----

Lưu ý bộ chỉ định "`@all`" trong đường dẫn depot; điều đó bảo git-p4 sao chép không chỉ changeset mới nhất cho cây con đó, mà tất cả các changeset đã từng chạm vào các đường dẫn đó.
Điều này gần hơn với khái niệm sao chép của Git, nhưng nếu bạn đang làm việc trên một dự án có lịch sử dài, nó có thể mất một lúc.

Cờ `--detect-branches` bảo git-p4 sử dụng các đặc tả nhánh của Perforce để ánh xạ các nhánh vào các tham chiếu Git.
Nếu các ánh xạ này không có trên máy chủ Perforce (đó là một cách hoàn toàn hợp lệ để sử dụng Perforce), bạn có thể bảo git-p4 các ánh xạ nhánh là gì, và bạn nhận được cùng một kết quả:

[source,console]
----
$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .
----

Đặt biến cấu hình `git-p4.branchList` thành `main:dev` bảo git-p4 rằng "`main`" và "`dev`" đều là các nhánh, và cái thứ hai là con của cái đầu tiên.

Nếu bây giờ chúng ta `git checkout -b dev p4/project/dev` và thực hiện một số commit, git-p4 đủ thông minh để nhắm đúng nhánh khi chúng ta thực hiện `git p4 submit`.
Thật không may, git-p4 không thể trộn các bản sao nông và nhiều nhánh; nếu bạn có một dự án khổng lồ và muốn làm việc trên nhiều hơn một nhánh, bạn sẽ phải `git p4 clone` một lần cho mỗi nhánh bạn muốn gửi đến.

Để tạo hoặc tích hợp các nhánh, bạn sẽ phải sử dụng một máy khách Perforce.
Git-p4 chỉ có thể đồng bộ hóa và gửi đến các nhánh hiện có, và nó chỉ có thể làm điều đó một changeset tuyến tính tại một thời điểm.
Nếu bạn trộn hai nhánh trong Git và cố gắng gửi changeset mới, tất cả những gì sẽ được ghi lại là một loạt các thay đổi tập tin; siêu dữ liệu về các nhánh nào liên quan đến việc tích hợp sẽ bị mất.

===== Tóm tắt Git và Perforce

Git-p4 làm cho việc sử dụng quy trình làm việc Git với một máy chủ Perforce trở nên khả thi, và nó khá tốt trong việc đó.
Tuy nhiên, điều quan trọng cần nhớ là Perforce đang phụ trách nguồn, và bạn chỉ đang sử dụng Git để làm việc cục bộ.
Chỉ cần thực sự cẩn thận về việc chia sẻ các commit Git; nếu bạn có một máy từ xa mà người khác sử dụng, đừng đẩy bất kỳ commit nào chưa được gửi đến máy chủ Perforce.

Nếu bạn muốn tự do kết hợp việc sử dụng Perforce và Git như các máy khách để kiểm soát nguồn, và bạn có thể thuyết phục quản trị viên máy chủ cài đặt nó, Git Fusion làm cho việc sử dụng Git trở thành một máy khách kiểm soát phiên bản hạng nhất cho một máy chủ Perforce.
