[[C-git-commands]]
[appendix]
== Các Lệnh Git

Trong suốt cuốn sách, chúng tôi đã giới thiệu hàng chục lệnh Git và đã cố gắng hết sức để giới thiệu chúng trong một câu chuyện, thêm nhiều lệnh vào câu chuyện một cách từ từ.
Tuy nhiên, điều này khiến các ví dụ về việc sử dụng các lệnh nằm rải rác trong toàn bộ cuốn sách.

Trong phụ lục này, chúng tôi sẽ đi qua tất cả các lệnh Git mà chúng tôi đã đề cập trong suốt cuốn sách, được nhóm lại đại khái theo mục đích sử dụng của chúng.
Chúng tôi sẽ nói về những gì mỗi lệnh thực hiện một cách tổng quát và sau đó chỉ ra nơi trong cuốn sách bạn có thể tìm thấy chúng tôi đã sử dụng nó.

[TIP]
====
Bạn có thể viết tắt các tùy chọn dài.
Ví dụ: bạn có thể nhập `git commit --a`, hoạt động giống như khi bạn nhập `git commit --amend`.
Điều này chỉ hoạt động khi các chữ cái sau `--` là duy nhất cho một tùy chọn.
Hãy sử dụng tùy chọn đầy đủ khi viết các tập lệnh.
====

=== Cài đặt và Cấu hình

Có hai lệnh được sử dụng khá nhiều, từ những lần gọi Git đầu tiên đến việc tinh chỉnh và tham khảo thông thường hàng ngày, đó là các lệnh `config` và `help`.

==== git config

Git có một cách mặc định để làm hàng trăm thứ.
Đối với rất nhiều thứ trong số này, bạn có thể bảo Git mặc định làm chúng theo một cách khác, hoặc thiết lập các tùy chọn của bạn.
Điều này bao gồm mọi thứ từ việc cho Git biết tên của bạn là gì đến các tùy chọn màu sắc cụ thể của thiết bị đầu cuối hoặc trình soạn thảo bạn sử dụng.
Có một số tệp mà lệnh này sẽ đọc và ghi vào để bạn có thể đặt các giá trị trên toàn cầu hoặc xuống các kho lưu trữ cụ thể.

Lệnh `git config` đã được sử dụng trong gần như mọi chương của cuốn sách.

Trong <<ch01-getting-started#_first_time>>, chúng tôi đã sử dụng nó để chỉ định tên, địa chỉ email và trình soạn thảo ưu tiên của chúng tôi trước khi chúng tôi bắt đầu sử dụng Git.

Trong <<ch02-git-basics-chapter#_git_aliases>>, chúng tôi đã chỉ ra cách bạn có thể sử dụng nó để tạo các lệnh viết tắt mở rộng thành các chuỗi tùy chọn dài để bạn không phải nhập chúng mỗi lần.

Trong <<ch03-git-branching#_rebasing>>, chúng tôi đã sử dụng nó để đặt `--rebase` làm mặc định khi bạn chạy `git pull`.

Trong <<ch07-git-tools#_credential_caching>>, chúng tôi đã sử dụng nó để thiết lập một kho lưu trữ mặc định cho mật khẩu HTTP của bạn.

Trong <<ch08-customizing-git#_keyword_expansion>>, chúng tôi đã chỉ ra cách thiết lập các bộ lọc smudge và clean trên nội dung vào và ra khỏi Git.

Cuối cùng, về cơ bản toàn bộ <<ch08-customizing-git#_git_config>> được dành riêng cho lệnh này.

[[ch_core_editor]]
==== các lệnh git config core.editor

Đi kèm với các hướng dẫn cấu hình trong <<ch01-getting-started#_editor>>, nhiều trình soạn thảo có thể được thiết lập như sau:

.Danh sách đầy đủ các lệnh cấu hình `core.editor`
[cols="1,2",options="header"]
|==============================
|Trình soạn thảo | Lệnh cấu hình
|Atom |`git config --global core.editor "atom --wait"`
|BBEdit (macOS, với các công cụ dòng lệnh) |`git config --global core.editor "bbedit -w"`
|Emacs |`git config --global core.editor emacs`
|Gedit (Linux) |`git config --global core.editor "gedit --wait --new-window"`
|Gvim (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Vim\vim72\gvim.exe' --nofork '%*'"` (Xem thêm lưu ý bên dưới)
|Helix |`git config --global core.editor "hx"`
|Kate (Linux) |`git config --global core.editor "kate --block"`
|nano |`git config --global core.editor "nano -w"`
|Notepad (Windows 64-bit) |`git config core.editor notepad`
|Notepad++ (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Notepad+\+\notepad++.exe' -multiInst -notabbar -nosession -noPlugin"` (Xem thêm lưu ý bên dưới)
|Scratch (Linux)|`git config --global core.editor "scratch-text-editor"`
|Sublime Text (macOS) |`git config --global core.editor "/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl --new-window --wait"`
|Sublime Text (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Sublime Text 3\sublime_text.exe' -w"` (Xem thêm lưu ý bên dưới)
|TextEdit (macOS)|`git config --global core.editor "open --wait-apps --new -e"`
|Textmate |`git config --global core.editor "mate -w"`
|Textpad (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\TextPad 5\TextPad.exe' -m"` (Xem thêm lưu ý bên dưới)
|UltraEdit (Windows 64-bit) | `git config --global core.editor Uedit32`
|Vim |`git config --global core.editor "vim --nofork"`
|Visual Studio Code |`git config --global core.editor "code --wait"`
|VSCodium (Phần mềm nguồn mở miễn phí/tự do của VSCode) | `git config --global core.editor "codium --wait"`
|WordPad |`git config --global core.editor "'C:\Program Files\Windows NT\Accessories\wordpad.exe'"`
|Xi | `git config --global core.editor "xi --wait"`
|==============================

[NOTE]
====
Nếu bạn có trình soạn thảo 32-bit trên hệ thống Windows 64-bit, chương trình sẽ được cài đặt trong `C:\Program Files (x86)\` thay vì `C:\Program Files\` như trong bảng trên.
====

==== git help

Lệnh `git help` được sử dụng để hiển thị cho bạn tất cả các tài liệu đi kèm với Git về bất kỳ lệnh nào.
Mặc dù chúng tôi đang đưa ra một cái nhìn tổng quan sơ bộ về hầu hết các lệnh phổ biến hơn trong phụ lục này, để có danh sách đầy đủ tất cả các tùy chọn và cờ có thể cho mọi lệnh, bạn luôn có thể chạy `git help <command>`.

Chúng tôi đã giới thiệu lệnh `git help` trong <<ch01-getting-started#_git_help>> và chỉ cho bạn cách sử dụng nó để tìm thêm thông tin về `git shell` trong <<ch04-git-on-the-server#_setting_up_server>>.

=== Nhận và Tạo Dự án

Có hai cách để có được một kho lưu trữ Git.
Một là sao chép nó từ một kho lưu trữ hiện có trên mạng hoặc nơi khác và hai là tạo một cái mới trong một thư mục hiện có.

==== git init

Để lấy một thư mục và biến nó thành một kho lưu trữ Git mới để bạn có thể bắt đầu kiểm soát phiên bản nó, bạn chỉ cần chạy `git init`.

Chúng tôi giới thiệu điều này lần đầu tiên trong <<ch02-git-basics-chapter#_getting_a_repo>>, nơi chúng tôi chỉ ra việc tạo một kho lưu trữ hoàn toàn mới để bắt đầu làm việc.

Chúng tôi nói ngắn gọn về cách bạn có thể thay đổi tên nhánh mặc định từ "`master`" trong <<ch03-git-branching#_remote_branches>>.

Chúng tôi sử dụng lệnh này để tạo một kho lưu trữ trần (bare repository) trống cho một máy chủ trong <<ch04-git-on-the-server#_bare_repo>>.

Cuối cùng, chúng tôi đi qua một số chi tiết về những gì nó thực sự làm ở hậu trường trong <<ch10-git-internals#_plumbing_porcelain>>.

==== git clone

Lệnh `git clone` thực sự là một trình bao bọc xung quanh một số lệnh khác.
Nó tạo một thư mục mới, đi vào đó và chạy `git init` để biến nó thành một kho lưu trữ Git trống, thêm một điều khiển từ xa (`git remote add`) vào URL mà bạn chuyển cho nó (theo mặc định được đặt tên là `origin`), chạy `git fetch` từ kho lưu trữ từ xa đó và sau đó kiểm xuất (checkout) cam kết mới nhất vào thư mục làm việc của bạn với `git checkout`.

Lệnh `git clone` được sử dụng ở hàng chục nơi trong suốt cuốn sách, nhưng chúng tôi sẽ chỉ liệt kê một vài nơi thú vị.

Về cơ bản, nó được giới thiệu và giải thích trong <<ch02-git-basics-chapter#_git_cloning>>, nơi chúng tôi đi qua một vài ví dụ.

Trong <<ch04-git-on-the-server#_getting_git_on_a_server>>, chúng tôi xem xét việc sử dụng tùy chọn `--bare` để tạo một bản sao của kho lưu trữ Git không có thư mục làm việc.

Trong <<ch07-git-tools#_bundling>>, chúng tôi sử dụng nó để giải nén một kho lưu trữ Git đã được đóng gói.

Cuối cùng, trong <<ch07-git-tools#_cloning_submodules>>, chúng tôi tìm hiểu tùy chọn `--recurse-submodules` để làm cho việc sao chép một kho lưu trữ với các mô-đun con đơn giản hơn một chút.

Mặc dù nó được sử dụng ở nhiều nơi khác trong cuốn sách, nhưng đây là những nơi có phần độc đáo hoặc nơi nó được sử dụng theo những cách hơi khác một chút.

=== Snapshot Cơ bản

Đối với quy trình làm việc cơ bản của việc tổ chức nội dung (staging) và cam kết (committing) nó vào lịch sử của bạn, chỉ có một vài lệnh cơ bản.

==== git add

Lệnh `git add` thêm nội dung từ thư mục làm việc vào khu vực tổ chức (hoặc "`index`") cho cam kết tiếp theo.
Khi lệnh `git commit` được chạy, theo mặc định, nó chỉ nhìn vào khu vực tổ chức này, vì vậy `git add` được sử dụng để tạo ra chính xác những gì bạn muốn ảnh chụp nhanh cam kết tiếp theo của mình trông như thế nào.

Lệnh này là một lệnh cực kỳ quan trọng trong Git và được đề cập hoặc sử dụng hàng chục lần trong cuốn sách này.
Chúng tôi sẽ nhanh chóng đề cập đến một số cách sử dụng độc đáo có thể được tìm thấy.

Chúng tôi giới thiệu và giải thích `git add` chi tiết lần đầu tiên trong <<ch02-git-basics-chapter#_tracking_files>>.

Chúng tôi đề cập đến cách sử dụng nó để giải quyết xung đột hợp nhất trong <<ch03-git-branching#_basic_merge_conflicts>>.

Chúng tôi xem xét việc sử dụng nó để tổ chức tương tác chỉ các phần cụ thể của tệp đã sửa đổi trong <<ch07-git-tools#_interactive_staging>>.

Cuối cùng, chúng tôi mô phỏng nó ở cấp độ thấp trong <<ch10-git-internals#_tree_objects>>, để bạn có thể biết nó đang làm gì ở hậu trường.

==== git status

Lệnh `git status` sẽ hiển thị cho bạn các trạng thái khác nhau của các tệp trong thư mục làm việc và khu vực tổ chức của bạn.
Những tệp nào được sửa đổi và chưa được tổ chức và những tệp nào được tổ chức nhưng chưa được cam kết.
Ở dạng bình thường, nó cũng sẽ hiển thị cho bạn một số gợi ý cơ bản về cách di chuyển các tệp giữa các giai đoạn này.

Chúng tôi đề cập đến `status` lần đầu tiên trong <<ch02-git-basics-chapter#_checking_status>>, cả ở dạng cơ bản và đơn giản hóa.
Mặc dù chúng tôi sử dụng nó trong suốt cuốn sách, nhưng hầu như mọi thứ bạn có thể làm với lệnh `git status` đều được đề cập ở đó.

==== git diff

Lệnh `git diff` được sử dụng khi bạn muốn xem sự khác biệt giữa bất kỳ hai cây (tree) nào.
Đây có thể là sự khác biệt giữa môi trường làm việc và khu vực tổ chức của bạn (`git diff` một mình), giữa khu vực tổ chức và cam kết cuối cùng của bạn (`git diff --staged`), hoặc giữa hai cam kết (`git diff master branchB`).

Chúng tôi xem xét các cách sử dụng cơ bản của `git diff` lần đầu tiên trong <<ch02-git-basics-chapter#_git_diff_staged>>, nơi chúng tôi chỉ ra cách xem những thay đổi nào được tổ chức và những thay đổi nào chưa được tổ chức.

Chúng tôi sử dụng nó để tìm các vấn đề về khoảng trắng có thể xảy ra trước khi cam kết với tùy chọn `--check` trong <<ch05-distributed-git#_commit_guidelines>>.

Chúng tôi xem cách kiểm tra sự khác biệt giữa các nhánh hiệu quả hơn với cú pháp `git diff A...B` trong <<ch05-distributed-git#_what_is_introduced>>.

Chúng tôi sử dụng nó để lọc ra các khác biệt về khoảng trắng với `-b` và cách so sánh các giai đoạn khác nhau của các tệp bị xung đột với `--theirs`, `--ours` và `--base` trong <<ch07-git-tools#_advanced_merging>>.

Cuối cùng, chúng tôi sử dụng nó để so sánh hiệu quả các thay đổi mô-đun con với `--submodule` trong <<ch07-git-tools#_starting_submodules>>.

==== git difftool

Lệnh `git difftool` chỉ đơn giản là khởi chạy một công cụ bên ngoài để hiển thị cho bạn sự khác biệt giữa hai cây trong trường hợp bạn muốn sử dụng thứ gì đó khác ngoài lệnh `git diff` tích hợp sẵn.

Chúng tôi chỉ đề cập ngắn gọn về điều này trong <<ch02-git-basics-chapter#_git_diff_staged>>.

==== git commit

Lệnh `git commit` lấy tất cả nội dung tệp đã được tổ chức với `git add` và ghi lại một ảnh chụp nhanh vĩnh viễn mới trong cơ sở dữ liệu và sau đó di chuyển con trỏ nhánh trên nhánh hiện tại lên đó.

Chúng tôi đề cập đến những điều cơ bản về cam kết lần đầu tiên trong <<ch02-git-basics-chapter#_committing_changes>>.
Ở đó, chúng tôi cũng trình bày cách sử dụng cờ `-a` để bỏ qua bước `git add` trong quy trình làm việc hàng ngày và cách sử dụng cờ `-m` để chuyển thông báo cam kết vào dòng lệnh thay vì kích hoạt trình soạn thảo.

Trong <<ch02-git-basics-chapter#_undoing>>, chúng tôi đề cập đến việc sử dụng tùy chọn `--amend` để làm lại cam kết gần đây nhất.

Trong <<ch03-git-branching#_git_branches_overview>>, chúng tôi đi sâu hơn nhiều về những gì `git commit` làm và tại sao nó lại làm như vậy.

Chúng tôi đã xem xét cách ký các cam kết bằng mật mã với cờ `-S` trong <<ch07-git-tools#_signing_commits>>.

Cuối cùng, chúng tôi xem xét những gì lệnh `git commit` làm trong nền và cách nó thực sự được triển khai trong <<ch10-git-internals#_git_commit_objects>>.

==== git reset

Lệnh `git reset` chủ yếu được sử dụng để hoàn tác mọi thứ, như bạn có thể đoán qua động từ.
Nó di chuyển con trỏ `HEAD` và tùy chọn thay đổi `index` hoặc khu vực tổ chức và cũng có thể tùy chọn thay đổi thư mục làm việc nếu bạn sử dụng `--hard`.
Tùy chọn cuối cùng này có thể khiến lệnh này làm mất công việc của bạn nếu sử dụng không đúng cách, vì vậy hãy đảm bảo bạn hiểu nó trước khi sử dụng.

Chúng tôi đề cập hiệu quả đến cách sử dụng đơn giản nhất của `git reset` lần đầu tiên trong <<ch02-git-basics-chapter#_unstaging>>, nơi chúng tôi sử dụng nó để hủy tổ chức một tệp mà chúng tôi đã chạy `git add`.

Sau đó, chúng tôi đề cập đến nó khá chi tiết trong <<ch07-git-tools#_git_reset>>, phần này hoàn toàn dành riêng để giải thích lệnh này.

Chúng tôi sử dụng `git reset --hard` để hủy bỏ hợp nhất trong <<ch07-git-tools#_abort_merge>>, nơi chúng tôi cũng sử dụng `git merge --abort`, đây là một trình bao bọc cho lệnh `git reset`.

==== git rm

Lệnh `git rm` được sử dụng để xóa các tệp khỏi khu vực tổ chức và thư mục làm việc cho Git.
Nó tương tự như `git add` ở chỗ nó tổ chức việc xóa một tệp cho cam kết tiếp theo.

Chúng tôi đề cập đến lệnh `git rm` khá chi tiết trong <<ch02-git-basics-chapter#_removing_files>>, bao gồm xóa đệ quy các tệp và chỉ xóa các tệp khỏi khu vực tổ chức nhưng để chúng trong thư mục làm việc với `--cached`.

Cách sử dụng khác duy nhất của `git rm` trong cuốn sách là trong <<ch10-git-internals#_removing_objects>>, nơi chúng tôi sử dụng và giải thích ngắn gọn về `--ignore-unmatch` khi chạy `git filter-branch`, điều này chỉ đơn giản là làm cho nó không bị lỗi khi tệp chúng tôi đang cố gắng xóa không tồn tại.
Điều này có thể hữu ích cho mục đích viết kịch bản.

==== git mv

Lệnh `git mv` là một lệnh tiện lợi mỏng để di chuyển một tệp và sau đó chạy `git add` trên tệp mới và `git rm` trên tệp cũ.

Chúng tôi chỉ đề cập ngắn gọn về lệnh này trong <<ch02-git-basics-chapter#_git_mv>>.

==== git clean

Lệnh `git clean` được sử dụng để xóa các tệp không mong muốn khỏi thư mục làm việc của bạn.
Điều này có thể bao gồm việc xóa các tạo phẩm xây dựng tạm thời hoặc các tệp xung đột hợp nhất.

Chúng tôi đề cập đến nhiều tùy chọn và kịch bản mà bạn có thể sử dụng lệnh clean trong <<ch07-git-tools#_git_clean>>.

=== Nhánh và Hợp nhất

Chỉ có một số ít lệnh thực hiện hầu hết các chức năng phân nhánh và hợp nhất trong Git.

==== git branch

Lệnh `git branch` thực sự là một công cụ quản lý nhánh.
Nó có thể liệt kê các nhánh bạn có, tạo một nhánh mới, xóa các nhánh và đổi tên các nhánh.

Hầu hết <<ch03-git-branching#ch03-git-branching>> được dành riêng cho lệnh `branch` và nó được sử dụng trong toàn bộ chương.
Chúng tôi giới thiệu nó lần đầu tiên trong <<ch03-git-branching#_create_new_branch>> và chúng tôi đi qua hầu hết các tính năng khác của nó (liệt kê và xóa) trong <<ch03-git-branching#_branch_management>>.

Trong <<ch03-git-branching#_tracking_branches>>, chúng tôi sử dụng tùy chọn `git branch -u` để thiết lập một nhánh theo dõi.

Cuối cùng, chúng tôi đi qua một số điều nó làm trong nền trong <<ch10-git-internals#_git_refs>>.

==== git checkout

Lệnh `git checkout` được sử dụng để chuyển đổi các nhánh và kiểm xuất nội dung vào thư mục làm việc của bạn.

Chúng tôi gặp lệnh này lần đầu tiên trong <<ch03-git-branching#_switching_branches>> cùng với lệnh `git branch`.

Chúng tôi xem cách sử dụng nó để bắt đầu theo dõi các nhánh với cờ `--track` trong <<ch03-git-branching#_tracking_branches>>.

Chúng tôi sử dụng nó để giới thiệu lại các xung đột tệp với `--conflict=diff3` trong <<ch07-git-tools#_checking_out_conflicts>>.

Chúng tôi đi vào chi tiết hơn về mối quan hệ của nó với `git reset` trong <<ch07-git-tools#_git_reset>>.

Cuối cùng, chúng tôi đi vào một số chi tiết triển khai trong <<ch10-git-internals#ref_the_ref>>.

==== git merge

Công cụ `git merge` được sử dụng để hợp nhất một hoặc nhiều nhánh vào nhánh bạn đã kiểm xuất.
Sau đó, nó sẽ nâng nhánh hiện tại lên kết quả của việc hợp nhất.

Lệnh `git merge` được giới thiệu lần đầu tiên trong <<ch03-git-branching#_basic_branching>>.
Mặc dù nó được sử dụng ở nhiều nơi khác nhau trong cuốn sách, nhưng có rất ít biến thể của lệnh `merge` -- thường chỉ là `git merge <branch>` với tên của nhánh duy nhất bạn muốn hợp nhất vào.

Chúng tôi đã đề cập đến cách thực hiện hợp nhất nén (squashed merge) (nơi Git hợp nhất công việc nhưng giả vờ như đó chỉ là một cam kết mới mà không ghi lại lịch sử của nhánh bạn đang hợp nhất vào) ở phần cuối của <<ch05-distributed-git#_public_project>>.

Chúng tôi đã đi qua rất nhiều về quy trình và lệnh hợp nhất, bao gồm lệnh `-Xignore-space-change` và cờ `--abort` để hủy bỏ một hợp nhất có vấn đề trong <<ch07-git-tools#_advanced_merging>>.

Chúng tôi đã học cách xác minh chữ ký trước khi hợp nhất nếu dự án của bạn đang sử dụng ký GPG trong <<ch07-git-tools#_signing_commits>>.

Cuối cùng, chúng tôi đã tìm hiểu về hợp nhất Subtree trong <<ch07-git-tools#_subtree_merge>>.

==== git mergetool

Lệnh `git mergetool` chỉ đơn giản là khởi chạy một trình trợ giúp hợp nhất bên ngoài trong trường hợp bạn gặp sự cố với việc hợp nhất trong Git.

Chúng tôi đề cập nhanh đến nó trong <<ch03-git-branching#_basic_merge_conflicts>> và đi vào chi tiết về cách triển khai công cụ hợp nhất bên ngoài của riêng bạn trong <<ch08-customizing-git#_external_merge_tools>>.

==== git log

Lệnh `git log` được sử dụng để hiển thị lịch sử được ghi lại có thể truy cập của một dự án từ ảnh chụp nhanh cam kết gần đây nhất trở về trước.
Theo mặc định, nó sẽ chỉ hiển thị lịch sử của nhánh bạn đang ở, nhưng có thể được cung cấp các đầu (heads) hoặc nhánh khác nhau hoặc thậm chí nhiều nhánh để duyệt qua.
Nó cũng thường được sử dụng để hiển thị sự khác biệt giữa hai hoặc nhiều nhánh ở cấp độ cam kết.

Lệnh này được sử dụng trong gần như mọi chương của cuốn sách để minh họa lịch sử của một dự án.

Chúng tôi giới thiệu lệnh và đề cập đến nó ở một mức độ sâu nào đó trong <<ch02-git-basics-chapter#_viewing_history>>.
Ở đó, chúng tôi xem xét tùy chọn `-p` và `--stat` để biết những gì đã được giới thiệu trong mỗi cam kết và các tùy chọn `--pretty` và `--oneline` để xem lịch sử ngắn gọn hơn, cùng với một số tùy chọn lọc ngày và tác giả đơn giản.

Trong <<ch03-git-branching#_create_new_branch>>, chúng tôi sử dụng nó với tùy chọn `--decorate` để dễ dàng hình dung vị trí các con trỏ nhánh của chúng tôi và chúng tôi cũng sử dụng tùy chọn `--graph` để xem các lịch sử phân kỳ trông như thế nào.

Trong <<ch05-distributed-git#_private_team>> và <<ch07-git-tools#_commit_ranges>>, chúng tôi đề cập đến cú pháp `branchA..branchB` để sử dụng lệnh `git log` để xem những cam kết nào là duy nhất cho một nhánh so với một nhánh khác.
Trong <<ch07-git-tools#_commit_ranges>>, chúng tôi đi qua điều này khá rộng rãi.

Trong <<ch07-git-tools#_merge_log>> và <<ch07-git-tools#_triple_dot>>, chúng tôi đề cập đến việc sử dụng định dạng `branchA...branchB` và cú pháp `--left-right` để xem những gì có trong nhánh này hoặc nhánh kia nhưng không có trong cả hai.
Trong <<ch07-git-tools#_merge_log>>, chúng tôi cũng xem xét cách sử dụng tùy chọn `--merge` để giúp gỡ lỗi xung đột hợp nhất cũng như sử dụng tùy chọn `--cc` để xem các xung đột cam kết hợp nhất trong lịch sử của bạn.

Trong <<ch07-git-tools#_git_reflog>>, chúng tôi sử dụng tùy chọn `-g` để xem Git reflog thông qua công cụ này thay vì thực hiện duyệt nhánh.

Trong <<ch07-git-tools#_searching>>, chúng tôi xem xét việc sử dụng các tùy chọn `-S` và `-L` để thực hiện các tìm kiếm khá phức tạp cho một cái gì đó đã xảy ra trong lịch sử trong mã như xem lịch sử của một hàm.

Trong <<ch07-git-tools#_signing_commits>>, chúng tôi xem cách sử dụng `--show-signature` để thêm một chuỗi xác thực vào mỗi cam kết trong đầu ra `git log` dựa trên việc nó có được ký hợp lệ hay không.

==== git stash

Lệnh `git stash` được sử dụng để lưu trữ tạm thời công việc chưa được cam kết để dọn sạch thư mục làm việc của bạn mà không cần phải cam kết công việc chưa hoàn thành trên một nhánh.

Điều này về cơ bản được đề cập hoàn toàn trong <<ch07-git-tools#_git_stashing>>.

==== git tag

Lệnh `git tag` được sử dụng để cung cấp một dấu trang vĩnh viễn cho một điểm cụ thể trong lịch sử mã.
Nói chung, điều này được sử dụng cho những thứ như phát hành.

Lệnh này được giới thiệu và đề cập chi tiết trong <<ch02-git-basics-chapter#_git_tagging>> và chúng tôi sử dụng nó trong thực tế trong <<ch05-distributed-git#_tagging_releases>>.

Chúng tôi cũng đề cập đến cách tạo thẻ được ký GPG với cờ `-s` và xác minh thẻ đó với cờ `-v` trong <<ch07-git-tools#_signing>>.

=== Chia sẻ và Cập nhật Dự án

Không có nhiều lệnh trong Git truy cập mạng, gần như tất cả các lệnh đều hoạt động trên cơ sở dữ liệu cục bộ.
Khi bạn đã sẵn sàng chia sẻ công việc của mình hoặc kéo các thay đổi từ nơi khác, có một số lệnh xử lý các kho lưu trữ từ xa.

==== git fetch

Lệnh `git fetch` giao tiếp với một kho lưu trữ từ xa và lấy xuống tất cả thông tin có trong kho lưu trữ đó mà không có trong kho lưu trữ hiện tại của bạn và lưu trữ nó trong cơ sở dữ liệu cục bộ của bạn.

Chúng tôi xem xét lệnh này lần đầu tiên trong <<ch02-git-basics-chapter#_fetching_and_pulling>> và chúng tôi tiếp tục thấy các ví dụ về việc sử dụng nó trong <<ch03-git-branching#_remote_branches>>.

Chúng tôi cũng sử dụng nó trong một số ví dụ trong <<ch05-distributed-git#_contributing_project>>.

Chúng tôi sử dụng nó để lấy một tham chiếu cụ thể duy nhất nằm ngoài không gian mặc định trong <<ch06-github#_pr_refs>> và chúng tôi xem cách lấy từ một gói (bundle) trong <<ch07-git-tools#_bundling>>.

Chúng tôi thiết lập các refspec tùy chỉnh cao để làm cho `git fetch` thực hiện điều gì đó hơi khác so với mặc định trong <<ch10-git-internals#_refspec>>.

==== git pull

Lệnh `git pull` về cơ bản là sự kết hợp của các lệnh `git fetch` và `git merge`, trong đó Git sẽ lấy từ điều khiển từ xa mà bạn chỉ định và sau đó ngay lập tức cố gắng hợp nhất nó vào nhánh bạn đang ở.

Chúng tôi giới thiệu nhanh về nó trong <<ch02-git-basics-chapter#_fetching_and_pulling>> và chỉ ra cách xem những gì nó sẽ hợp nhất nếu bạn chạy nó trong <<ch02-git-basics-chapter#_inspecting_remote>>.

Chúng tôi cũng xem cách sử dụng nó để giúp giải quyết các khó khăn khi rebase trong <<ch03-git-branching#_rebase_rebase>>.

Chúng tôi chỉ ra cách sử dụng nó với một URL để kéo các thay đổi theo kiểu một lần trong <<ch05-distributed-git#_checking_out_remotes>>.

Cuối cùng, chúng tôi đề cập rất nhanh rằng bạn có thể sử dụng tùy chọn `--verify-signatures` cho nó để xác minh rằng các cam kết bạn đang kéo đã được ký GPG trong <<ch07-git-tools#_signing_commits>>.

==== git push

Lệnh `git push` được sử dụng để giao tiếp với một kho lưu trữ khác, tính toán những gì cơ sở dữ liệu cục bộ của bạn có mà kho lưu trữ từ xa không có, và sau đó đẩy sự khác biệt vào kho lưu trữ khác.
Nó yêu cầu quyền ghi vào kho lưu trữ khác và vì vậy thường được xác thực theo cách nào đó.

Chúng tôi xem xét lệnh `git push` lần đầu tiên trong <<ch02-git-basics-chapter#_pushing_remotes>>.
Ở đây chúng tôi đề cập đến những điều cơ bản về việc đẩy một nhánh đến một kho lưu trữ từ xa.
Trong <<ch03-git-branching#_pushing_branches>>, chúng tôi đi sâu hơn một chút vào việc đẩy các nhánh cụ thể và trong <<ch03-git-branching#_tracking_branches>>, chúng tôi xem cách thiết lập các nhánh theo dõi để tự động đẩy đến.
Trong <<ch03-git-branching#_delete_branches>>, chúng tôi sử dụng cờ `--delete` để xóa một nhánh trên máy chủ bằng `git push`.

Trong suốt <<ch05-distributed-git#_contributing_project>>, chúng tôi thấy một số ví dụ về việc sử dụng `git push` để chia sẻ công việc trên các nhánh thông qua nhiều điều khiển từ xa.

Chúng tôi xem cách sử dụng nó để chia sẻ các thẻ mà bạn đã tạo với tùy chọn `--tags` trong <<ch02-git-basics-chapter#_sharing_tags>>.

Trong <<ch07-git-tools#_publishing_submodules>>, chúng tôi sử dụng tùy chọn `--recurse-submodules` để kiểm tra xem tất cả công việc mô-đun con của chúng tôi đã được xuất bản chưa trước khi đẩy siêu dự án (superproject), điều này có thể thực sự hữu ích khi sử dụng các mô-đun con.

Trong <<ch08-customizing-git#_other_client_hooks>>, chúng tôi nói ngắn gọn về hook `pre-push`, đây là một tập lệnh chúng tôi có thể thiết lập để chạy trước khi quá trình đẩy hoàn tất để xác minh rằng nó được phép đẩy.

Cuối cùng, trong <<ch10-git-internals#_pushing_refspecs>>, chúng tôi xem xét việc đẩy với một refspec đầy đủ thay vì các phím tắt chung thường được sử dụng.
Điều này có thể giúp bạn rất cụ thể về công việc bạn muốn chia sẻ.

==== git remote

Lệnh `git remote` là một công cụ quản lý cho hồ sơ của bạn về các kho lưu trữ từ xa.
Nó cho phép bạn lưu các URL dài dưới dạng các tay cầm ngắn, chẳng hạn như "`origin`" để bạn không phải nhập chúng ra mọi lúc.
Bạn có thể có một vài trong số này và lệnh `git remote` được sử dụng để thêm, thay đổi và xóa chúng.

Lệnh này được đề cập chi tiết trong <<ch02-git-basics-chapter#_remote_repos>>, bao gồm liệt kê, thêm, xóa và đổi tên chúng.

Nó cũng được sử dụng trong gần như mọi chương tiếp theo trong cuốn sách, nhưng luôn ở định dạng `git remote add <name> <url>` tiêu chuẩn.

==== git archive

Lệnh `git archive` được sử dụng để tạo tệp lưu trữ của một ảnh chụp nhanh cụ thể của dự án.

Chúng tôi sử dụng `git archive` để tạo một tarball của một dự án để chia sẻ trong <<ch05-distributed-git#_preparing_release>>.

==== git submodule

Lệnh `git submodule` được sử dụng để quản lý các kho lưu trữ bên ngoài trong một kho lưu trữ bình thường.
Điều này có thể dành cho các thư viện hoặc các loại tài nguyên được chia sẻ khác.
Lệnh `submodule` có một số lệnh phụ (`add`, `update`, `sync`, v.v.) để quản lý các tài nguyên này.

Lệnh này chỉ được đề cập và hoàn toàn được đề cập trong <<ch07-git-tools#_git_submodules>>.

=== Kiểm tra và So sánh

==== git show

Lệnh `git show` có thể hiển thị một đối tượng Git theo cách đơn giản và dễ đọc cho con người.
Thông thường, bạn sẽ sử dụng lệnh này để hiển thị thông tin về một thẻ hoặc một cam kết.

Chúng tôi sử dụng nó lần đầu tiên để hiển thị thông tin thẻ được chú thích trong <<ch02-git-basics-chapter#_annotated_tags>>.

Sau đó, chúng tôi sử dụng nó khá nhiều trong <<ch07-git-tools#_revision_selection>> để hiển thị các cam kết mà các lựa chọn sửa đổi khác nhau của chúng tôi giải quyết.

Một trong những điều thú vị hơn chúng tôi làm với `git show` là trong <<ch07-git-tools#_manual_remerge>> để trích xuất nội dung tệp cụ thể của các giai đoạn khác nhau trong quá trình xung đột hợp nhất.

==== git shortlog

Lệnh `git shortlog` được sử dụng để tóm tắt đầu ra của `git log`.
Nó sẽ lấy nhiều tùy chọn giống như lệnh `git log` sẽ làm nhưng thay vì liệt kê tất cả các cam kết, nó sẽ trình bày một bản tóm tắt các cam kết được nhóm theo tác giả.

Chúng tôi đã chỉ ra cách sử dụng nó để tạo một bảng thay đổi (changelog) đẹp trong <<ch05-distributed-git#_the_shortlog>>.

==== git describe

Lệnh `git describe` được sử dụng để lấy bất cứ thứ gì giải quyết thành một cam kết và tạo ra một chuỗi có thể đọc được và sẽ không thay đổi.
Đó là một cách để có được mô tả về một cam kết không mơ hồ như SHA-1 cam kết nhưng dễ hiểu hơn.

Chúng tôi sử dụng `git describe` trong <<ch05-distributed-git#_build_number>> và <<ch05-distributed-git#_preparing_release>> để lấy một chuỗi để đặt tên cho tệp phát hành của chúng tôi.

=== Gỡ lỗi

Git có một vài lệnh được sử dụng để giúp gỡ lỗi một vấn đề trong mã của bạn.
Điều này bao gồm từ việc tìm ra nơi một cái gì đó được giới thiệu đến việc tìm ra ai đã giới thiệu nó.

==== git bisect

Công cụ `git bisect` là một công cụ gỡ lỗi cực kỳ hữu ích được sử dụng để tìm cam kết cụ thể nào là cam kết đầu tiên giới thiệu lỗi hoặc sự cố bằng cách thực hiện tìm kiếm nhị phân tự động.

Nó được đề cập đầy đủ trong <<ch07-git-tools#_binary_search>> và chỉ được đề cập trong phần đó.

==== git blame

Lệnh `git blame` chú thích các dòng của bất kỳ tệp nào với cam kết nào là cam kết cuối cùng giới thiệu thay đổi cho từng dòng của tệp và người nào đã tạo cam kết đó.
Điều này hữu ích để tìm người để hỏi thêm thông tin về một phần cụ thể trong mã của bạn.

Nó được đề cập trong <<ch07-git-tools#_file_annotation>> và chỉ được đề cập trong phần đó.

==== git grep

Lệnh `git grep` có thể giúp bạn tìm bất kỳ chuỗi hoặc biểu thức chính quy nào trong bất kỳ tệp nào trong mã nguồn của bạn, ngay cả các phiên bản cũ hơn của dự án của bạn.

Nó được đề cập trong <<ch07-git-tools#_git_grep>> và chỉ được đề cập trong phần đó.

=== Vá lỗi

Một vài lệnh trong Git tập trung vào khái niệm suy nghĩ về các cam kết về mặt các thay đổi mà chúng giới thiệu, như thể chuỗi cam kết là một loạt các bản vá.
Các lệnh này giúp bạn quản lý các nhánh của mình theo cách này.

==== git cherry-pick

Lệnh `git cherry-pick` được sử dụng để lấy thay đổi được giới thiệu trong một cam kết Git duy nhất và cố gắng giới thiệu lại nó như một cam kết mới trên nhánh bạn đang ở.
Điều này có thể hữu ích để chỉ lấy một hoặc hai cam kết từ một nhánh riêng lẻ thay vì hợp nhất trong nhánh lấy tất cả các thay đổi.

Cherry picking được mô tả và minh họa trong <<ch05-distributed-git#_rebase_cherry_pick>>.

==== git rebase

Lệnh `git rebase` về cơ bản là một `cherry-pick` tự động.
Nó xác định một loạt các cam kết và sau đó cherry-pick chúng từng cái một theo cùng một thứ tự ở một nơi khác.

Rebasing được đề cập chi tiết trong <<ch03-git-branching#_rebasing>>, bao gồm việc đề cập đến các vấn đề cộng tác liên quan đến việc rebase các nhánh đã công khai.

Chúng tôi sử dụng nó trong thực tế trong một ví dụ về việc chia lịch sử của bạn thành hai kho lưu trữ riêng biệt trong <<ch07-git-tools#_replace>>, sử dụng cờ `--onto` cũng vậy.

Chúng tôi đi qua việc gặp xung đột hợp nhất trong quá trình rebase trong <<ch07-git-tools#ref_rerere>>.

Chúng tôi cũng sử dụng nó trong chế độ viết kịch bản tương tác với tùy chọn `-i` trong <<ch07-git-tools#_changing_multiple>>.

==== git revert

Lệnh `git revert` về cơ bản là một `git cherry-pick` ngược lại.
Nó tạo ra một cam kết mới áp dụng chính xác ngược lại thay đổi được giới thiệu trong cam kết bạn đang nhắm mục tiêu, về cơ bản là hoàn tác hoặc đảo ngược nó.

Chúng tôi sử dụng điều này trong <<ch07-git-tools#_reverse_commit>> để hoàn tác một cam kết hợp nhất.

=== Email

Nhiều dự án Git, bao gồm cả chính Git, được duy trì hoàn toàn qua danh sách gửi thư.
Git có một số công cụ được tích hợp sẵn giúp quá trình này dễ dàng hơn, từ việc tạo các bản vá bạn có thể dễ dàng gửi email đến việc áp dụng các bản vá đó từ hộp thư email.

==== git apply

Lệnh `git apply` áp dụng một bản vá được tạo bằng lệnh `git diff` hoặc thậm chí là GNU diff.
Nó tương tự như những gì lệnh `patch` có thể làm với một vài khác biệt nhỏ.

Chúng tôi minh họa việc sử dụng nó và các trường hợp bạn có thể làm như vậy trong <<ch05-distributed-git#_patches_from_email>>.

==== git am

Lệnh `git am` được sử dụng để áp dụng các bản vá từ hộp thư đến email, cụ thể là hộp thư được định dạng mbox.
Điều này hữu ích để nhận các bản vá qua email và áp dụng chúng vào dự án của bạn một cách dễ dàng.

Chúng tôi đã đề cập đến cách sử dụng và quy trình làm việc xung quanh `git am` trong <<ch05-distributed-git#_git_am>> bao gồm sử dụng các tùy chọn `--resolved`, `-i` và `-3`.

Ngoài ra còn có một số hook bạn có thể sử dụng để trợ giúp quy trình làm việc xung quanh `git am` và tất cả chúng đều được đề cập trong <<ch08-customizing-git#_email_hooks>>.

Chúng tôi cũng sử dụng nó để áp dụng các thay đổi Yêu cầu Kéo (Pull Request) GitHub được định dạng bản vá trong <<ch06-github#_email_notifications>>.

==== git format-patch

Lệnh `git format-patch` được sử dụng để tạo một loạt các bản vá ở định dạng mbox mà bạn có thể sử dụng để gửi đến danh sách gửi thư được định dạng đúng.

Chúng tôi đi qua một ví dụ về việc đóng góp cho một dự án bằng công cụ `git format-patch` trong <<ch05-distributed-git#_project_over_email>>.

==== git imap-send

Lệnh `git imap-send` tải lên một hộp thư được tạo bằng `git format-patch` vào thư mục nháp IMAP.

Chúng tôi đi qua một ví dụ về việc đóng góp cho một dự án bằng cách gửi các bản vá bằng công cụ `git imap-send` trong <<ch05-distributed-git#_project_over_email>>.

==== git send-email

Lệnh `git send-email` được sử dụng để gửi các bản vá được tạo bằng `git format-patch` qua email.

Chúng tôi đi qua một ví dụ về việc đóng góp cho một dự án bằng cách gửi các bản vá bằng công cụ `git send-email` trong <<ch05-distributed-git#_project_over_email>>.

==== git request-pull

Lệnh `git request-pull` chỉ đơn giản là được sử dụng để tạo một nội dung thư ví dụ để gửi email cho ai đó.
Nếu bạn có một nhánh trên máy chủ công cộng và muốn cho ai đó biết cách tích hợp những thay đổi đó mà không cần gửi các bản vá qua email, bạn có thể chạy lệnh này và gửi đầu ra cho người bạn muốn kéo các thay đổi vào.

Chúng tôi minh họa cách sử dụng `git request-pull` để tạo thông báo kéo trong <<ch05-distributed-git#_public_project>>.

=== Hệ thống Bên ngoài

Git đi kèm với một vài lệnh để tích hợp với các hệ thống kiểm soát phiên bản khác.

==== git svn

Lệnh `git svn` được sử dụng để giao tiếp với hệ thống kiểm soát phiên bản Subversion như một máy khách.
Điều này có nghĩa là bạn có thể sử dụng Git để kiểm xuất từ và cam kết với máy chủ Subversion.

Lệnh này được đề cập sâu trong <<ch09-git-and-other-systems#_git_svn>>.

==== git fast-import

Đối với các hệ thống kiểm soát phiên bản khác hoặc nhập từ gần như bất kỳ định dạng nào, bạn có thể sử dụng `git fast-import` để nhanh chóng ánh xạ định dạng khác sang thứ gì đó mà Git có thể dễ dàng ghi lại.

Lệnh này được đề cập sâu trong <<ch09-git-and-other-systems#_custom_importer>>.

=== Quản trị

Nếu bạn đang quản trị một kho lưu trữ Git hoặc cần sửa chữa một cái gì đó theo cách lớn, Git cung cấp một số lệnh quản trị để giúp bạn.

==== git gc

Lệnh `git gc` chạy "`garbage collection`" (thu gom rác) trên kho lưu trữ của bạn, xóa các tệp không cần thiết trong cơ sở dữ liệu của bạn và đóng gói các tệp còn lại thành một định dạng hiệu quả hơn.

Lệnh này thường chạy trong nền cho bạn, mặc dù bạn có thể chạy thủ công nếu muốn.
Chúng tôi đi qua một số ví dụ về điều này trong <<ch10-git-internals#_git_gc>>.

==== git fsck

Lệnh `git fsck` được sử dụng để kiểm tra cơ sở dữ liệu nội bộ xem có vấn đề hoặc sự không nhất quán nào không.

Chúng tôi chỉ sử dụng nhanh điều này một lần trong <<ch10-git-internals#_data_recovery>> để tìm kiếm các đối tượng lơ lửng.

==== git reflog

Lệnh `git reflog` đi qua một nhật ký về nơi tất cả các đầu của các nhánh của bạn đã ở khi bạn làm việc để tìm các cam kết bạn có thể đã mất thông qua việc viết lại lịch sử.

Chúng tôi đề cập đến lệnh này chủ yếu trong <<ch07-git-tools#_git_reflog>>, nơi chúng tôi hiển thị cách sử dụng bình thường và cách sử dụng `git log -g` để xem cùng một thông tin với đầu ra `git log`.

Chúng tôi cũng đi qua một ví dụ thực tế về việc khôi phục một nhánh bị mất như vậy trong <<ch10-git-internals#_data_recovery>>.

==== git filter-branch

Lệnh `git filter-branch` được sử dụng để viết lại vô số cam kết theo các mẫu nhất định, chẳng hạn như xóa một tệp ở mọi nơi hoặc lọc toàn bộ kho lưu trữ xuống một thư mục con duy nhất để trích xuất một dự án.

Trong <<ch07-git-tools#_removing_file_every_commit>>, chúng tôi giải thích lệnh và khám phá một số tùy chọn khác nhau như `--commit-filter`, `--subdirectory-filter` và `--tree-filter`.

Trong <<ch09-git-and-other-systems#_git_p4>>, chúng tôi sử dụng nó để sửa chữa các kho lưu trữ bên ngoài đã nhập.

=== Các Lệnh Plumbing

Cũng có khá nhiều lệnh plumbing cấp thấp hơn mà chúng tôi đã gặp trong cuốn sách.

Lệnh đầu tiên chúng tôi gặp là `ls-remote` trong <<ch06-github#_pr_refs>> mà chúng tôi sử dụng để xem các tham chiếu thô trên máy chủ.

Chúng tôi sử dụng `ls-files` trong <<ch07-git-tools#_manual_remerge>>, <<ch07-git-tools#ref_rerere>> và <<ch07-git-tools#_the_index>> để có cái nhìn thô hơn về khu vực tổ chức của bạn trông như thế nào.

Chúng tôi cũng đề cập đến `rev-parse` trong <<ch07-git-tools#_branch_references>> để lấy bất kỳ chuỗi nào và biến nó thành một đối tượng SHA-1.

Tuy nhiên, hầu hết các lệnh plumbing cấp thấp mà chúng tôi đề cập đều nằm trong <<ch10-git-internals#ch10-git-internals>>, ít nhiều là những gì chương này tập trung vào.
Chúng tôi đã cố gắng tránh sử dụng chúng trong hầu hết phần còn lại của cuốn sách.
